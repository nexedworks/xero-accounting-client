mod progenitor_client;

use std::fmt::Write as _;

#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a TryFrom or FromStr implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///Account
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountID": {
    ///      "description": "The Xero identifier for an account – specified as a
    /// string following  the endpoint name   e.g.
    /// /297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "AddToWatchlist": {
    ///      "description": "Boolean – describes whether the account is shown in
    /// the watchlist widget on the dashboard",
    ///      "type": "boolean"
    ///    },
    ///    "BankAccountNumber": {
    ///      "description": "For bank accounts only (Account Type BANK)",
    ///      "type": "string"
    ///    },
    ///    "BankAccountType": {
    ///      "description": "For bank accounts only. See Bank Account types",
    ///      "type": "string",
    ///      "enum": [
    ///        "BANK",
    ///        "CREDITCARD",
    ///        "PAYPAL",
    ///        "NONE",
    ///        ""
    ///      ]
    ///    },
    ///    "Class": {
    ///      "description": "See Account Class Types",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "enum": [
    ///        "ASSET",
    ///        "EQUITY",
    ///        "EXPENSE",
    ///        "LIABILITY",
    ///        "REVENUE"
    ///      ]
    ///    },
    ///    "Code": {
    ///      "description": "Customer defined alpha numeric account code e.g 200
    /// or SALES (max length = 10)",
    ///      "examples": [
    ///        4400
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "Description": {
    ///      "description": "Description of the Account. Valid for all types of
    /// accounts except bank accounts (max length = 4000)",
    ///      "type": "string"
    ///    },
    ///    "EnablePaymentsToAccount": {
    ///      "description": "Boolean – describes whether account can have
    /// payments applied to it",
    ///      "type": "boolean"
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if an account has an attachment
    /// (read only)",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Name": {
    ///      "description": "Name of account (max length = 150)",
    ///      "examples": [
    ///        "Food Sales"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 150
    ///    },
    ///    "ReportingCode": {
    ///      "description": "Shown if set",
    ///      "type": "string"
    ///    },
    ///    "ReportingCodeName": {
    ///      "description": "Shown if set",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "ShowInExpenseClaims": {
    ///      "description": "Boolean – describes whether account code is
    /// available for use with expense claims",
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "Accounts with a status of ACTIVE can be updated to
    /// ARCHIVED. See Account Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "ARCHIVED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "SystemAccount": {
    ///      "description": "If this is a system account then this element is
    /// returned. See System Account types. Note that non-system accounts may
    /// have this element set as either “” or null.",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "enum": [
    ///        "DEBTORS",
    ///        "CREDITORS",
    ///        "BANKCURRENCYGAIN",
    ///        "GST",
    ///        "GSTONIMPORTS",
    ///        "HISTORICAL",
    ///        "REALISEDCURRENCYGAIN",
    ///        "RETAINEDEARNINGS",
    ///        "ROUNDING",
    ///        "TRACKINGTRANSFERS",
    ///        "UNPAIDEXPCLM",
    ///        "UNREALISEDCURRENCYGAIN",
    ///        "WAGEPAYABLES",
    ///        "CISASSETS",
    ///        "CISASSET",
    ///        "CISLABOUR",
    ///        "CISLABOUREXPENSE",
    ///        "CISLABOURINCOME",
    ///        "CISLIABILITY",
    ///        "CISMATERIALS",
    ///        ""
    ///      ]
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type from taxRates",
    ///      "type": "string"
    ///    },
    ///    "Type": {
    ///      "$ref": "#/components/schemas/AccountType"
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Account {
        ///The Xero identifier for an account – specified as a string following
        /// the endpoint name   e.g. /297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(rename = "AccountID", default, skip_serializing_if = "Option::is_none")]
        pub account_id: Option<uuid::Uuid>,
        ///Boolean – describes whether the account is shown in the watchlist
        /// widget on the dashboard
        #[serde(
            rename = "AddToWatchlist",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub add_to_watchlist: Option<bool>,
        ///For bank accounts only (Account Type BANK)
        #[serde(
            rename = "BankAccountNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_number: Option<String>,
        ///For bank accounts only. See Bank Account types
        #[serde(
            rename = "BankAccountType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_type: Option<AccountBankAccountType>,
        ///See Account Class Types
        #[serde(rename = "Class", default, skip_serializing_if = "Option::is_none")]
        pub class: Option<AccountClass>,
        ///Customer defined alpha numeric account code e.g 200 or SALES (max
        /// length = 10)
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        ///Description of the Account. Valid for all types of accounts except
        /// bank accounts (max length = 4000)
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        ///Boolean – describes whether account can have payments applied to it
        #[serde(
            rename = "EnablePaymentsToAccount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub enable_payments_to_account: Option<bool>,
        ///boolean to indicate if an account has an attachment (read only)
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///Name of account (max length = 150)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<AccountName>,
        ///Shown if set
        #[serde(
            rename = "ReportingCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_code: Option<String>,
        ///Shown if set
        #[serde(
            rename = "ReportingCodeName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_code_name: Option<String>,
        ///Boolean – describes whether account code is available for use with
        /// expense claims
        #[serde(
            rename = "ShowInExpenseClaims",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub show_in_expense_claims: Option<bool>,
        ///Accounts with a status of ACTIVE can be updated to ARCHIVED. See
        /// Account Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<AccountStatus>,
        ///If this is a system account then this element is returned. See
        /// System Account types. Note that non-system accounts may have this
        /// element set as either “” or null.
        #[serde(
            rename = "SystemAccount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub system_account: Option<AccountSystemAccount>,
        ///The tax type from taxRates
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<AccountType>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Account> for Account {
        fn from(value: &Account) -> Self {
            value.clone()
        }
    }

    ///For bank accounts only. See Bank Account types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "For bank accounts only. See Bank Account types",
    ///  "type": "string",
    ///  "enum": [
    ///    "BANK",
    ///    "CREDITCARD",
    ///    "PAYPAL",
    ///    "NONE",
    ///    ""
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccountBankAccountType {
        #[serde(rename = "BANK")]
        Bank,
        #[serde(rename = "CREDITCARD")]
        Creditcard,
        #[serde(rename = "PAYPAL")]
        Paypal,
        #[serde(rename = "NONE")]
        None,
        #[serde(rename = "")]
        X,
    }

    impl From<&AccountBankAccountType> for AccountBankAccountType {
        fn from(value: &AccountBankAccountType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccountBankAccountType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bank => write!(f, "BANK"),
                Self::Creditcard => write!(f, "CREDITCARD"),
                Self::Paypal => write!(f, "PAYPAL"),
                Self::None => write!(f, "NONE"),
                Self::X => write!(f, ""),
            }
        }
    }

    impl std::str::FromStr for AccountBankAccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BANK" => Ok(Self::Bank),
                "CREDITCARD" => Ok(Self::Creditcard),
                "PAYPAL" => Ok(Self::Paypal),
                "NONE" => Ok(Self::None),
                "" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccountBankAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccountBankAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccountBankAccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Account Class Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Account Class Types",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "ASSET",
    ///    "EQUITY",
    ///    "EXPENSE",
    ///    "LIABILITY",
    ///    "REVENUE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccountClass {
        #[serde(rename = "ASSET")]
        Asset,
        #[serde(rename = "EQUITY")]
        Equity,
        #[serde(rename = "EXPENSE")]
        Expense,
        #[serde(rename = "LIABILITY")]
        Liability,
        #[serde(rename = "REVENUE")]
        Revenue,
    }

    impl From<&AccountClass> for AccountClass {
        fn from(value: &AccountClass) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccountClass {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asset => write!(f, "ASSET"),
                Self::Equity => write!(f, "EQUITY"),
                Self::Expense => write!(f, "EXPENSE"),
                Self::Liability => write!(f, "LIABILITY"),
                Self::Revenue => write!(f, "REVENUE"),
            }
        }
    }

    impl std::str::FromStr for AccountClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ASSET" => Ok(Self::Asset),
                "EQUITY" => Ok(Self::Equity),
                "EXPENSE" => Ok(Self::Expense),
                "LIABILITY" => Ok(Self::Liability),
                "REVENUE" => Ok(Self::Revenue),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccountClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccountClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccountClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Name of account (max length = 150)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Name of account (max length = 150)",
    ///  "examples": [
    ///    "Food Sales"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 150
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AccountName(String);
    impl ::std::ops::Deref for AccountName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AccountName> for String {
        fn from(value: AccountName) -> Self {
            value.0
        }
    }

    impl From<&AccountName> for AccountName {
        fn from(value: &AccountName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AccountName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 150usize {
                return Err("longer than 150 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AccountName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AccountName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Accounts with a status of ACTIVE can be updated to ARCHIVED. See Account
    /// Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Accounts with a status of ACTIVE can be updated to
    /// ARCHIVED. See Account Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "ARCHIVED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccountStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&AccountStatus> for AccountStatus {
        fn from(value: &AccountStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccountStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for AccountStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "ARCHIVED" => Ok(Self::Archived),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccountStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccountStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccountStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///If this is a system account then this element is returned. See System
    /// Account types. Note that non-system accounts may have this element set
    /// as either “” or null.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If this is a system account then this element is
    /// returned. See System Account types. Note that non-system accounts may
    /// have this element set as either “” or null.",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "DEBTORS",
    ///    "CREDITORS",
    ///    "BANKCURRENCYGAIN",
    ///    "GST",
    ///    "GSTONIMPORTS",
    ///    "HISTORICAL",
    ///    "REALISEDCURRENCYGAIN",
    ///    "RETAINEDEARNINGS",
    ///    "ROUNDING",
    ///    "TRACKINGTRANSFERS",
    ///    "UNPAIDEXPCLM",
    ///    "UNREALISEDCURRENCYGAIN",
    ///    "WAGEPAYABLES",
    ///    "CISASSETS",
    ///    "CISASSET",
    ///    "CISLABOUR",
    ///    "CISLABOUREXPENSE",
    ///    "CISLABOURINCOME",
    ///    "CISLIABILITY",
    ///    "CISMATERIALS",
    ///    ""
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccountSystemAccount {
        #[serde(rename = "DEBTORS")]
        Debtors,
        #[serde(rename = "CREDITORS")]
        Creditors,
        #[serde(rename = "BANKCURRENCYGAIN")]
        Bankcurrencygain,
        #[serde(rename = "GST")]
        Gst,
        #[serde(rename = "GSTONIMPORTS")]
        Gstonimports,
        #[serde(rename = "HISTORICAL")]
        Historical,
        #[serde(rename = "REALISEDCURRENCYGAIN")]
        Realisedcurrencygain,
        #[serde(rename = "RETAINEDEARNINGS")]
        Retainedearnings,
        #[serde(rename = "ROUNDING")]
        Rounding,
        #[serde(rename = "TRACKINGTRANSFERS")]
        Trackingtransfers,
        #[serde(rename = "UNPAIDEXPCLM")]
        Unpaidexpclm,
        #[serde(rename = "UNREALISEDCURRENCYGAIN")]
        Unrealisedcurrencygain,
        #[serde(rename = "WAGEPAYABLES")]
        Wagepayables,
        #[serde(rename = "CISASSETS")]
        Cisassets,
        #[serde(rename = "CISASSET")]
        Cisasset,
        #[serde(rename = "CISLABOUR")]
        Cislabour,
        #[serde(rename = "CISLABOUREXPENSE")]
        Cislabourexpense,
        #[serde(rename = "CISLABOURINCOME")]
        Cislabourincome,
        #[serde(rename = "CISLIABILITY")]
        Cisliability,
        #[serde(rename = "CISMATERIALS")]
        Cismaterials,
        #[serde(rename = "")]
        X,
    }

    impl From<&AccountSystemAccount> for AccountSystemAccount {
        fn from(value: &AccountSystemAccount) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccountSystemAccount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Debtors => write!(f, "DEBTORS"),
                Self::Creditors => write!(f, "CREDITORS"),
                Self::Bankcurrencygain => write!(f, "BANKCURRENCYGAIN"),
                Self::Gst => write!(f, "GST"),
                Self::Gstonimports => write!(f, "GSTONIMPORTS"),
                Self::Historical => write!(f, "HISTORICAL"),
                Self::Realisedcurrencygain => write!(f, "REALISEDCURRENCYGAIN"),
                Self::Retainedearnings => write!(f, "RETAINEDEARNINGS"),
                Self::Rounding => write!(f, "ROUNDING"),
                Self::Trackingtransfers => write!(f, "TRACKINGTRANSFERS"),
                Self::Unpaidexpclm => write!(f, "UNPAIDEXPCLM"),
                Self::Unrealisedcurrencygain => write!(f, "UNREALISEDCURRENCYGAIN"),
                Self::Wagepayables => write!(f, "WAGEPAYABLES"),
                Self::Cisassets => write!(f, "CISASSETS"),
                Self::Cisasset => write!(f, "CISASSET"),
                Self::Cislabour => write!(f, "CISLABOUR"),
                Self::Cislabourexpense => write!(f, "CISLABOUREXPENSE"),
                Self::Cislabourincome => write!(f, "CISLABOURINCOME"),
                Self::Cisliability => write!(f, "CISLIABILITY"),
                Self::Cismaterials => write!(f, "CISMATERIALS"),
                Self::X => write!(f, ""),
            }
        }
    }

    impl std::str::FromStr for AccountSystemAccount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DEBTORS" => Ok(Self::Debtors),
                "CREDITORS" => Ok(Self::Creditors),
                "BANKCURRENCYGAIN" => Ok(Self::Bankcurrencygain),
                "GST" => Ok(Self::Gst),
                "GSTONIMPORTS" => Ok(Self::Gstonimports),
                "HISTORICAL" => Ok(Self::Historical),
                "REALISEDCURRENCYGAIN" => Ok(Self::Realisedcurrencygain),
                "RETAINEDEARNINGS" => Ok(Self::Retainedearnings),
                "ROUNDING" => Ok(Self::Rounding),
                "TRACKINGTRANSFERS" => Ok(Self::Trackingtransfers),
                "UNPAIDEXPCLM" => Ok(Self::Unpaidexpclm),
                "UNREALISEDCURRENCYGAIN" => Ok(Self::Unrealisedcurrencygain),
                "WAGEPAYABLES" => Ok(Self::Wagepayables),
                "CISASSETS" => Ok(Self::Cisassets),
                "CISASSET" => Ok(Self::Cisasset),
                "CISLABOUR" => Ok(Self::Cislabour),
                "CISLABOUREXPENSE" => Ok(Self::Cislabourexpense),
                "CISLABOURINCOME" => Ok(Self::Cislabourincome),
                "CISLIABILITY" => Ok(Self::Cisliability),
                "CISMATERIALS" => Ok(Self::Cismaterials),
                "" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccountSystemAccount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccountSystemAccount {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccountSystemAccount {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Account Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Account Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "BANK",
    ///    "CURRENT",
    ///    "CURRLIAB",
    ///    "DEPRECIATN",
    ///    "DIRECTCOSTS",
    ///    "EQUITY",
    ///    "EXPENSE",
    ///    "FIXED",
    ///    "INVENTORY",
    ///    "LIABILITY",
    ///    "NONCURRENT",
    ///    "OTHERINCOME",
    ///    "OVERHEADS",
    ///    "PREPAYMENT",
    ///    "REVENUE",
    ///    "SALES",
    ///    "TERMLIAB",
    ///    "PAYG"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccountType {
        #[serde(rename = "BANK")]
        Bank,
        #[serde(rename = "CURRENT")]
        Current,
        #[serde(rename = "CURRLIAB")]
        Currliab,
        #[serde(rename = "DEPRECIATN")]
        Depreciatn,
        #[serde(rename = "DIRECTCOSTS")]
        Directcosts,
        #[serde(rename = "EQUITY")]
        Equity,
        #[serde(rename = "EXPENSE")]
        Expense,
        #[serde(rename = "FIXED")]
        Fixed,
        #[serde(rename = "INVENTORY")]
        Inventory,
        #[serde(rename = "LIABILITY")]
        Liability,
        #[serde(rename = "NONCURRENT")]
        Noncurrent,
        #[serde(rename = "OTHERINCOME")]
        Otherincome,
        #[serde(rename = "OVERHEADS")]
        Overheads,
        #[serde(rename = "PREPAYMENT")]
        Prepayment,
        #[serde(rename = "REVENUE")]
        Revenue,
        #[serde(rename = "SALES")]
        Sales,
        #[serde(rename = "TERMLIAB")]
        Termliab,
        #[serde(rename = "PAYG")]
        Payg,
    }

    impl From<&AccountType> for AccountType {
        fn from(value: &AccountType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccountType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bank => write!(f, "BANK"),
                Self::Current => write!(f, "CURRENT"),
                Self::Currliab => write!(f, "CURRLIAB"),
                Self::Depreciatn => write!(f, "DEPRECIATN"),
                Self::Directcosts => write!(f, "DIRECTCOSTS"),
                Self::Equity => write!(f, "EQUITY"),
                Self::Expense => write!(f, "EXPENSE"),
                Self::Fixed => write!(f, "FIXED"),
                Self::Inventory => write!(f, "INVENTORY"),
                Self::Liability => write!(f, "LIABILITY"),
                Self::Noncurrent => write!(f, "NONCURRENT"),
                Self::Otherincome => write!(f, "OTHERINCOME"),
                Self::Overheads => write!(f, "OVERHEADS"),
                Self::Prepayment => write!(f, "PREPAYMENT"),
                Self::Revenue => write!(f, "REVENUE"),
                Self::Sales => write!(f, "SALES"),
                Self::Termliab => write!(f, "TERMLIAB"),
                Self::Payg => write!(f, "PAYG"),
            }
        }
    }

    impl std::str::FromStr for AccountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BANK" => Ok(Self::Bank),
                "CURRENT" => Ok(Self::Current),
                "CURRLIAB" => Ok(Self::Currliab),
                "DEPRECIATN" => Ok(Self::Depreciatn),
                "DIRECTCOSTS" => Ok(Self::Directcosts),
                "EQUITY" => Ok(Self::Equity),
                "EXPENSE" => Ok(Self::Expense),
                "FIXED" => Ok(Self::Fixed),
                "INVENTORY" => Ok(Self::Inventory),
                "LIABILITY" => Ok(Self::Liability),
                "NONCURRENT" => Ok(Self::Noncurrent),
                "OTHERINCOME" => Ok(Self::Otherincome),
                "OVERHEADS" => Ok(Self::Overheads),
                "PREPAYMENT" => Ok(Self::Prepayment),
                "REVENUE" => Ok(Self::Revenue),
                "SALES" => Ok(Self::Sales),
                "TERMLIAB" => Ok(Self::Termliab),
                "PAYG" => Ok(Self::Payg),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Accounts
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Account"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "accounts"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Accounts {
        #[serde(rename = "Accounts", default, skip_serializing_if = "Vec::is_empty")]
        pub accounts: Vec<Account>,
    }

    impl From<&Accounts> for Accounts {
        fn from(value: &Accounts) -> Self {
            value.clone()
        }
    }

    ///AccountsPayable
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Outstanding": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Overdue": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountsPayable {
        #[serde(
            rename = "Outstanding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub outstanding: Option<f64>,
        #[serde(rename = "Overdue", default, skip_serializing_if = "Option::is_none")]
        pub overdue: Option<f64>,
    }

    impl From<&AccountsPayable> for AccountsPayable {
        fn from(value: &AccountsPayable) -> Self {
            value.clone()
        }
    }

    ///AccountsReceivable
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Outstanding": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Overdue": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountsReceivable {
        #[serde(
            rename = "Outstanding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub outstanding: Option<f64>,
        #[serde(rename = "Overdue", default, skip_serializing_if = "Option::is_none")]
        pub overdue: Option<f64>,
    }

    impl From<&AccountsReceivable> for AccountsReceivable {
        fn from(value: &AccountsReceivable) -> Self {
            value.clone()
        }
    }

    ///Action
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Name": {
    ///      "description": "Name of the actions for this organisation",
    ///      "examples": [
    ///        "UseMulticurrency"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "Status": {
    ///      "description": "Status of the action for this organisation",
    ///      "type": "string",
    ///      "enum": [
    ///        "ALLOWED",
    ///        "NOT-ALLOWED"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Action {
        ///Name of the actions for this organisation
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///Status of the action for this organisation
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ActionStatus>,
    }

    impl From<&Action> for Action {
        fn from(value: &Action) -> Self {
            value.clone()
        }
    }

    ///Status of the action for this organisation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Status of the action for this organisation",
    ///  "type": "string",
    ///  "enum": [
    ///    "ALLOWED",
    ///    "NOT-ALLOWED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ActionStatus {
        #[serde(rename = "ALLOWED")]
        Allowed,
        #[serde(rename = "NOT-ALLOWED")]
        NotAllowed,
    }

    impl From<&ActionStatus> for ActionStatus {
        fn from(value: &ActionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ActionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allowed => write!(f, "ALLOWED"),
                Self::NotAllowed => write!(f, "NOT-ALLOWED"),
            }
        }
    }

    impl std::str::FromStr for ActionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ALLOWED" => Ok(Self::Allowed),
                "NOT-ALLOWED" => Ok(Self::NotAllowed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ActionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ActionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ActionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Actions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Actions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Action"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "actions"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Actions {
        #[serde(rename = "Actions", default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<Action>,
    }

    impl From<&Actions> for Actions {
        fn from(value: &Actions) -> Self {
            value.clone()
        }
    }

    ///Address
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AddressLine1": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine2": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine3": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine4": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressType": {
    ///      "description": "define the type of address",
    ///      "type": "string",
    ///      "enum": [
    ///        "POBOX",
    ///        "STREET"
    ///      ]
    ///    },
    ///    "AttentionTo": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "City": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Country": {
    ///      "description": "max length = 50, [A-Z], [a-z] only",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "PostalCode": {
    ///      "description": "max length = 50",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "Region": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Address {
        ///max length = 500
        #[serde(
            rename = "AddressLine1",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line1: Option<AddressAddressLine1>,
        ///max length = 500
        #[serde(
            rename = "AddressLine2",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line2: Option<AddressAddressLine2>,
        ///max length = 500
        #[serde(
            rename = "AddressLine3",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line3: Option<AddressAddressLine3>,
        ///max length = 500
        #[serde(
            rename = "AddressLine4",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line4: Option<AddressAddressLine4>,
        ///define the type of address
        #[serde(
            rename = "AddressType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_type: Option<AddressAddressType>,
        ///max length = 255
        #[serde(
            rename = "AttentionTo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub attention_to: Option<AddressAttentionTo>,
        ///max length = 255
        #[serde(rename = "City", default, skip_serializing_if = "Option::is_none")]
        pub city: Option<AddressCity>,
        ///max length = 50, [A-Z], [a-z] only
        #[serde(rename = "Country", default, skip_serializing_if = "Option::is_none")]
        pub country: Option<AddressCountry>,
        ///max length = 50
        #[serde(
            rename = "PostalCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub postal_code: Option<AddressPostalCode>,
        ///max length = 255
        #[serde(rename = "Region", default, skip_serializing_if = "Option::is_none")]
        pub region: Option<AddressRegion>,
    }

    impl From<&Address> for Address {
        fn from(value: &Address) -> Self {
            value.clone()
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressAddressLine1(String);
    impl ::std::ops::Deref for AddressAddressLine1 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressAddressLine1> for String {
        fn from(value: AddressAddressLine1) -> Self {
            value.0
        }
    }

    impl From<&AddressAddressLine1> for AddressAddressLine1 {
        fn from(value: &AddressAddressLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressAddressLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressAddressLine1 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressAddressLine2(String);
    impl ::std::ops::Deref for AddressAddressLine2 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressAddressLine2> for String {
        fn from(value: AddressAddressLine2) -> Self {
            value.0
        }
    }

    impl From<&AddressAddressLine2> for AddressAddressLine2 {
        fn from(value: &AddressAddressLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressAddressLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressAddressLine2 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressAddressLine3(String);
    impl ::std::ops::Deref for AddressAddressLine3 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressAddressLine3> for String {
        fn from(value: AddressAddressLine3) -> Self {
            value.0
        }
    }

    impl From<&AddressAddressLine3> for AddressAddressLine3 {
        fn from(value: &AddressAddressLine3) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressAddressLine3 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressAddressLine3 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressAddressLine4(String);
    impl ::std::ops::Deref for AddressAddressLine4 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressAddressLine4> for String {
        fn from(value: AddressAddressLine4) -> Self {
            value.0
        }
    }

    impl From<&AddressAddressLine4> for AddressAddressLine4 {
        fn from(value: &AddressAddressLine4) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressAddressLine4 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressAddressLine4 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///define the type of address
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "define the type of address",
    ///  "type": "string",
    ///  "enum": [
    ///    "POBOX",
    ///    "STREET"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AddressAddressType {
        #[serde(rename = "POBOX")]
        Pobox,
        #[serde(rename = "STREET")]
        Street,
    }

    impl From<&AddressAddressType> for AddressAddressType {
        fn from(value: &AddressAddressType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddressAddressType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pobox => write!(f, "POBOX"),
                Self::Street => write!(f, "STREET"),
            }
        }
    }

    impl std::str::FromStr for AddressAddressType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "POBOX" => Ok(Self::Pobox),
                "STREET" => Ok(Self::Street),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AddressAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AddressAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AddressAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressAttentionTo(String);
    impl ::std::ops::Deref for AddressAttentionTo {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressAttentionTo> for String {
        fn from(value: AddressAttentionTo) -> Self {
            value.0
        }
    }

    impl From<&AddressAttentionTo> for AddressAttentionTo {
        fn from(value: &AddressAttentionTo) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressAttentionTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressAttentionTo {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressCity(String);
    impl ::std::ops::Deref for AddressCity {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressCity> for String {
        fn from(value: AddressCity) -> Self {
            value.0
        }
    }

    impl From<&AddressCity> for AddressCity {
        fn from(value: &AddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressCity {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 50, [A-Z], [a-z] only
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 50, [A-Z], [a-z] only",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressCountry(String);
    impl ::std::ops::Deref for AddressCountry {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressCountry> for String {
        fn from(value: AddressCountry) -> Self {
            value.0
        }
    }

    impl From<&AddressCountry> for AddressCountry {
        fn from(value: &AddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressCountry {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///AddressForOrganisation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AddressLine1": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine2": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine3": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressLine4": {
    ///      "description": "max length = 500",
    ///      "type": "string",
    ///      "maxLength": 500
    ///    },
    ///    "AddressType": {
    ///      "description": "define the type of address",
    ///      "type": "string",
    ///      "enum": [
    ///        "POBOX",
    ///        "STREET",
    ///        "DELIVERY"
    ///      ]
    ///    },
    ///    "AttentionTo": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "City": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Country": {
    ///      "description": "max length = 50, [A-Z], [a-z] only",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "PostalCode": {
    ///      "description": "max length = 50",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "Region": {
    ///      "description": "max length = 255",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddressForOrganisation {
        ///max length = 500
        #[serde(
            rename = "AddressLine1",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line1: Option<AddressForOrganisationAddressLine1>,
        ///max length = 500
        #[serde(
            rename = "AddressLine2",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line2: Option<AddressForOrganisationAddressLine2>,
        ///max length = 500
        #[serde(
            rename = "AddressLine3",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line3: Option<AddressForOrganisationAddressLine3>,
        ///max length = 500
        #[serde(
            rename = "AddressLine4",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line4: Option<AddressForOrganisationAddressLine4>,
        ///define the type of address
        #[serde(
            rename = "AddressType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_type: Option<AddressForOrganisationAddressType>,
        ///max length = 255
        #[serde(
            rename = "AttentionTo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub attention_to: Option<AddressForOrganisationAttentionTo>,
        ///max length = 255
        #[serde(rename = "City", default, skip_serializing_if = "Option::is_none")]
        pub city: Option<AddressForOrganisationCity>,
        ///max length = 50, [A-Z], [a-z] only
        #[serde(rename = "Country", default, skip_serializing_if = "Option::is_none")]
        pub country: Option<AddressForOrganisationCountry>,
        ///max length = 50
        #[serde(
            rename = "PostalCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub postal_code: Option<AddressForOrganisationPostalCode>,
        ///max length = 255
        #[serde(rename = "Region", default, skip_serializing_if = "Option::is_none")]
        pub region: Option<AddressForOrganisationRegion>,
    }

    impl From<&AddressForOrganisation> for AddressForOrganisation {
        fn from(value: &AddressForOrganisation) -> Self {
            value.clone()
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationAddressLine1(String);
    impl ::std::ops::Deref for AddressForOrganisationAddressLine1 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationAddressLine1> for String {
        fn from(value: AddressForOrganisationAddressLine1) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationAddressLine1> for AddressForOrganisationAddressLine1 {
        fn from(value: &AddressForOrganisationAddressLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationAddressLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationAddressLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationAddressLine1 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationAddressLine2(String);
    impl ::std::ops::Deref for AddressForOrganisationAddressLine2 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationAddressLine2> for String {
        fn from(value: AddressForOrganisationAddressLine2) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationAddressLine2> for AddressForOrganisationAddressLine2 {
        fn from(value: &AddressForOrganisationAddressLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationAddressLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationAddressLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationAddressLine2 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationAddressLine3(String);
    impl ::std::ops::Deref for AddressForOrganisationAddressLine3 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationAddressLine3> for String {
        fn from(value: AddressForOrganisationAddressLine3) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationAddressLine3> for AddressForOrganisationAddressLine3 {
        fn from(value: &AddressForOrganisationAddressLine3) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationAddressLine3 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationAddressLine3 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationAddressLine3 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 500
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 500",
    ///  "type": "string",
    ///  "maxLength": 500
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationAddressLine4(String);
    impl ::std::ops::Deref for AddressForOrganisationAddressLine4 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationAddressLine4> for String {
        fn from(value: AddressForOrganisationAddressLine4) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationAddressLine4> for AddressForOrganisationAddressLine4 {
        fn from(value: &AddressForOrganisationAddressLine4) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationAddressLine4 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 500usize {
                return Err("longer than 500 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationAddressLine4 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationAddressLine4 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///define the type of address
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "define the type of address",
    ///  "type": "string",
    ///  "enum": [
    ///    "POBOX",
    ///    "STREET",
    ///    "DELIVERY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AddressForOrganisationAddressType {
        #[serde(rename = "POBOX")]
        Pobox,
        #[serde(rename = "STREET")]
        Street,
        #[serde(rename = "DELIVERY")]
        Delivery,
    }

    impl From<&AddressForOrganisationAddressType> for AddressForOrganisationAddressType {
        fn from(value: &AddressForOrganisationAddressType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddressForOrganisationAddressType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pobox => write!(f, "POBOX"),
                Self::Street => write!(f, "STREET"),
                Self::Delivery => write!(f, "DELIVERY"),
            }
        }
    }

    impl std::str::FromStr for AddressForOrganisationAddressType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "POBOX" => Ok(Self::Pobox),
                "STREET" => Ok(Self::Street),
                "DELIVERY" => Ok(Self::Delivery),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AddressForOrganisationAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AddressForOrganisationAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AddressForOrganisationAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationAttentionTo(String);
    impl ::std::ops::Deref for AddressForOrganisationAttentionTo {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationAttentionTo> for String {
        fn from(value: AddressForOrganisationAttentionTo) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationAttentionTo> for AddressForOrganisationAttentionTo {
        fn from(value: &AddressForOrganisationAttentionTo) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationAttentionTo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationAttentionTo {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationAttentionTo {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationCity(String);
    impl ::std::ops::Deref for AddressForOrganisationCity {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationCity> for String {
        fn from(value: AddressForOrganisationCity) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationCity> for AddressForOrganisationCity {
        fn from(value: &AddressForOrganisationCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationCity {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationCity {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 50, [A-Z], [a-z] only
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 50, [A-Z], [a-z] only",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationCountry(String);
    impl ::std::ops::Deref for AddressForOrganisationCountry {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationCountry> for String {
        fn from(value: AddressForOrganisationCountry) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationCountry> for AddressForOrganisationCountry {
        fn from(value: &AddressForOrganisationCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationCountry {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 50
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 50",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationPostalCode(String);
    impl ::std::ops::Deref for AddressForOrganisationPostalCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationPostalCode> for String {
        fn from(value: AddressForOrganisationPostalCode) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationPostalCode> for AddressForOrganisationPostalCode {
        fn from(value: &AddressForOrganisationPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationPostalCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressForOrganisationRegion(String);
    impl ::std::ops::Deref for AddressForOrganisationRegion {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressForOrganisationRegion> for String {
        fn from(value: AddressForOrganisationRegion) -> Self {
            value.0
        }
    }

    impl From<&AddressForOrganisationRegion> for AddressForOrganisationRegion {
        fn from(value: &AddressForOrganisationRegion) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressForOrganisationRegion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressForOrganisationRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressForOrganisationRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressForOrganisationRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressForOrganisationRegion {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 50
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 50",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressPostalCode(String);
    impl ::std::ops::Deref for AddressPostalCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressPostalCode> for String {
        fn from(value: AddressPostalCode) -> Self {
            value.0
        }
    }

    impl From<&AddressPostalCode> for AddressPostalCode {
        fn from(value: &AddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressPostalCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 255
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 255",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AddressRegion(String);
    impl ::std::ops::Deref for AddressRegion {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AddressRegion> for String {
        fn from(value: AddressRegion) -> Self {
            value.0
        }
    }

    impl From<&AddressRegion> for AddressRegion {
        fn from(value: &AddressRegion) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddressRegion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AddressRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AddressRegion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddressRegion {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Allocation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Amount",
    ///    "Date",
    ///    "Invoice"
    ///  ],
    ///  "properties": {
    ///    "AllocationID": {
    ///      "description": "Xero generated unique identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Amount": {
    ///      "description": "the amount being applied to the invoice",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "CreditNote": {
    ///      "$ref": "#/components/schemas/CreditNote"
    ///    },
    ///    "Date": {
    ///      "description": "the date the allocation is applied YYYY-MM-DD.",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Invoice": {
    ///      "$ref": "#/components/schemas/Invoice"
    ///    },
    ///    "IsDeleted": {
    ///      "description": "A flag that returns true when the allocation is
    /// succesfully deleted",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "Overpayment": {
    ///      "$ref": "#/components/schemas/Overpayment"
    ///    },
    ///    "Prepayment": {
    ///      "$ref": "#/components/schemas/Prepayment"
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Allocation {
        ///Xero generated unique identifier
        #[serde(
            rename = "AllocationID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub allocation_id: Option<uuid::Uuid>,
        #[serde(rename = "Amount")]
        pub amount: f64,
        #[serde(
            rename = "CreditNote",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note: Option<CreditNote>,
        ///the date the allocation is applied YYYY-MM-DD.
        #[serde(rename = "Date")]
        pub date: String,
        #[serde(rename = "Invoice")]
        pub invoice: Invoice,
        ///A flag that returns true when the allocation is succesfully deleted
        #[serde(rename = "IsDeleted", default, skip_serializing_if = "Option::is_none")]
        pub is_deleted: Option<bool>,
        #[serde(
            rename = "Overpayment",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub overpayment: Option<Overpayment>,
        #[serde(
            rename = "Prepayment",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prepayment: Option<Prepayment>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Allocation> for Allocation {
        fn from(value: &Allocation) -> Self {
            value.clone()
        }
    }

    ///Allocations
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Allocations": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Allocation"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "allocations"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Allocations {
        #[serde(rename = "Allocations", default, skip_serializing_if = "Vec::is_empty")]
        pub allocations: Vec<Allocation>,
    }

    impl From<&Allocations> for Allocations {
        fn from(value: &Allocations) -> Self {
            value.clone()
        }
    }

    ///Attachment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AttachmentID": {
    ///      "description": "Unique ID for the file",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ContentLength": {
    ///      "description": "Length of the file content",
    ///      "type": "integer"
    ///    },
    ///    "FileName": {
    ///      "description": "Name of the file",
    ///      "examples": [
    ///        "xero-dev.jpg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "IncludeOnline": {
    ///      "description": "Include the file with the online invoice",
    ///      "type": "boolean"
    ///    },
    ///    "MimeType": {
    ///      "description": "Type of file",
    ///      "examples": [
    ///        "image/jpg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "Url": {
    ///      "description": "URL to the file on xero.com",
    ///      "examples": [
    ///        "https://api.xero.com/api.xro/2.0/Accounts/da962997-a8bd-4dff-9616-01cdc199283f/Attachments/sample5.jpg"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Attachment {
        ///Unique ID for the file
        #[serde(
            rename = "AttachmentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub attachment_id: Option<uuid::Uuid>,
        ///Length of the file content
        #[serde(
            rename = "ContentLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub content_length: Option<i64>,
        ///Name of the file
        #[serde(rename = "FileName", default, skip_serializing_if = "Option::is_none")]
        pub file_name: Option<String>,
        ///Include the file with the online invoice
        #[serde(
            rename = "IncludeOnline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub include_online: Option<bool>,
        ///Type of file
        #[serde(rename = "MimeType", default, skip_serializing_if = "Option::is_none")]
        pub mime_type: Option<String>,
        ///URL to the file on xero.com
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
    }

    impl From<&Attachment> for Attachment {
        fn from(value: &Attachment) -> Self {
            value.clone()
        }
    }

    ///Attachments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Attachments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "attachments"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Attachments {
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
    }

    impl From<&Attachments> for Attachments {
        fn from(value: &Attachments) -> Self {
            value.clone()
        }
    }

    ///An array to specify multiple currency balances of an account
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An array to specify multiple currency balances of an
    /// account",
    ///  "type": "object",
    ///  "properties": {
    ///    "Balance": {
    ///      "description": "The opening balances of the account. Debits are
    /// positive, credits are negative values",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "CurrencyCode": {
    ///      "description": "The currency of the balance (Not required for base
    /// currency)",
    ///      "type": "string"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "(Optional) Exchange rate to base currency when
    /// money is spent or received. If not specified, XE rate for the day is
    /// applied",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BalanceDetails {
        #[serde(rename = "Balance", default, skip_serializing_if = "Option::is_none")]
        pub balance: Option<f64>,
        ///The currency of the balance (Not required for base currency)
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<String>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
    }

    impl From<&BalanceDetails> for BalanceDetails {
        fn from(value: &BalanceDetails) -> Self {
            value.clone()
        }
    }

    ///The raw AccountsReceivable(sales invoices) and AccountsPayable(bills)
    /// outstanding and overdue amounts, not converted to base currency (read
    /// only)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The raw AccountsReceivable(sales invoices) and
    /// AccountsPayable(bills) outstanding and overdue amounts, not converted to
    /// base currency (read only)",
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountsPayable": {
    ///      "$ref": "#/components/schemas/AccountsPayable"
    ///    },
    ///    "AccountsReceivable": {
    ///      "$ref": "#/components/schemas/AccountsReceivable"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Balances {
        #[serde(
            rename = "AccountsPayable",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accounts_payable: Option<AccountsPayable>,
        #[serde(
            rename = "AccountsReceivable",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accounts_receivable: Option<AccountsReceivable>,
    }

    impl From<&Balances> for Balances {
        fn from(value: &Balances) -> Self {
            value.clone()
        }
    }

    ///BankTransaction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BankAccount",
    ///    "LineItems",
    ///    "Type"
    ///  ],
    ///  "properties": {
    ///    "BankAccount": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "BankTransactionID": {
    ///      "description": "Xero generated unique identifier for bank
    /// transaction",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "Exchange rate to base currency when money is spent
    /// or received. e.g.0.7500 Only used for bank transactions in non base
    /// currency. If this isn’t specified for non base currency accounts then
    /// either the user-defined rate (preference) or the XE.com day rate will be
    /// used. Setting currency is only supported on overpayments.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "Date of transaction – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "Boolean to indicate if a bank transaction has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "IsReconciled": {
    ///      "description": "Boolean to show if transaction is reconciled",
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See LineItems",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "OverpaymentID": {
    ///      "description": "Xero generated unique identifier for an
    /// Overpayment. This will be returned on BankTransactions with a Type of
    /// SPEND-OVERPAYMENT or RECEIVE-OVERPAYMENT",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PrepaymentID": {
    ///      "description": "Xero generated unique identifier for a Prepayment.
    /// This will be returned on BankTransactions with a Type of
    /// SPEND-PREPAYMENT or RECEIVE-PREPAYMENT",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Reference": {
    ///      "description": "Reference for the transaction. Only supported for
    /// SPEND and RECEIVE transactions.",
    ///      "type": "string"
    ///    },
    ///    "Status": {
    ///      "description": "See Bank Transaction Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "AUTHORISED",
    ///        "DELETED",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of bank transaction excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "Total of bank transaction tax inclusive",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on bank transaction",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Bank Transaction Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "RECEIVE",
    ///        "RECEIVE-OVERPAYMENT",
    ///        "RECEIVE-PREPAYMENT",
    ///        "SPEND",
    ///        "SPEND-OVERPAYMENT",
    ///        "SPEND-PREPAYMENT",
    ///        "RECEIVE-TRANSFER",
    ///        "SPEND-TRANSFER"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "Url": {
    ///      "description": "URL link to a source document – shown as “Go to App
    /// Name”",
    ///      "type": "string"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BankTransaction {
        #[serde(rename = "BankAccount")]
        pub bank_account: Account,
        ///Xero generated unique identifier for bank transaction
        #[serde(
            rename = "BankTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_transaction_id: Option<uuid::Uuid>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///Date of transaction – YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Boolean to indicate if a bank transaction has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///Boolean to show if transaction is reconciled
        #[serde(
            rename = "IsReconciled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_reconciled: Option<bool>,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See LineItems
        #[serde(rename = "LineItems")]
        pub line_items: Vec<LineItem>,
        ///Xero generated unique identifier for an Overpayment. This will be
        /// returned on BankTransactions with a Type of SPEND-OVERPAYMENT or
        /// RECEIVE-OVERPAYMENT
        #[serde(
            rename = "OverpaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub overpayment_id: Option<uuid::Uuid>,
        ///Xero generated unique identifier for a Prepayment. This will be
        /// returned on BankTransactions with a Type of SPEND-PREPAYMENT or
        /// RECEIVE-PREPAYMENT
        #[serde(
            rename = "PrepaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prepayment_id: Option<uuid::Uuid>,
        ///Reference for the transaction. Only supported for SPEND and RECEIVE
        /// transactions.
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///See Bank Transaction Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<BankTransactionStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Bank Transaction Types
        #[serde(rename = "Type")]
        pub type_: BankTransactionType,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///URL link to a source document – shown as “Go to App Name”
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&BankTransaction> for BankTransaction {
        fn from(value: &BankTransaction) -> Self {
            value.clone()
        }
    }

    ///See Bank Transaction Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Bank Transaction Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORISED",
    ///    "DELETED",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BankTransactionStatus {
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "DELETED")]
        Deleted,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&BankTransactionStatus> for BankTransactionStatus {
        fn from(value: &BankTransactionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BankTransactionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Deleted => write!(f, "DELETED"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for BankTransactionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORISED" => Ok(Self::Authorised),
                "DELETED" => Ok(Self::Deleted),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BankTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BankTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BankTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Bank Transaction Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Bank Transaction Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "RECEIVE",
    ///    "RECEIVE-OVERPAYMENT",
    ///    "RECEIVE-PREPAYMENT",
    ///    "SPEND",
    ///    "SPEND-OVERPAYMENT",
    ///    "SPEND-PREPAYMENT",
    ///    "RECEIVE-TRANSFER",
    ///    "SPEND-TRANSFER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BankTransactionType {
        #[serde(rename = "RECEIVE")]
        Receive,
        #[serde(rename = "RECEIVE-OVERPAYMENT")]
        ReceiveOverpayment,
        #[serde(rename = "RECEIVE-PREPAYMENT")]
        ReceivePrepayment,
        #[serde(rename = "SPEND")]
        Spend,
        #[serde(rename = "SPEND-OVERPAYMENT")]
        SpendOverpayment,
        #[serde(rename = "SPEND-PREPAYMENT")]
        SpendPrepayment,
        #[serde(rename = "RECEIVE-TRANSFER")]
        ReceiveTransfer,
        #[serde(rename = "SPEND-TRANSFER")]
        SpendTransfer,
    }

    impl From<&BankTransactionType> for BankTransactionType {
        fn from(value: &BankTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BankTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Receive => write!(f, "RECEIVE"),
                Self::ReceiveOverpayment => write!(f, "RECEIVE-OVERPAYMENT"),
                Self::ReceivePrepayment => write!(f, "RECEIVE-PREPAYMENT"),
                Self::Spend => write!(f, "SPEND"),
                Self::SpendOverpayment => write!(f, "SPEND-OVERPAYMENT"),
                Self::SpendPrepayment => write!(f, "SPEND-PREPAYMENT"),
                Self::ReceiveTransfer => write!(f, "RECEIVE-TRANSFER"),
                Self::SpendTransfer => write!(f, "SPEND-TRANSFER"),
            }
        }
    }

    impl std::str::FromStr for BankTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "RECEIVE" => Ok(Self::Receive),
                "RECEIVE-OVERPAYMENT" => Ok(Self::ReceiveOverpayment),
                "RECEIVE-PREPAYMENT" => Ok(Self::ReceivePrepayment),
                "SPEND" => Ok(Self::Spend),
                "SPEND-OVERPAYMENT" => Ok(Self::SpendOverpayment),
                "SPEND-PREPAYMENT" => Ok(Self::SpendPrepayment),
                "RECEIVE-TRANSFER" => Ok(Self::ReceiveTransfer),
                "SPEND-TRANSFER" => Ok(Self::SpendTransfer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BankTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BankTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BankTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///BankTransactions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BankTransactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BankTransaction"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "bank_transactions"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BankTransactions {
        #[serde(
            rename = "BankTransactions",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub bank_transactions: Vec<BankTransaction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&BankTransactions> for BankTransactions {
        fn from(value: &BankTransactions) -> Self {
            value.clone()
        }
    }

    ///BankTransfer
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Amount",
    ///    "FromBankAccount",
    ///    "ToBankAccount"
    ///  ],
    ///  "properties": {
    ///    "Amount": {
    ///      "description": "amount of the transaction",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BankTransferID": {
    ///      "description": "The identifier of the Bank Transfer",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CreatedDateUTC": {
    ///      "description": "UTC timestamp of creation date of bank transfer",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "The date of the Transfer YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "FromBankAccount": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "FromBankTransactionID": {
    ///      "description": "The Bank Transaction ID for the source account",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "FromIsReconciled": {
    ///      "description": "The Bank Transaction boolean to show if it is
    /// reconciled for the source account",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "HasAttachments": {
    ///      "description": "Boolean to indicate if a Bank Transfer has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Reference": {
    ///      "description": "Reference for the transactions.",
    ///      "type": "string"
    ///    },
    ///    "ToBankAccount": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "ToBankTransactionID": {
    ///      "description": "The Bank Transaction ID for the destination
    /// account",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ToIsReconciled": {
    ///      "description": "The Bank Transaction boolean to show if it is
    /// reconciled for the destination account",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BankTransfer {
        #[serde(rename = "Amount")]
        pub amount: f64,
        ///The identifier of the Bank Transfer
        #[serde(
            rename = "BankTransferID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_transfer_id: Option<uuid::Uuid>,
        ///UTC timestamp of creation date of bank transfer
        #[serde(
            rename = "CreatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub created_date_utc: Option<String>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///The date of the Transfer YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        #[serde(rename = "FromBankAccount")]
        pub from_bank_account: Account,
        ///The Bank Transaction ID for the source account
        #[serde(
            rename = "FromBankTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub from_bank_transaction_id: Option<uuid::Uuid>,
        ///The Bank Transaction boolean to show if it is reconciled for the
        /// source account
        #[serde(rename = "FromIsReconciled", default)]
        pub from_is_reconciled: bool,
        ///Boolean to indicate if a Bank Transfer has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///Reference for the transactions.
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        #[serde(rename = "ToBankAccount")]
        pub to_bank_account: Account,
        ///The Bank Transaction ID for the destination account
        #[serde(
            rename = "ToBankTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub to_bank_transaction_id: Option<uuid::Uuid>,
        ///The Bank Transaction boolean to show if it is reconciled for the
        /// destination account
        #[serde(rename = "ToIsReconciled", default)]
        pub to_is_reconciled: bool,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&BankTransfer> for BankTransfer {
        fn from(value: &BankTransfer) -> Self {
            value.clone()
        }
    }

    ///BankTransfers
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BankTransfers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BankTransfer"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "bank_transfers"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BankTransfers {
        #[serde(
            rename = "BankTransfers",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub bank_transfers: Vec<BankTransfer>,
    }

    impl From<&BankTransfers> for BankTransfers {
        fn from(value: &BankTransfers) -> Self {
            value.clone()
        }
    }

    ///BatchPayment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Account": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "Amount": {
    ///      "description": "The amount of the payment. Must be less than or
    /// equal to the outstanding amount owing on the invoice e.g. 200.00",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BatchPaymentID": {
    ///      "description": "The Xero generated unique identifier for the bank
    /// transaction (read-only)",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Code": {
    ///      "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///      "type": "string",
    ///      "maxLength": 12
    ///    },
    ///    "Date": {
    ///      "description": "Date the payment is being made (YYYY-MM-DD) e.g.
    /// 2009-09-06",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DateString": {
    ///      "description": "Date the payment is being made (YYYY-MM-DD) e.g.
    /// 2009-09-06",
    ///      "type": "string"
    ///    },
    ///    "Details": {
    ///      "description": "(Non-NZ Only) These details are sent to the org’s
    /// bank as a reference for the batch payment transaction. They will also
    /// show with the batch payment transaction in the bank reconciliation Find
    /// & Match screen. Depending on your individual bank, the detail may also
    /// show on the bank statement imported into Xero. Maximum field length =
    /// 18",
    ///      "type": "string"
    ///    },
    ///    "IsReconciled": {
    ///      "description": "Booelan that tells you if the batch payment has
    /// been reconciled (read-only)",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "Narrative": {
    ///      "description": "(UK Only) Only shows on the statement line in Xero.
    /// Max length =18",
    ///      "type": "string",
    ///      "maxLength": 18
    ///    },
    ///    "Particulars": {
    ///      "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///      "type": "string",
    ///      "maxLength": 12
    ///    },
    ///    "Payments": {
    ///      "description": "An array of payments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "Reference": {
    ///      "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Status": {
    ///      "description": "AUTHORISED or DELETED (read-only). New batch
    /// payments will have a status of AUTHORISED. It is not possible to delete
    /// batch payments via the API.",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "enum": [
    ///        "AUTHORISED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "TotalAmount": {
    ///      "description": "The total of the payments that make up the batch
    /// (read-only)",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "PAYBATCH for bill payments or RECBATCH for sales
    /// invoice payments (read-only)",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "enum": [
    ///        "PAYBATCH",
    ///        "RECBATCH"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to the payment",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatchPayment {
        #[serde(rename = "Account", default, skip_serializing_if = "Option::is_none")]
        pub account: Option<Account>,
        #[serde(rename = "Amount", default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
        ///The Xero generated unique identifier for the bank transaction
        /// (read-only)
        #[serde(
            rename = "BatchPaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub batch_payment_id: Option<uuid::Uuid>,
        ///(NZ Only) Optional references for the batch payment transaction. It
        /// will also show with the batch payment transaction in the bank
        /// reconciliation Find & Match screen. Depending on your individual
        /// bank, the detail may also show on the bank statement you import into
        /// Xero.
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<BatchPaymentCode>,
        ///Date the payment is being made (YYYY-MM-DD) e.g. 2009-09-06
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Date the payment is being made (YYYY-MM-DD) e.g. 2009-09-06
        #[serde(
            rename = "DateString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub date_string: Option<String>,
        ///(Non-NZ Only) These details are sent to the org’s bank as a
        /// reference for the batch payment transaction. They will also show
        /// with the batch payment transaction in the bank reconciliation Find &
        /// Match screen. Depending on your individual bank, the detail may also
        /// show on the bank statement imported into Xero. Maximum field length
        /// = 18
        #[serde(rename = "Details", default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        ///Booelan that tells you if the batch payment has been reconciled
        /// (read-only)
        #[serde(
            rename = "IsReconciled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_reconciled: Option<bool>,
        ///(UK Only) Only shows on the statement line in Xero. Max length =18
        #[serde(rename = "Narrative", default, skip_serializing_if = "Option::is_none")]
        pub narrative: Option<BatchPaymentNarrative>,
        ///(NZ Only) Optional references for the batch payment transaction. It
        /// will also show with the batch payment transaction in the bank
        /// reconciliation Find & Match screen. Depending on your individual
        /// bank, the detail may also show on the bank statement you import into
        /// Xero.
        #[serde(
            rename = "Particulars",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub particulars: Option<BatchPaymentParticulars>,
        ///An array of payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///(NZ Only) Optional references for the batch payment transaction. It
        /// will also show with the batch payment transaction in the bank
        /// reconciliation Find & Match screen. Depending on your individual
        /// bank, the detail may also show on the bank statement you import into
        /// Xero.
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<BatchPaymentReference>,
        ///AUTHORISED or DELETED (read-only). New batch payments will have a
        /// status of AUTHORISED. It is not possible to delete batch payments
        /// via the API.
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<BatchPaymentStatus>,
        #[serde(
            rename = "TotalAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_amount: Option<f64>,
        ///PAYBATCH for bill payments or RECBATCH for sales invoice payments
        /// (read-only)
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<BatchPaymentType>,
        ///UTC timestamp of last update to the payment
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&BatchPayment> for BatchPayment {
        fn from(value: &BatchPayment) -> Self {
            value.clone()
        }
    }

    ///(NZ Only) Optional references for the batch payment transaction. It will
    /// also show with the batch payment transaction in the bank reconciliation
    /// Find & Match screen. Depending on your individual bank, the detail may
    /// also show on the bank statement you import into Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///  "type": "string",
    ///  "maxLength": 12
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentCode(String);
    impl ::std::ops::Deref for BatchPaymentCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentCode> for String {
        fn from(value: BatchPaymentCode) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentCode> for BatchPaymentCode {
        fn from(value: &BatchPaymentCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 12usize {
                return Err("longer than 12 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///BatchPaymentDelete
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "BatchPaymentID",
    ///    "Status"
    ///  ],
    ///  "properties": {
    ///    "BatchPaymentID": {
    ///      "description": "The Xero generated unique identifier for the bank
    /// transaction (read-only)",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Status": {
    ///      "description": "The status of the batch payment.",
    ///      "default": "DELETED",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatchPaymentDelete {
        ///The Xero generated unique identifier for the bank transaction
        /// (read-only)
        #[serde(rename = "BatchPaymentID")]
        pub batch_payment_id: uuid::Uuid,
        ///The status of the batch payment.
        #[serde(rename = "Status")]
        pub status: String,
    }

    impl From<&BatchPaymentDelete> for BatchPaymentDelete {
        fn from(value: &BatchPaymentDelete) -> Self {
            value.clone()
        }
    }

    ///BatchPaymentDeleteByUrlParam
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Status"
    ///  ],
    ///  "properties": {
    ///    "Status": {
    ///      "description": "The status of the batch payment.",
    ///      "default": "DELETED",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatchPaymentDeleteByUrlParam {
        ///The status of the batch payment.
        #[serde(rename = "Status")]
        pub status: String,
    }

    impl From<&BatchPaymentDeleteByUrlParam> for BatchPaymentDeleteByUrlParam {
        fn from(value: &BatchPaymentDeleteByUrlParam) -> Self {
            value.clone()
        }
    }

    ///Bank details for use on a batch payment stored with each contact
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Bank details for use on a batch payment stored with
    /// each contact",
    ///  "properties": {
    ///    "BankAccountName": {
    ///      "description": "Name of bank for use with Batch Payments",
    ///      "examples": [
    ///        "ACME Bank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "BankAccountNumber": {
    ///      "description": "Bank account number for use with Batch Payments",
    ///      "examples": [
    ///        "123-456-1111111"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "Code": {
    ///      "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///      "examples": [
    ///        "ABC"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 12
    ///    },
    ///    "Details": {
    ///      "description": "(Non-NZ Only) These details are sent to the org’s
    /// bank as a reference for the batch payment transaction. They will also
    /// show with the batch payment transaction in the bank reconciliation Find
    /// & Match screen. Depending on your individual bank, the detail may also
    /// show on the bank statement imported into Xero. Maximum field length =
    /// 18",
    ///      "examples": [
    ///        "Hello World"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "Reference": {
    ///      "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///      "examples": [
    ///        "Foobar"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 12
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatchPaymentDetails {
        ///Name of bank for use with Batch Payments
        #[serde(
            rename = "BankAccountName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_name: Option<String>,
        ///Bank account number for use with Batch Payments
        #[serde(
            rename = "BankAccountNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_number: Option<String>,
        ///(NZ Only) Optional references for the batch payment transaction. It
        /// will also show with the batch payment transaction in the bank
        /// reconciliation Find & Match screen. Depending on your individual
        /// bank, the detail may also show on the bank statement you import into
        /// Xero.
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<BatchPaymentDetailsCode>,
        ///(Non-NZ Only) These details are sent to the org’s bank as a
        /// reference for the batch payment transaction. They will also show
        /// with the batch payment transaction in the bank reconciliation Find &
        /// Match screen. Depending on your individual bank, the detail may also
        /// show on the bank statement imported into Xero. Maximum field length
        /// = 18
        #[serde(rename = "Details", default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        ///(NZ Only) Optional references for the batch payment transaction. It
        /// will also show with the batch payment transaction in the bank
        /// reconciliation Find & Match screen. Depending on your individual
        /// bank, the detail may also show on the bank statement you import into
        /// Xero.
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<BatchPaymentDetailsReference>,
    }

    impl From<&BatchPaymentDetails> for BatchPaymentDetails {
        fn from(value: &BatchPaymentDetails) -> Self {
            value.clone()
        }
    }

    ///(NZ Only) Optional references for the batch payment transaction. It will
    /// also show with the batch payment transaction in the bank reconciliation
    /// Find & Match screen. Depending on your individual bank, the detail may
    /// also show on the bank statement you import into Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///  "examples": [
    ///    "ABC"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 12
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentDetailsCode(String);
    impl ::std::ops::Deref for BatchPaymentDetailsCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentDetailsCode> for String {
        fn from(value: BatchPaymentDetailsCode) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentDetailsCode> for BatchPaymentDetailsCode {
        fn from(value: &BatchPaymentDetailsCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentDetailsCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 12usize {
                return Err("longer than 12 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentDetailsCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentDetailsCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentDetailsCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentDetailsCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///(NZ Only) Optional references for the batch payment transaction. It will
    /// also show with the batch payment transaction in the bank reconciliation
    /// Find & Match screen. Depending on your individual bank, the detail may
    /// also show on the bank statement you import into Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///  "examples": [
    ///    "Foobar"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 12
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentDetailsReference(String);
    impl ::std::ops::Deref for BatchPaymentDetailsReference {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentDetailsReference> for String {
        fn from(value: BatchPaymentDetailsReference) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentDetailsReference> for BatchPaymentDetailsReference {
        fn from(value: &BatchPaymentDetailsReference) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentDetailsReference {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 12usize {
                return Err("longer than 12 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentDetailsReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentDetailsReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentDetailsReference {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentDetailsReference {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///(UK Only) Only shows on the statement line in Xero. Max length =18
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(UK Only) Only shows on the statement line in Xero. Max
    /// length =18",
    ///  "type": "string",
    ///  "maxLength": 18
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentNarrative(String);
    impl ::std::ops::Deref for BatchPaymentNarrative {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentNarrative> for String {
        fn from(value: BatchPaymentNarrative) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentNarrative> for BatchPaymentNarrative {
        fn from(value: &BatchPaymentNarrative) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentNarrative {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 18usize {
                return Err("longer than 18 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentNarrative {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentNarrative {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentNarrative {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentNarrative {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///(NZ Only) Optional references for the batch payment transaction. It will
    /// also show with the batch payment transaction in the bank reconciliation
    /// Find & Match screen. Depending on your individual bank, the detail may
    /// also show on the bank statement you import into Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///  "type": "string",
    ///  "maxLength": 12
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentParticulars(String);
    impl ::std::ops::Deref for BatchPaymentParticulars {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentParticulars> for String {
        fn from(value: BatchPaymentParticulars) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentParticulars> for BatchPaymentParticulars {
        fn from(value: &BatchPaymentParticulars) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentParticulars {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 12usize {
                return Err("longer than 12 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentParticulars {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentParticulars {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentParticulars {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentParticulars {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///(NZ Only) Optional references for the batch payment transaction. It will
    /// also show with the batch payment transaction in the bank reconciliation
    /// Find & Match screen. Depending on your individual bank, the detail may
    /// also show on the bank statement you import into Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "(NZ Only) Optional references for the batch payment
    /// transaction. It will also show with the batch payment transaction in the
    /// bank reconciliation Find & Match screen. Depending on your individual
    /// bank, the detail may also show on the bank statement you import into
    /// Xero.",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BatchPaymentReference(String);
    impl ::std::ops::Deref for BatchPaymentReference {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BatchPaymentReference> for String {
        fn from(value: BatchPaymentReference) -> Self {
            value.0
        }
    }

    impl From<&BatchPaymentReference> for BatchPaymentReference {
        fn from(value: &BatchPaymentReference) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BatchPaymentReference {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BatchPaymentReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BatchPaymentReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BatchPaymentReference {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BatchPaymentReference {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///AUTHORISED or DELETED (read-only). New batch payments will have a status
    /// of AUTHORISED. It is not possible to delete batch payments via the API.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "AUTHORISED or DELETED (read-only). New batch payments
    /// will have a status of AUTHORISED. It is not possible to delete batch
    /// payments via the API.",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORISED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BatchPaymentStatus {
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&BatchPaymentStatus> for BatchPaymentStatus {
        fn from(value: &BatchPaymentStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BatchPaymentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for BatchPaymentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORISED" => Ok(Self::Authorised),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BatchPaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BatchPaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BatchPaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///PAYBATCH for bill payments or RECBATCH for sales invoice payments
    /// (read-only)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "PAYBATCH for bill payments or RECBATCH for sales
    /// invoice payments (read-only)",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "PAYBATCH",
    ///    "RECBATCH"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BatchPaymentType {
        #[serde(rename = "PAYBATCH")]
        Paybatch,
        #[serde(rename = "RECBATCH")]
        Recbatch,
    }

    impl From<&BatchPaymentType> for BatchPaymentType {
        fn from(value: &BatchPaymentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BatchPaymentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Paybatch => write!(f, "PAYBATCH"),
                Self::Recbatch => write!(f, "RECBATCH"),
            }
        }
    }

    impl std::str::FromStr for BatchPaymentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PAYBATCH" => Ok(Self::Paybatch),
                "RECBATCH" => Ok(Self::Recbatch),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BatchPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BatchPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BatchPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///BatchPayments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BatchPayments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BatchPayment"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "batch_payments"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatchPayments {
        #[serde(
            rename = "BatchPayments",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub batch_payments: Vec<BatchPayment>,
    }

    impl From<&BatchPayments> for BatchPayments {
        fn from(value: &BatchPayments) -> Self {
            value.clone()
        }
    }

    ///Bill
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Day": {
    ///      "description": "Day of Month (0-31)",
    ///      "type": "integer"
    ///    },
    ///    "Type": {
    ///      "$ref": "#/components/schemas/PaymentTermType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Bill {
        ///Day of Month (0-31)
        #[serde(rename = "Day", default, skip_serializing_if = "Option::is_none")]
        pub day: Option<i64>,
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<PaymentTermType>,
    }

    impl From<&Bill> for Bill {
        fn from(value: &Bill) -> Self {
            value.clone()
        }
    }

    ///BrandingTheme
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BrandingThemeID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CreatedDateUTC": {
    ///      "description": "UTC timestamp of creation date of branding theme",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "LogoUrl": {
    ///      "description": "The location of the image file used as the logo on
    /// this branding theme",
    ///      "type": "string"
    ///    },
    ///    "Name": {
    ///      "description": "Name of branding theme",
    ///      "type": "string"
    ///    },
    ///    "SortOrder": {
    ///      "description": "Integer – ranked order of branding theme. The
    /// default branding theme has a value of 0",
    ///      "type": "integer"
    ///    },
    ///    "Type": {
    ///      "description": "Always INVOICE",
    ///      "type": "string",
    ///      "enum": [
    ///        "INVOICE"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BrandingTheme {
        ///Xero identifier
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        ///UTC timestamp of creation date of branding theme
        #[serde(
            rename = "CreatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub created_date_utc: Option<String>,
        ///The location of the image file used as the logo on this branding
        /// theme
        #[serde(rename = "LogoUrl", default, skip_serializing_if = "Option::is_none")]
        pub logo_url: Option<String>,
        ///Name of branding theme
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///Integer – ranked order of branding theme. The default branding theme
        /// has a value of 0
        #[serde(rename = "SortOrder", default, skip_serializing_if = "Option::is_none")]
        pub sort_order: Option<i64>,
        ///Always INVOICE
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<BrandingThemeType>,
    }

    impl From<&BrandingTheme> for BrandingTheme {
        fn from(value: &BrandingTheme) -> Self {
            value.clone()
        }
    }

    ///Always INVOICE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Always INVOICE",
    ///  "type": "string",
    ///  "enum": [
    ///    "INVOICE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BrandingThemeType {
        #[serde(rename = "INVOICE")]
        Invoice,
    }

    impl From<&BrandingThemeType> for BrandingThemeType {
        fn from(value: &BrandingThemeType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BrandingThemeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Invoice => write!(f, "INVOICE"),
            }
        }
    }

    impl std::str::FromStr for BrandingThemeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "INVOICE" => Ok(Self::Invoice),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BrandingThemeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BrandingThemeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BrandingThemeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///BrandingThemes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BrandingThemes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BrandingTheme"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "branding_themes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BrandingThemes {
        #[serde(
            rename = "BrandingThemes",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub branding_themes: Vec<BrandingTheme>,
    }

    impl From<&BrandingThemes> for BrandingThemes {
        fn from(value: &BrandingThemes) -> Self {
            value.clone()
        }
    }

    ///Budget
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BudgetID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "BudgetLines": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BudgetLine"
    ///      }
    ///    },
    ///    "Description": {
    ///      "description": "The Budget description",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Tracking": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingCategory"
    ///      }
    ///    },
    ///    "Type": {
    ///      "description": "Type of Budget. OVERALL or TRACKING",
    ///      "type": "string",
    ///      "enum": [
    ///        "OVERALL",
    ///        "TRACKING"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to budget",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Budget {
        ///Xero identifier
        #[serde(rename = "BudgetID", default, skip_serializing_if = "Option::is_none")]
        pub budget_id: Option<uuid::Uuid>,
        #[serde(rename = "BudgetLines", default, skip_serializing_if = "Vec::is_empty")]
        pub budget_lines: Vec<BudgetLine>,
        ///The Budget description
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<BudgetDescription>,
        #[serde(rename = "Tracking", default, skip_serializing_if = "Vec::is_empty")]
        pub tracking: Vec<TrackingCategory>,
        ///Type of Budget. OVERALL or TRACKING
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<BudgetType>,
        ///UTC timestamp of last update to budget
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
    }

    impl From<&Budget> for Budget {
        fn from(value: &Budget) -> Self {
            value.clone()
        }
    }

    ///BudgetBalance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Amount": {
    ///      "description": "LineItem Quantity",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Notes": {
    ///      "description": "Any footnotes associated with this balance",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Period": {
    ///      "description": "Period the amount applies to (e.g. “2019-08”)",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "UnitAmount": {
    ///      "description": "Budgeted amount",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetBalance {
        #[serde(rename = "Amount", default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
        ///Any footnotes associated with this balance
        #[serde(rename = "Notes", default, skip_serializing_if = "Option::is_none")]
        pub notes: Option<BudgetBalanceNotes>,
        ///Period the amount applies to (e.g. “2019-08”)
        #[serde(rename = "Period", default, skip_serializing_if = "Option::is_none")]
        pub period: Option<String>,
        #[serde(
            rename = "UnitAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub unit_amount: Option<f64>,
    }

    impl From<&BudgetBalance> for BudgetBalance {
        fn from(value: &BudgetBalance) -> Self {
            value.clone()
        }
    }

    ///Any footnotes associated with this balance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Any footnotes associated with this balance",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BudgetBalanceNotes(String);
    impl ::std::ops::Deref for BudgetBalanceNotes {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BudgetBalanceNotes> for String {
        fn from(value: BudgetBalanceNotes) -> Self {
            value.0
        }
    }

    impl From<&BudgetBalanceNotes> for BudgetBalanceNotes {
        fn from(value: &BudgetBalanceNotes) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BudgetBalanceNotes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BudgetBalanceNotes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BudgetBalanceNotes {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BudgetBalanceNotes {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BudgetBalanceNotes {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The Budget description
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Budget description",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BudgetDescription(String);
    impl ::std::ops::Deref for BudgetDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BudgetDescription> for String {
        fn from(value: BudgetDescription) -> Self {
            value.0
        }
    }

    impl From<&BudgetDescription> for BudgetDescription {
        fn from(value: &BudgetDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BudgetDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BudgetDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BudgetDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BudgetDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BudgetDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///BudgetLine
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "See Accounts",
    ///      "examples": [
    ///        "090"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "AccountID": {
    ///      "description": "See Accounts",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "BudgetBalances": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BudgetBalance"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetLine {
        ///See Accounts
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        ///See Accounts
        #[serde(rename = "AccountID", default, skip_serializing_if = "Option::is_none")]
        pub account_id: Option<uuid::Uuid>,
        #[serde(
            rename = "BudgetBalances",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub budget_balances: Vec<BudgetBalance>,
    }

    impl From<&BudgetLine> for BudgetLine {
        fn from(value: &BudgetLine) -> Self {
            value.clone()
        }
    }

    ///Type of Budget. OVERALL or TRACKING
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of Budget. OVERALL or TRACKING",
    ///  "type": "string",
    ///  "enum": [
    ///    "OVERALL",
    ///    "TRACKING"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum BudgetType {
        #[serde(rename = "OVERALL")]
        Overall,
        #[serde(rename = "TRACKING")]
        Tracking,
    }

    impl From<&BudgetType> for BudgetType {
        fn from(value: &BudgetType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BudgetType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Overall => write!(f, "OVERALL"),
                Self::Tracking => write!(f, "TRACKING"),
            }
        }
    }

    impl std::str::FromStr for BudgetType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "OVERALL" => Ok(Self::Overall),
                "TRACKING" => Ok(Self::Tracking),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for BudgetType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BudgetType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BudgetType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Budgets
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Budgets": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Budget"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "budgets"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Budgets {
        #[serde(rename = "Budgets", default, skip_serializing_if = "Vec::is_empty")]
        pub budgets: Vec<Budget>,
    }

    impl From<&Budgets> for Budgets {
        fn from(value: &Budgets) -> Self {
            value.clone()
        }
    }

    ///CisOrgSetting
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "CISContractorEnabled": {
    ///      "description": "true or false - Boolean that describes if the
    /// organisation is a CIS Contractor",
    ///      "type": "boolean"
    ///    },
    ///    "CISSubContractorEnabled": {
    ///      "description": "true or false - Boolean that describes if the
    /// organisation is a CIS SubContractor",
    ///      "type": "boolean"
    ///    },
    ///    "Rate": {
    ///      "description": "CIS Deduction rate for the organisation",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CisOrgSetting {
        ///true or false - Boolean that describes if the organisation is a CIS
        /// Contractor
        #[serde(
            rename = "CISContractorEnabled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cis_contractor_enabled: Option<bool>,
        ///true or false - Boolean that describes if the organisation is a CIS
        /// SubContractor
        #[serde(
            rename = "CISSubContractorEnabled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cis_sub_contractor_enabled: Option<bool>,
        #[serde(rename = "Rate", default, skip_serializing_if = "Option::is_none")]
        pub rate: Option<f64>,
    }

    impl From<&CisOrgSetting> for CisOrgSetting {
        fn from(value: &CisOrgSetting) -> Self {
            value.clone()
        }
    }

    ///CisOrgSettings
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "CISSettings": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CISOrgSetting"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "cis_settings"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CisOrgSettings {
        #[serde(rename = "CISSettings", default, skip_serializing_if = "Vec::is_empty")]
        pub cis_settings: Vec<CisOrgSetting>,
    }

    impl From<&CisOrgSettings> for CisOrgSettings {
        fn from(value: &CisOrgSettings) -> Self {
            value.clone()
        }
    }

    ///CisSetting
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "CISEnabled": {
    ///      "description": "Boolean that describes if the contact is a CIS
    /// Subcontractor",
    ///      "type": "boolean"
    ///    },
    ///    "Rate": {
    ///      "description": "CIS Deduction rate for the contact if he is a
    /// subcontractor. If the contact is not CISEnabled, then the rate is not
    /// returned",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CisSetting {
        ///Boolean that describes if the contact is a CIS Subcontractor
        #[serde(
            rename = "CISEnabled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cis_enabled: Option<bool>,
        #[serde(rename = "Rate", default, skip_serializing_if = "Option::is_none")]
        pub rate: Option<f64>,
    }

    impl From<&CisSetting> for CisSetting {
        fn from(value: &CisSetting) -> Self {
            value.clone()
        }
    }

    ///CisSettings
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "CISSettings": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CISSetting"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "cis_settings"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CisSettings {
        #[serde(rename = "CISSettings", default, skip_serializing_if = "Vec::is_empty")]
        pub cis_settings: Vec<CisSetting>,
    }

    impl From<&CisSettings> for CisSettings {
        fn from(value: &CisSettings) -> Self {
            value.clone()
        }
    }

    ///Contact
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountNumber": {
    ///      "description": "A user defined account number. This can be updated
    /// via the API and the Xero UI (max length = 50)",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "AccountsPayableTaxType": {
    ///      "description": "The tax type from TaxRates",
    ///      "type": "string"
    ///    },
    ///    "AccountsReceivableTaxType": {
    ///      "description": "The tax type from TaxRates",
    ///      "type": "string"
    ///    },
    ///    "Addresses": {
    ///      "description": "Store certain address types for a contact – see
    /// address types",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Address"
    ///      }
    ///    },
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "Balances": {
    ///      "$ref": "#/components/schemas/Balances"
    ///    },
    ///    "BankAccountDetails": {
    ///      "description": "Bank account number of contact",
    ///      "type": "string"
    ///    },
    ///    "BatchPayments": {
    ///      "$ref": "#/components/schemas/BatchPaymentDetails"
    ///    },
    ///    "BrandingTheme": {
    ///      "$ref": "#/components/schemas/BrandingTheme"
    ///    },
    ///    "CompanyNumber": {
    ///      "description": "Company registration number (max length = 50)",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "ContactGroups": {
    ///      "description": "Displays which contact groups a contact is included
    /// in",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ContactGroup"
    ///      }
    ///    },
    ///    "ContactID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ContactNumber": {
    ///      "description": "This can be updated via the API only i.e. This
    /// field is read only on the Xero contact screen, used to identify contacts
    /// in external systems (max length = 50). If the Contact Number is used,
    /// this is displayed as Contact Code in the Contacts UI in Xero.",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "ContactPersons": {
    ///      "description": "See contact persons",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ContactPerson"
    ///      }
    ///    },
    ///    "ContactStatus": {
    ///      "description": "Current status of a contact – see contact status
    /// types",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "ARCHIVED",
    ///        "GDPRREQUEST"
    ///      ]
    ///    },
    ///    "DefaultCurrency": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "Discount": {
    ///      "description": "The default discount rate for the contact (read
    /// only)",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "EmailAddress": {
    ///      "description": "Email address of contact person (umlauts not
    /// supported) (max length  = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "FirstName": {
    ///      "description": "First name of contact person (max length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "HasAttachments": {
    ///      "description": "A boolean to indicate if a contact has an
    /// attachment",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "HasValidationErrors": {
    ///      "description": "A boolean to indicate if a contact has an
    /// validation errors",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "IsCustomer": {
    ///      "description": "true or false – Boolean that describes if a contact
    /// has any AR invoices entered against them. Cannot be set via PUT or POST
    /// – it is automatically set when an accounts receivable invoice is
    /// generated against this contact.",
    ///      "type": "boolean"
    ///    },
    ///    "IsSupplier": {
    ///      "description": "true or false – Boolean that describes if a contact
    /// that has any AP  invoices entered against them. Cannot be set via PUT or
    /// POST – it is automatically set when an accounts payable invoice is
    /// generated against this contact.",
    ///      "type": "boolean"
    ///    },
    ///    "LastName": {
    ///      "description": "Last name of contact person (max length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "MergedToContactID": {
    ///      "description": "ID for the destination of a merged contact. Only
    /// returned when using paging or when fetching a contact by ContactId or
    /// ContactNumber.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Name": {
    ///      "description": "Full name of contact/organisation (max length =
    /// 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "PaymentTerms": {
    ///      "$ref": "#/components/schemas/PaymentTerm"
    ///    },
    ///    "Phones": {
    ///      "description": "Store certain phone types for a contact – see phone
    /// types",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Phone"
    ///      }
    ///    },
    ///    "PurchasesDefaultAccountCode": {
    ///      "description": "The default purchases account code for contacts",
    ///      "type": "string"
    ///    },
    ///    "PurchasesDefaultLineAmountType": {
    ///      "description": "The default purchases line amount type for a
    /// contact Only available when summaryOnly parameter or paging is used, or
    /// when fetch by ContactId or ContactNumber.",
    ///      "type": "string",
    ///      "enum": [
    ///        "INCLUSIVE",
    ///        "EXCLUSIVE",
    ///        "NONE"
    ///      ]
    ///    },
    ///    "PurchasesTrackingCategories": {
    ///      "description": "The default purchases tracking categories for
    /// contacts",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SalesTrackingCategory"
    ///      }
    ///    },
    ///    "SalesDefaultAccountCode": {
    ///      "description": "The default sales account code for contacts",
    ///      "type": "string"
    ///    },
    ///    "SalesDefaultLineAmountType": {
    ///      "description": "The default sales line amount type for a contact.
    /// Only available when summaryOnly parameter or paging is used, or when
    /// fetch by ContactId or ContactNumber.",
    ///      "type": "string",
    ///      "enum": [
    ///        "INCLUSIVE",
    ///        "EXCLUSIVE",
    ///        "NONE"
    ///      ]
    ///    },
    ///    "SalesTrackingCategories": {
    ///      "description": "The default sales tracking categories for
    /// contacts",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SalesTrackingCategory"
    ///      }
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "Status of object",
    ///      "type": "string"
    ///    },
    ///    "TaxNumber": {
    ///      "description": "Tax number of contact – this is also known as the
    /// ABN (Australia), GST Number (New Zealand), VAT Number (UK) or Tax ID
    /// Number (US and global) in the Xero UI depending on which regionalized
    /// version of Xero you are using (max length = 50)",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "TrackingCategoryName": {
    ///      "description": "The name of the Tracking Category assigned to the contact under SalesTrackingCategories and PurchasesTrackingCategories",
    ///      "type": "string"
    ///    },
    ///    "TrackingCategoryOption": {
    ///      "description": "The name of the Tracking Option assigned to the contact under SalesTrackingCategories and PurchasesTrackingCategories",
    ///      "type": "string"
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to contact",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays validation errors returned from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Website": {
    ///      "description": "Website address for contact (read only)",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "XeroNetworkKey": {
    ///      "description": "Store XeroNetworkKey for contacts.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Contact {
        ///A user defined account number. This can be updated via the API and
        /// the Xero UI (max length = 50)
        #[serde(
            rename = "AccountNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_number: Option<ContactAccountNumber>,
        ///The tax type from TaxRates
        #[serde(
            rename = "AccountsPayableTaxType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accounts_payable_tax_type: Option<String>,
        ///The tax type from TaxRates
        #[serde(
            rename = "AccountsReceivableTaxType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accounts_receivable_tax_type: Option<String>,
        ///Store certain address types for a contact – see address types
        #[serde(rename = "Addresses", default, skip_serializing_if = "Vec::is_empty")]
        pub addresses: Vec<Address>,
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        #[serde(rename = "Balances", default, skip_serializing_if = "Option::is_none")]
        pub balances: Option<Balances>,
        ///Bank account number of contact
        #[serde(
            rename = "BankAccountDetails",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_details: Option<String>,
        #[serde(
            rename = "BatchPayments",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub batch_payments: Option<BatchPaymentDetails>,
        #[serde(
            rename = "BrandingTheme",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme: Option<BrandingTheme>,
        ///Company registration number (max length = 50)
        #[serde(
            rename = "CompanyNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub company_number: Option<ContactCompanyNumber>,
        ///Displays which contact groups a contact is included in
        #[serde(
            rename = "ContactGroups",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub contact_groups: Vec<ContactGroup>,
        ///Xero identifier
        #[serde(rename = "ContactID", default, skip_serializing_if = "Option::is_none")]
        pub contact_id: Option<uuid::Uuid>,
        ///This can be updated via the API only i.e. This field is read only on
        /// the Xero contact screen, used to identify contacts in external
        /// systems (max length = 50). If the Contact Number is used, this is
        /// displayed as Contact Code in the Contacts UI in Xero.
        #[serde(
            rename = "ContactNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub contact_number: Option<ContactContactNumber>,
        ///See contact persons
        #[serde(
            rename = "ContactPersons",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub contact_persons: Vec<ContactPerson>,
        ///Current status of a contact – see contact status types
        #[serde(
            rename = "ContactStatus",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub contact_status: Option<ContactContactStatus>,
        #[serde(
            rename = "DefaultCurrency",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub default_currency: Option<CurrencyCode>,
        #[serde(rename = "Discount", default, skip_serializing_if = "Option::is_none")]
        pub discount: Option<f64>,
        ///Email address of contact person (umlauts not supported) (max length
        /// = 255)
        #[serde(
            rename = "EmailAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub email_address: Option<ContactEmailAddress>,
        ///First name of contact person (max length = 255)
        #[serde(rename = "FirstName", default, skip_serializing_if = "Option::is_none")]
        pub first_name: Option<ContactFirstName>,
        ///A boolean to indicate if a contact has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///A boolean to indicate if a contact has an validation errors
        #[serde(rename = "HasValidationErrors", default)]
        pub has_validation_errors: bool,
        ///true or false – Boolean that describes if a contact has any AR
        /// invoices entered against them. Cannot be set via PUT or POST – it is
        /// automatically set when an accounts receivable invoice is generated
        /// against this contact.
        #[serde(
            rename = "IsCustomer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_customer: Option<bool>,
        ///true or false – Boolean that describes if a contact that has any AP
        /// invoices entered against them. Cannot be set via PUT or POST – it is
        /// automatically set when an accounts payable invoice is generated
        /// against this contact.
        #[serde(
            rename = "IsSupplier",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_supplier: Option<bool>,
        ///Last name of contact person (max length = 255)
        #[serde(rename = "LastName", default, skip_serializing_if = "Option::is_none")]
        pub last_name: Option<ContactLastName>,
        ///ID for the destination of a merged contact. Only returned when using
        /// paging or when fetching a contact by ContactId or ContactNumber.
        #[serde(
            rename = "MergedToContactID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub merged_to_contact_id: Option<uuid::Uuid>,
        ///Full name of contact/organisation (max length = 255)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<ContactName>,
        #[serde(
            rename = "PaymentTerms",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_terms: Option<PaymentTerm>,
        ///Store certain phone types for a contact – see phone types
        #[serde(rename = "Phones", default, skip_serializing_if = "Vec::is_empty")]
        pub phones: Vec<Phone>,
        ///The default purchases account code for contacts
        #[serde(
            rename = "PurchasesDefaultAccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchases_default_account_code: Option<String>,
        ///The default purchases line amount type for a contact Only available
        /// when summaryOnly parameter or paging is used, or when fetch by
        /// ContactId or ContactNumber.
        #[serde(
            rename = "PurchasesDefaultLineAmountType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchases_default_line_amount_type: Option<ContactPurchasesDefaultLineAmountType>,
        ///The default purchases tracking categories for contacts
        #[serde(
            rename = "PurchasesTrackingCategories",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub purchases_tracking_categories: Vec<SalesTrackingCategory>,
        ///The default sales account code for contacts
        #[serde(
            rename = "SalesDefaultAccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_default_account_code: Option<String>,
        ///The default sales line amount type for a contact. Only available
        /// when summaryOnly parameter or paging is used, or when fetch by
        /// ContactId or ContactNumber.
        #[serde(
            rename = "SalesDefaultLineAmountType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_default_line_amount_type: Option<ContactSalesDefaultLineAmountType>,
        ///The default sales tracking categories for contacts
        #[serde(
            rename = "SalesTrackingCategories",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub sales_tracking_categories: Vec<SalesTrackingCategory>,
        ///Status of object
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        ///Tax number of contact – this is also known as the ABN (Australia),
        /// GST Number (New Zealand), VAT Number (UK) or Tax ID Number (US and
        /// global) in the Xero UI depending on which regionalized version of
        /// Xero you are using (max length = 50)
        #[serde(rename = "TaxNumber", default, skip_serializing_if = "Option::is_none")]
        pub tax_number: Option<ContactTaxNumber>,
        ///The name of the Tracking Category assigned to the contact under
        /// SalesTrackingCategories and PurchasesTrackingCategories
        #[serde(
            rename = "TrackingCategoryName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_name: Option<String>,
        ///The name of the Tracking Option assigned to the contact under
        /// SalesTrackingCategories and PurchasesTrackingCategories
        #[serde(
            rename = "TrackingCategoryOption",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_option: Option<String>,
        ///UTC timestamp of last update to contact
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays validation errors returned from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Website address for contact (read only)
        #[serde(rename = "Website", default, skip_serializing_if = "Option::is_none")]
        pub website: Option<String>,
        ///Store XeroNetworkKey for contacts.
        #[serde(
            rename = "XeroNetworkKey",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub xero_network_key: Option<String>,
    }

    impl From<&Contact> for Contact {
        fn from(value: &Contact) -> Self {
            value.clone()
        }
    }

    ///A user defined account number. This can be updated via the API and the
    /// Xero UI (max length = 50)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A user defined account number. This can be updated via
    /// the API and the Xero UI (max length = 50)",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactAccountNumber(String);
    impl ::std::ops::Deref for ContactAccountNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactAccountNumber> for String {
        fn from(value: ContactAccountNumber) -> Self {
            value.0
        }
    }

    impl From<&ContactAccountNumber> for ContactAccountNumber {
        fn from(value: &ContactAccountNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactAccountNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactAccountNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Company registration number (max length = 50)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Company registration number (max length = 50)",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactCompanyNumber(String);
    impl ::std::ops::Deref for ContactCompanyNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactCompanyNumber> for String {
        fn from(value: ContactCompanyNumber) -> Self {
            value.0
        }
    }

    impl From<&ContactCompanyNumber> for ContactCompanyNumber {
        fn from(value: &ContactCompanyNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactCompanyNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactCompanyNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactCompanyNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactCompanyNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactCompanyNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///This can be updated via the API only i.e. This field is read only on the
    /// Xero contact screen, used to identify contacts in external systems (max
    /// length = 50). If the Contact Number is used, this is displayed as
    /// Contact Code in the Contacts UI in Xero.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This can be updated via the API only i.e. This field is
    /// read only on the Xero contact screen, used to identify contacts in
    /// external systems (max length = 50). If the Contact Number is used, this
    /// is displayed as Contact Code in the Contacts UI in Xero.",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactContactNumber(String);
    impl ::std::ops::Deref for ContactContactNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactContactNumber> for String {
        fn from(value: ContactContactNumber) -> Self {
            value.0
        }
    }

    impl From<&ContactContactNumber> for ContactContactNumber {
        fn from(value: &ContactContactNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactContactNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactContactNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactContactNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactContactNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactContactNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Current status of a contact – see contact status types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Current status of a contact – see contact status
    /// types",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "ARCHIVED",
    ///    "GDPRREQUEST"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ContactContactStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "GDPRREQUEST")]
        Gdprrequest,
    }

    impl From<&ContactContactStatus> for ContactContactStatus {
        fn from(value: &ContactContactStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ContactContactStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Gdprrequest => write!(f, "GDPRREQUEST"),
            }
        }
    }

    impl std::str::FromStr for ContactContactStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "ARCHIVED" => Ok(Self::Archived),
                "GDPRREQUEST" => Ok(Self::Gdprrequest),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ContactContactStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ContactContactStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ContactContactStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Email address of contact person (umlauts not supported) (max length  =
    /// 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Email address of contact person (umlauts not supported)
    /// (max length  = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactEmailAddress(String);
    impl ::std::ops::Deref for ContactEmailAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactEmailAddress> for String {
        fn from(value: ContactEmailAddress) -> Self {
            value.0
        }
    }

    impl From<&ContactEmailAddress> for ContactEmailAddress {
        fn from(value: &ContactEmailAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactEmailAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactEmailAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactEmailAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactEmailAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactEmailAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///First name of contact person (max length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "First name of contact person (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactFirstName(String);
    impl ::std::ops::Deref for ContactFirstName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactFirstName> for String {
        fn from(value: ContactFirstName) -> Self {
            value.0
        }
    }

    impl From<&ContactFirstName> for ContactFirstName {
        fn from(value: &ContactFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactFirstName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///ContactGroup
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ContactGroupID": {
    ///      "description": "The Xero identifier for an contact group –
    /// specified as a string following the endpoint name. e.g.
    /// /297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Contacts": {
    ///      "description": "The ContactID and Name of Contacts in a contact
    /// group. Returned on GETs when the ContactGroupID is supplied in the
    /// URL.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Contact"
    ///      }
    ///    },
    ///    "Name": {
    ///      "description": "The Name of the contact group. Required when
    /// creating a new contact  group",
    ///      "type": "string"
    ///    },
    ///    "Status": {
    ///      "description": "The Status of a contact group. To delete a contact
    /// group update the status to DELETED. Only contact groups with a status of
    /// ACTIVE are returned on GETs.",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "DELETED"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ContactGroup {
        ///The Xero identifier for an contact group – specified as a string
        /// following the endpoint name. e.g.
        /// /297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(
            rename = "ContactGroupID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub contact_group_id: Option<uuid::Uuid>,
        ///The ContactID and Name of Contacts in a contact group. Returned on
        /// GETs when the ContactGroupID is supplied in the URL.
        #[serde(rename = "Contacts", default, skip_serializing_if = "Vec::is_empty")]
        pub contacts: Vec<Contact>,
        ///The Name of the contact group. Required when creating a new contact
        /// group
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///The Status of a contact group. To delete a contact group update the
        /// status to DELETED. Only contact groups with a status of ACTIVE are
        /// returned on GETs.
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ContactGroupStatus>,
    }

    impl From<&ContactGroup> for ContactGroup {
        fn from(value: &ContactGroup) -> Self {
            value.clone()
        }
    }

    ///The Status of a contact group. To delete a contact group update the
    /// status to DELETED. Only contact groups with a status of ACTIVE are
    /// returned on GETs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Status of a contact group. To delete a contact
    /// group update the status to DELETED. Only contact groups with a status of
    /// ACTIVE are returned on GETs.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ContactGroupStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&ContactGroupStatus> for ContactGroupStatus {
        fn from(value: &ContactGroupStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ContactGroupStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for ContactGroupStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ContactGroupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ContactGroupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ContactGroupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///ContactGroups
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ContactGroups": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ContactGroup"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "contact_groups"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ContactGroups {
        #[serde(
            rename = "ContactGroups",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub contact_groups: Vec<ContactGroup>,
    }

    impl From<&ContactGroups> for ContactGroups {
        fn from(value: &ContactGroups) -> Self {
            value.clone()
        }
    }

    ///Last name of contact person (max length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Last name of contact person (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactLastName(String);
    impl ::std::ops::Deref for ContactLastName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactLastName> for String {
        fn from(value: ContactLastName) -> Self {
            value.0
        }
    }

    impl From<&ContactLastName> for ContactLastName {
        fn from(value: &ContactLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactLastName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Full name of contact/organisation (max length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Full name of contact/organisation (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactName(String);
    impl ::std::ops::Deref for ContactName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactName> for String {
        fn from(value: ContactName) -> Self {
            value.0
        }
    }

    impl From<&ContactName> for ContactName {
        fn from(value: &ContactName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///ContactPerson
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "EmailAddress": {
    ///      "description": "Email address of person",
    ///      "type": "string"
    ///    },
    ///    "FirstName": {
    ///      "description": "First name of person",
    ///      "type": "string"
    ///    },
    ///    "IncludeInEmails": {
    ///      "description": "boolean to indicate whether contact should be
    /// included on emails with invoices etc.",
    ///      "type": "boolean"
    ///    },
    ///    "LastName": {
    ///      "description": "Last name of person",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ContactPerson {
        ///Email address of person
        #[serde(
            rename = "EmailAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub email_address: Option<String>,
        ///First name of person
        #[serde(rename = "FirstName", default, skip_serializing_if = "Option::is_none")]
        pub first_name: Option<String>,
        ///boolean to indicate whether contact should be included on emails
        /// with invoices etc.
        #[serde(
            rename = "IncludeInEmails",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub include_in_emails: Option<bool>,
        ///Last name of person
        #[serde(rename = "LastName", default, skip_serializing_if = "Option::is_none")]
        pub last_name: Option<String>,
    }

    impl From<&ContactPerson> for ContactPerson {
        fn from(value: &ContactPerson) -> Self {
            value.clone()
        }
    }

    ///The default purchases line amount type for a contact Only available when
    /// summaryOnly parameter or paging is used, or when fetch by ContactId or
    /// ContactNumber.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The default purchases line amount type for a contact
    /// Only available when summaryOnly parameter or paging is used, or when
    /// fetch by ContactId or ContactNumber.",
    ///  "type": "string",
    ///  "enum": [
    ///    "INCLUSIVE",
    ///    "EXCLUSIVE",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ContactPurchasesDefaultLineAmountType {
        #[serde(rename = "INCLUSIVE")]
        Inclusive,
        #[serde(rename = "EXCLUSIVE")]
        Exclusive,
        #[serde(rename = "NONE")]
        None,
    }

    impl From<&ContactPurchasesDefaultLineAmountType> for ContactPurchasesDefaultLineAmountType {
        fn from(value: &ContactPurchasesDefaultLineAmountType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ContactPurchasesDefaultLineAmountType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Inclusive => write!(f, "INCLUSIVE"),
                Self::Exclusive => write!(f, "EXCLUSIVE"),
                Self::None => write!(f, "NONE"),
            }
        }
    }

    impl std::str::FromStr for ContactPurchasesDefaultLineAmountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "INCLUSIVE" => Ok(Self::Inclusive),
                "EXCLUSIVE" => Ok(Self::Exclusive),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ContactPurchasesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ContactPurchasesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ContactPurchasesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The default sales line amount type for a contact. Only available when
    /// summaryOnly parameter or paging is used, or when fetch by ContactId or
    /// ContactNumber.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The default sales line amount type for a contact. Only
    /// available when summaryOnly parameter or paging is used, or when fetch by
    /// ContactId or ContactNumber.",
    ///  "type": "string",
    ///  "enum": [
    ///    "INCLUSIVE",
    ///    "EXCLUSIVE",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ContactSalesDefaultLineAmountType {
        #[serde(rename = "INCLUSIVE")]
        Inclusive,
        #[serde(rename = "EXCLUSIVE")]
        Exclusive,
        #[serde(rename = "NONE")]
        None,
    }

    impl From<&ContactSalesDefaultLineAmountType> for ContactSalesDefaultLineAmountType {
        fn from(value: &ContactSalesDefaultLineAmountType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ContactSalesDefaultLineAmountType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Inclusive => write!(f, "INCLUSIVE"),
                Self::Exclusive => write!(f, "EXCLUSIVE"),
                Self::None => write!(f, "NONE"),
            }
        }
    }

    impl std::str::FromStr for ContactSalesDefaultLineAmountType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "INCLUSIVE" => Ok(Self::Inclusive),
                "EXCLUSIVE" => Ok(Self::Exclusive),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ContactSalesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ContactSalesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ContactSalesDefaultLineAmountType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Tax number of contact – this is also known as the ABN (Australia), GST
    /// Number (New Zealand), VAT Number (UK) or Tax ID Number (US and global)
    /// in the Xero UI depending on which regionalized version of Xero you are
    /// using (max length = 50)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Tax number of contact – this is also known as the ABN
    /// (Australia), GST Number (New Zealand), VAT Number (UK) or Tax ID Number
    /// (US and global) in the Xero UI depending on which regionalized version
    /// of Xero you are using (max length = 50)",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ContactTaxNumber(String);
    impl ::std::ops::Deref for ContactTaxNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ContactTaxNumber> for String {
        fn from(value: ContactTaxNumber) -> Self {
            value.0
        }
    }

    impl From<&ContactTaxNumber> for ContactTaxNumber {
        fn from(value: &ContactTaxNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ContactTaxNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ContactTaxNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ContactTaxNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ContactTaxNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ContactTaxNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contacts
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Contacts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Contact"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "contacts"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Contacts {
        #[serde(rename = "Contacts", default, skip_serializing_if = "Vec::is_empty")]
        pub contacts: Vec<Contact>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Contacts> for Contacts {
        fn from(value: &Contacts) -> Self {
            value.clone()
        }
    }

    ///Balance supplied for each account that has a value as at the conversion
    /// date.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Balance supplied for each account that has a value as
    /// at the conversion date.",
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "The account code for a account",
    ///      "type": "string"
    ///    },
    ///    "Balance": {
    ///      "description": "The opening balances of the account. Debits are
    /// positive, credits are negative values",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "BalanceDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BalanceDetails"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConversionBalances {
        ///The account code for a account
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        #[serde(rename = "Balance", default, skip_serializing_if = "Option::is_none")]
        pub balance: Option<f64>,
        #[serde(
            rename = "BalanceDetails",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub balance_details: Vec<BalanceDetails>,
    }

    impl From<&ConversionBalances> for ConversionBalances {
        fn from(value: &ConversionBalances) -> Self {
            value.clone()
        }
    }

    ///The date when the organisation starts using Xero
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The date when the organisation starts using Xero",
    ///  "type": "object",
    ///  "properties": {
    ///    "Month": {
    ///      "description": "The month the organisation starts using Xero. Value
    /// is an integer between 1 and 12",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "Year": {
    ///      "description": "The year the organisation starts using Xero. Value
    /// is an integer greater than 2006",
    ///      "examples": [
    ///        2020
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConversionDate {
        ///The month the organisation starts using Xero. Value is an integer
        /// between 1 and 12
        #[serde(rename = "Month", default, skip_serializing_if = "Option::is_none")]
        pub month: Option<i64>,
        ///The year the organisation starts using Xero. Value is an integer
        /// greater than 2006
        #[serde(rename = "Year", default, skip_serializing_if = "Option::is_none")]
        pub year: Option<i64>,
    }

    impl From<&ConversionDate> for ConversionDate {
        fn from(value: &ConversionDate) -> Self {
            value.clone()
        }
    }

    ///CountryCode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "AD",
    ///    "AE",
    ///    "AF",
    ///    "AG",
    ///    "AI",
    ///    "AL",
    ///    "AM",
    ///    "AN",
    ///    "AO",
    ///    "AQ",
    ///    "AR",
    ///    "AS",
    ///    "AT",
    ///    "AU",
    ///    "AW",
    ///    "AZ",
    ///    "BA",
    ///    "BB",
    ///    "BD",
    ///    "BE",
    ///    "BF",
    ///    "BG",
    ///    "BH",
    ///    "BI",
    ///    "BJ",
    ///    "BL",
    ///    "BM",
    ///    "BN",
    ///    "BO",
    ///    "BR",
    ///    "BS",
    ///    "BT",
    ///    "BW",
    ///    "BY",
    ///    "BZ",
    ///    "CA",
    ///    "CC",
    ///    "CD",
    ///    "CF",
    ///    "CG",
    ///    "CH",
    ///    "CI",
    ///    "CK",
    ///    "CL",
    ///    "CM",
    ///    "CN",
    ///    "CO",
    ///    "CR",
    ///    "CU",
    ///    "CV",
    ///    "CW",
    ///    "CX",
    ///    "CY",
    ///    "CZ",
    ///    "DE",
    ///    "DJ",
    ///    "DK",
    ///    "DM",
    ///    "DO",
    ///    "DZ",
    ///    "EC",
    ///    "EE",
    ///    "EG",
    ///    "EH",
    ///    "ER",
    ///    "ES",
    ///    "ET",
    ///    "FI",
    ///    "FJ",
    ///    "FK",
    ///    "FM",
    ///    "FO",
    ///    "FR",
    ///    "GA",
    ///    "GB",
    ///    "GD",
    ///    "GE",
    ///    "GG",
    ///    "GH",
    ///    "GI",
    ///    "GL",
    ///    "GM",
    ///    "GN",
    ///    "GQ",
    ///    "GR",
    ///    "GT",
    ///    "GU",
    ///    "GW",
    ///    "GY",
    ///    "HK",
    ///    "HN",
    ///    "HR",
    ///    "HT",
    ///    "HU",
    ///    "ID",
    ///    "IE",
    ///    "IL",
    ///    "IM",
    ///    "IN",
    ///    "IO",
    ///    "IQ",
    ///    "IR",
    ///    "IS",
    ///    "IT",
    ///    "JE",
    ///    "JM",
    ///    "JO",
    ///    "JP",
    ///    "KE",
    ///    "KG",
    ///    "KH",
    ///    "KI",
    ///    "KM",
    ///    "KN",
    ///    "KP",
    ///    "KR",
    ///    "KW",
    ///    "KY",
    ///    "KZ",
    ///    "LA",
    ///    "LB",
    ///    "LC",
    ///    "LI",
    ///    "LK",
    ///    "LR",
    ///    "LS",
    ///    "LT",
    ///    "LU",
    ///    "LV",
    ///    "LY",
    ///    "MA",
    ///    "MC",
    ///    "MD",
    ///    "ME",
    ///    "MF",
    ///    "MG",
    ///    "MH",
    ///    "MK",
    ///    "ML",
    ///    "MM",
    ///    "MN",
    ///    "MO",
    ///    "MP",
    ///    "MR",
    ///    "MS",
    ///    "MT",
    ///    "MU",
    ///    "MV",
    ///    "MW",
    ///    "MX",
    ///    "MY",
    ///    "MZ",
    ///    "NA",
    ///    "NC",
    ///    "NE",
    ///    "NG",
    ///    "NI",
    ///    "NL",
    ///    "NO",
    ///    "NP",
    ///    "NR",
    ///    "NU",
    ///    "NZ",
    ///    "OM",
    ///    "PA",
    ///    "PE",
    ///    "PF",
    ///    "PG",
    ///    "PH",
    ///    "PK",
    ///    "PL",
    ///    "PM",
    ///    "PN",
    ///    "PR",
    ///    "PS",
    ///    "PT",
    ///    "PW",
    ///    "PY",
    ///    "QA",
    ///    "RE",
    ///    "RO",
    ///    "RS",
    ///    "RU",
    ///    "RW",
    ///    "SA",
    ///    "SB",
    ///    "SC",
    ///    "SD",
    ///    "SE",
    ///    "SG",
    ///    "SH",
    ///    "SI",
    ///    "SJ",
    ///    "SK",
    ///    "SL",
    ///    "SM",
    ///    "SN",
    ///    "SO",
    ///    "SR",
    ///    "SS",
    ///    "ST",
    ///    "SV",
    ///    "SX",
    ///    "SY",
    ///    "SZ",
    ///    "TC",
    ///    "TD",
    ///    "TG",
    ///    "TH",
    ///    "TJ",
    ///    "TK",
    ///    "TL",
    ///    "TM",
    ///    "TN",
    ///    "TO",
    ///    "TR",
    ///    "TT",
    ///    "TV",
    ///    "TW",
    ///    "TZ",
    ///    "UA",
    ///    "UG",
    ///    "US",
    ///    "UY",
    ///    "UZ",
    ///    "VA",
    ///    "VC",
    ///    "VE",
    ///    "VG",
    ///    "VI",
    ///    "VN",
    ///    "VU",
    ///    "WF",
    ///    "WS",
    ///    "XK",
    ///    "YE",
    ///    "YT",
    ///    "ZA",
    ///    "ZM",
    ///    "ZW"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CountryCode {
        #[serde(rename = "AD")]
        Ad,
        #[serde(rename = "AE")]
        Ae,
        #[serde(rename = "AF")]
        Af,
        #[serde(rename = "AG")]
        Ag,
        #[serde(rename = "AI")]
        Ai,
        #[serde(rename = "AL")]
        Al,
        #[serde(rename = "AM")]
        Am,
        #[serde(rename = "AN")]
        An,
        #[serde(rename = "AO")]
        Ao,
        #[serde(rename = "AQ")]
        Aq,
        #[serde(rename = "AR")]
        Ar,
        #[serde(rename = "AS")]
        As,
        #[serde(rename = "AT")]
        At,
        #[serde(rename = "AU")]
        Au,
        #[serde(rename = "AW")]
        Aw,
        #[serde(rename = "AZ")]
        Az,
        #[serde(rename = "BA")]
        Ba,
        #[serde(rename = "BB")]
        Bb,
        #[serde(rename = "BD")]
        Bd,
        #[serde(rename = "BE")]
        Be,
        #[serde(rename = "BF")]
        Bf,
        #[serde(rename = "BG")]
        Bg,
        #[serde(rename = "BH")]
        Bh,
        #[serde(rename = "BI")]
        Bi,
        #[serde(rename = "BJ")]
        Bj,
        #[serde(rename = "BL")]
        Bl,
        #[serde(rename = "BM")]
        Bm,
        #[serde(rename = "BN")]
        Bn,
        #[serde(rename = "BO")]
        Bo,
        #[serde(rename = "BR")]
        Br,
        #[serde(rename = "BS")]
        Bs,
        #[serde(rename = "BT")]
        Bt,
        #[serde(rename = "BW")]
        Bw,
        #[serde(rename = "BY")]
        By,
        #[serde(rename = "BZ")]
        Bz,
        #[serde(rename = "CA")]
        Ca,
        #[serde(rename = "CC")]
        Cc,
        #[serde(rename = "CD")]
        Cd,
        #[serde(rename = "CF")]
        Cf,
        #[serde(rename = "CG")]
        Cg,
        #[serde(rename = "CH")]
        Ch,
        #[serde(rename = "CI")]
        Ci,
        #[serde(rename = "CK")]
        Ck,
        #[serde(rename = "CL")]
        Cl,
        #[serde(rename = "CM")]
        Cm,
        #[serde(rename = "CN")]
        Cn,
        #[serde(rename = "CO")]
        Co,
        #[serde(rename = "CR")]
        Cr,
        #[serde(rename = "CU")]
        Cu,
        #[serde(rename = "CV")]
        Cv,
        #[serde(rename = "CW")]
        Cw,
        #[serde(rename = "CX")]
        Cx,
        #[serde(rename = "CY")]
        Cy,
        #[serde(rename = "CZ")]
        Cz,
        #[serde(rename = "DE")]
        De,
        #[serde(rename = "DJ")]
        Dj,
        #[serde(rename = "DK")]
        Dk,
        #[serde(rename = "DM")]
        Dm,
        #[serde(rename = "DO")]
        Do,
        #[serde(rename = "DZ")]
        Dz,
        #[serde(rename = "EC")]
        Ec,
        #[serde(rename = "EE")]
        Ee,
        #[serde(rename = "EG")]
        Eg,
        #[serde(rename = "EH")]
        Eh,
        #[serde(rename = "ER")]
        Er,
        #[serde(rename = "ES")]
        Es,
        #[serde(rename = "ET")]
        Et,
        #[serde(rename = "FI")]
        Fi,
        #[serde(rename = "FJ")]
        Fj,
        #[serde(rename = "FK")]
        Fk,
        #[serde(rename = "FM")]
        Fm,
        #[serde(rename = "FO")]
        Fo,
        #[serde(rename = "FR")]
        Fr,
        #[serde(rename = "GA")]
        Ga,
        #[serde(rename = "GB")]
        Gb,
        #[serde(rename = "GD")]
        Gd,
        #[serde(rename = "GE")]
        Ge,
        #[serde(rename = "GG")]
        Gg,
        #[serde(rename = "GH")]
        Gh,
        #[serde(rename = "GI")]
        Gi,
        #[serde(rename = "GL")]
        Gl,
        #[serde(rename = "GM")]
        Gm,
        #[serde(rename = "GN")]
        Gn,
        #[serde(rename = "GQ")]
        Gq,
        #[serde(rename = "GR")]
        Gr,
        #[serde(rename = "GT")]
        Gt,
        #[serde(rename = "GU")]
        Gu,
        #[serde(rename = "GW")]
        Gw,
        #[serde(rename = "GY")]
        Gy,
        #[serde(rename = "HK")]
        Hk,
        #[serde(rename = "HN")]
        Hn,
        #[serde(rename = "HR")]
        Hr,
        #[serde(rename = "HT")]
        Ht,
        #[serde(rename = "HU")]
        Hu,
        #[serde(rename = "ID")]
        Id,
        #[serde(rename = "IE")]
        Ie,
        #[serde(rename = "IL")]
        Il,
        #[serde(rename = "IM")]
        Im,
        #[serde(rename = "IN")]
        In,
        #[serde(rename = "IO")]
        Io,
        #[serde(rename = "IQ")]
        Iq,
        #[serde(rename = "IR")]
        Ir,
        #[serde(rename = "IS")]
        Is,
        #[serde(rename = "IT")]
        It,
        #[serde(rename = "JE")]
        Je,
        #[serde(rename = "JM")]
        Jm,
        #[serde(rename = "JO")]
        Jo,
        #[serde(rename = "JP")]
        Jp,
        #[serde(rename = "KE")]
        Ke,
        #[serde(rename = "KG")]
        Kg,
        #[serde(rename = "KH")]
        Kh,
        #[serde(rename = "KI")]
        Ki,
        #[serde(rename = "KM")]
        Km,
        #[serde(rename = "KN")]
        Kn,
        #[serde(rename = "KP")]
        Kp,
        #[serde(rename = "KR")]
        Kr,
        #[serde(rename = "KW")]
        Kw,
        #[serde(rename = "KY")]
        Ky,
        #[serde(rename = "KZ")]
        Kz,
        #[serde(rename = "LA")]
        La,
        #[serde(rename = "LB")]
        Lb,
        #[serde(rename = "LC")]
        Lc,
        #[serde(rename = "LI")]
        Li,
        #[serde(rename = "LK")]
        Lk,
        #[serde(rename = "LR")]
        Lr,
        #[serde(rename = "LS")]
        Ls,
        #[serde(rename = "LT")]
        Lt,
        #[serde(rename = "LU")]
        Lu,
        #[serde(rename = "LV")]
        Lv,
        #[serde(rename = "LY")]
        Ly,
        #[serde(rename = "MA")]
        Ma,
        #[serde(rename = "MC")]
        Mc,
        #[serde(rename = "MD")]
        Md,
        #[serde(rename = "ME")]
        Me,
        #[serde(rename = "MF")]
        Mf,
        #[serde(rename = "MG")]
        Mg,
        #[serde(rename = "MH")]
        Mh,
        #[serde(rename = "MK")]
        Mk,
        #[serde(rename = "ML")]
        Ml,
        #[serde(rename = "MM")]
        Mm,
        #[serde(rename = "MN")]
        Mn,
        #[serde(rename = "MO")]
        Mo,
        #[serde(rename = "MP")]
        Mp,
        #[serde(rename = "MR")]
        Mr,
        #[serde(rename = "MS")]
        Ms,
        #[serde(rename = "MT")]
        Mt,
        #[serde(rename = "MU")]
        Mu,
        #[serde(rename = "MV")]
        Mv,
        #[serde(rename = "MW")]
        Mw,
        #[serde(rename = "MX")]
        Mx,
        #[serde(rename = "MY")]
        My,
        #[serde(rename = "MZ")]
        Mz,
        #[serde(rename = "NA")]
        Na,
        #[serde(rename = "NC")]
        Nc,
        #[serde(rename = "NE")]
        Ne,
        #[serde(rename = "NG")]
        Ng,
        #[serde(rename = "NI")]
        Ni,
        #[serde(rename = "NL")]
        Nl,
        #[serde(rename = "NO")]
        No,
        #[serde(rename = "NP")]
        Np,
        #[serde(rename = "NR")]
        Nr,
        #[serde(rename = "NU")]
        Nu,
        #[serde(rename = "NZ")]
        Nz,
        #[serde(rename = "OM")]
        Om,
        #[serde(rename = "PA")]
        Pa,
        #[serde(rename = "PE")]
        Pe,
        #[serde(rename = "PF")]
        Pf,
        #[serde(rename = "PG")]
        Pg,
        #[serde(rename = "PH")]
        Ph,
        #[serde(rename = "PK")]
        Pk,
        #[serde(rename = "PL")]
        Pl,
        #[serde(rename = "PM")]
        Pm,
        #[serde(rename = "PN")]
        Pn,
        #[serde(rename = "PR")]
        Pr,
        #[serde(rename = "PS")]
        Ps,
        #[serde(rename = "PT")]
        Pt,
        #[serde(rename = "PW")]
        Pw,
        #[serde(rename = "PY")]
        Py,
        #[serde(rename = "QA")]
        Qa,
        #[serde(rename = "RE")]
        Re,
        #[serde(rename = "RO")]
        Ro,
        #[serde(rename = "RS")]
        Rs,
        #[serde(rename = "RU")]
        Ru,
        #[serde(rename = "RW")]
        Rw,
        #[serde(rename = "SA")]
        Sa,
        #[serde(rename = "SB")]
        Sb,
        #[serde(rename = "SC")]
        Sc,
        #[serde(rename = "SD")]
        Sd,
        #[serde(rename = "SE")]
        Se,
        #[serde(rename = "SG")]
        Sg,
        #[serde(rename = "SH")]
        Sh,
        #[serde(rename = "SI")]
        Si,
        #[serde(rename = "SJ")]
        Sj,
        #[serde(rename = "SK")]
        Sk,
        #[serde(rename = "SL")]
        Sl,
        #[serde(rename = "SM")]
        Sm,
        #[serde(rename = "SN")]
        Sn,
        #[serde(rename = "SO")]
        So,
        #[serde(rename = "SR")]
        Sr,
        #[serde(rename = "SS")]
        Ss,
        #[serde(rename = "ST")]
        St,
        #[serde(rename = "SV")]
        Sv,
        #[serde(rename = "SX")]
        Sx,
        #[serde(rename = "SY")]
        Sy,
        #[serde(rename = "SZ")]
        Sz,
        #[serde(rename = "TC")]
        Tc,
        #[serde(rename = "TD")]
        Td,
        #[serde(rename = "TG")]
        Tg,
        #[serde(rename = "TH")]
        Th,
        #[serde(rename = "TJ")]
        Tj,
        #[serde(rename = "TK")]
        Tk,
        #[serde(rename = "TL")]
        Tl,
        #[serde(rename = "TM")]
        Tm,
        #[serde(rename = "TN")]
        Tn,
        #[serde(rename = "TO")]
        To,
        #[serde(rename = "TR")]
        Tr,
        #[serde(rename = "TT")]
        Tt,
        #[serde(rename = "TV")]
        Tv,
        #[serde(rename = "TW")]
        Tw,
        #[serde(rename = "TZ")]
        Tz,
        #[serde(rename = "UA")]
        Ua,
        #[serde(rename = "UG")]
        Ug,
        #[serde(rename = "US")]
        Us,
        #[serde(rename = "UY")]
        Uy,
        #[serde(rename = "UZ")]
        Uz,
        #[serde(rename = "VA")]
        Va,
        #[serde(rename = "VC")]
        Vc,
        #[serde(rename = "VE")]
        Ve,
        #[serde(rename = "VG")]
        Vg,
        #[serde(rename = "VI")]
        Vi,
        #[serde(rename = "VN")]
        Vn,
        #[serde(rename = "VU")]
        Vu,
        #[serde(rename = "WF")]
        Wf,
        #[serde(rename = "WS")]
        Ws,
        #[serde(rename = "XK")]
        Xk,
        #[serde(rename = "YE")]
        Ye,
        #[serde(rename = "YT")]
        Yt,
        #[serde(rename = "ZA")]
        Za,
        #[serde(rename = "ZM")]
        Zm,
        #[serde(rename = "ZW")]
        Zw,
    }

    impl From<&CountryCode> for CountryCode {
        fn from(value: &CountryCode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CountryCode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ad => write!(f, "AD"),
                Self::Ae => write!(f, "AE"),
                Self::Af => write!(f, "AF"),
                Self::Ag => write!(f, "AG"),
                Self::Ai => write!(f, "AI"),
                Self::Al => write!(f, "AL"),
                Self::Am => write!(f, "AM"),
                Self::An => write!(f, "AN"),
                Self::Ao => write!(f, "AO"),
                Self::Aq => write!(f, "AQ"),
                Self::Ar => write!(f, "AR"),
                Self::As => write!(f, "AS"),
                Self::At => write!(f, "AT"),
                Self::Au => write!(f, "AU"),
                Self::Aw => write!(f, "AW"),
                Self::Az => write!(f, "AZ"),
                Self::Ba => write!(f, "BA"),
                Self::Bb => write!(f, "BB"),
                Self::Bd => write!(f, "BD"),
                Self::Be => write!(f, "BE"),
                Self::Bf => write!(f, "BF"),
                Self::Bg => write!(f, "BG"),
                Self::Bh => write!(f, "BH"),
                Self::Bi => write!(f, "BI"),
                Self::Bj => write!(f, "BJ"),
                Self::Bl => write!(f, "BL"),
                Self::Bm => write!(f, "BM"),
                Self::Bn => write!(f, "BN"),
                Self::Bo => write!(f, "BO"),
                Self::Br => write!(f, "BR"),
                Self::Bs => write!(f, "BS"),
                Self::Bt => write!(f, "BT"),
                Self::Bw => write!(f, "BW"),
                Self::By => write!(f, "BY"),
                Self::Bz => write!(f, "BZ"),
                Self::Ca => write!(f, "CA"),
                Self::Cc => write!(f, "CC"),
                Self::Cd => write!(f, "CD"),
                Self::Cf => write!(f, "CF"),
                Self::Cg => write!(f, "CG"),
                Self::Ch => write!(f, "CH"),
                Self::Ci => write!(f, "CI"),
                Self::Ck => write!(f, "CK"),
                Self::Cl => write!(f, "CL"),
                Self::Cm => write!(f, "CM"),
                Self::Cn => write!(f, "CN"),
                Self::Co => write!(f, "CO"),
                Self::Cr => write!(f, "CR"),
                Self::Cu => write!(f, "CU"),
                Self::Cv => write!(f, "CV"),
                Self::Cw => write!(f, "CW"),
                Self::Cx => write!(f, "CX"),
                Self::Cy => write!(f, "CY"),
                Self::Cz => write!(f, "CZ"),
                Self::De => write!(f, "DE"),
                Self::Dj => write!(f, "DJ"),
                Self::Dk => write!(f, "DK"),
                Self::Dm => write!(f, "DM"),
                Self::Do => write!(f, "DO"),
                Self::Dz => write!(f, "DZ"),
                Self::Ec => write!(f, "EC"),
                Self::Ee => write!(f, "EE"),
                Self::Eg => write!(f, "EG"),
                Self::Eh => write!(f, "EH"),
                Self::Er => write!(f, "ER"),
                Self::Es => write!(f, "ES"),
                Self::Et => write!(f, "ET"),
                Self::Fi => write!(f, "FI"),
                Self::Fj => write!(f, "FJ"),
                Self::Fk => write!(f, "FK"),
                Self::Fm => write!(f, "FM"),
                Self::Fo => write!(f, "FO"),
                Self::Fr => write!(f, "FR"),
                Self::Ga => write!(f, "GA"),
                Self::Gb => write!(f, "GB"),
                Self::Gd => write!(f, "GD"),
                Self::Ge => write!(f, "GE"),
                Self::Gg => write!(f, "GG"),
                Self::Gh => write!(f, "GH"),
                Self::Gi => write!(f, "GI"),
                Self::Gl => write!(f, "GL"),
                Self::Gm => write!(f, "GM"),
                Self::Gn => write!(f, "GN"),
                Self::Gq => write!(f, "GQ"),
                Self::Gr => write!(f, "GR"),
                Self::Gt => write!(f, "GT"),
                Self::Gu => write!(f, "GU"),
                Self::Gw => write!(f, "GW"),
                Self::Gy => write!(f, "GY"),
                Self::Hk => write!(f, "HK"),
                Self::Hn => write!(f, "HN"),
                Self::Hr => write!(f, "HR"),
                Self::Ht => write!(f, "HT"),
                Self::Hu => write!(f, "HU"),
                Self::Id => write!(f, "ID"),
                Self::Ie => write!(f, "IE"),
                Self::Il => write!(f, "IL"),
                Self::Im => write!(f, "IM"),
                Self::In => write!(f, "IN"),
                Self::Io => write!(f, "IO"),
                Self::Iq => write!(f, "IQ"),
                Self::Ir => write!(f, "IR"),
                Self::Is => write!(f, "IS"),
                Self::It => write!(f, "IT"),
                Self::Je => write!(f, "JE"),
                Self::Jm => write!(f, "JM"),
                Self::Jo => write!(f, "JO"),
                Self::Jp => write!(f, "JP"),
                Self::Ke => write!(f, "KE"),
                Self::Kg => write!(f, "KG"),
                Self::Kh => write!(f, "KH"),
                Self::Ki => write!(f, "KI"),
                Self::Km => write!(f, "KM"),
                Self::Kn => write!(f, "KN"),
                Self::Kp => write!(f, "KP"),
                Self::Kr => write!(f, "KR"),
                Self::Kw => write!(f, "KW"),
                Self::Ky => write!(f, "KY"),
                Self::Kz => write!(f, "KZ"),
                Self::La => write!(f, "LA"),
                Self::Lb => write!(f, "LB"),
                Self::Lc => write!(f, "LC"),
                Self::Li => write!(f, "LI"),
                Self::Lk => write!(f, "LK"),
                Self::Lr => write!(f, "LR"),
                Self::Ls => write!(f, "LS"),
                Self::Lt => write!(f, "LT"),
                Self::Lu => write!(f, "LU"),
                Self::Lv => write!(f, "LV"),
                Self::Ly => write!(f, "LY"),
                Self::Ma => write!(f, "MA"),
                Self::Mc => write!(f, "MC"),
                Self::Md => write!(f, "MD"),
                Self::Me => write!(f, "ME"),
                Self::Mf => write!(f, "MF"),
                Self::Mg => write!(f, "MG"),
                Self::Mh => write!(f, "MH"),
                Self::Mk => write!(f, "MK"),
                Self::Ml => write!(f, "ML"),
                Self::Mm => write!(f, "MM"),
                Self::Mn => write!(f, "MN"),
                Self::Mo => write!(f, "MO"),
                Self::Mp => write!(f, "MP"),
                Self::Mr => write!(f, "MR"),
                Self::Ms => write!(f, "MS"),
                Self::Mt => write!(f, "MT"),
                Self::Mu => write!(f, "MU"),
                Self::Mv => write!(f, "MV"),
                Self::Mw => write!(f, "MW"),
                Self::Mx => write!(f, "MX"),
                Self::My => write!(f, "MY"),
                Self::Mz => write!(f, "MZ"),
                Self::Na => write!(f, "NA"),
                Self::Nc => write!(f, "NC"),
                Self::Ne => write!(f, "NE"),
                Self::Ng => write!(f, "NG"),
                Self::Ni => write!(f, "NI"),
                Self::Nl => write!(f, "NL"),
                Self::No => write!(f, "NO"),
                Self::Np => write!(f, "NP"),
                Self::Nr => write!(f, "NR"),
                Self::Nu => write!(f, "NU"),
                Self::Nz => write!(f, "NZ"),
                Self::Om => write!(f, "OM"),
                Self::Pa => write!(f, "PA"),
                Self::Pe => write!(f, "PE"),
                Self::Pf => write!(f, "PF"),
                Self::Pg => write!(f, "PG"),
                Self::Ph => write!(f, "PH"),
                Self::Pk => write!(f, "PK"),
                Self::Pl => write!(f, "PL"),
                Self::Pm => write!(f, "PM"),
                Self::Pn => write!(f, "PN"),
                Self::Pr => write!(f, "PR"),
                Self::Ps => write!(f, "PS"),
                Self::Pt => write!(f, "PT"),
                Self::Pw => write!(f, "PW"),
                Self::Py => write!(f, "PY"),
                Self::Qa => write!(f, "QA"),
                Self::Re => write!(f, "RE"),
                Self::Ro => write!(f, "RO"),
                Self::Rs => write!(f, "RS"),
                Self::Ru => write!(f, "RU"),
                Self::Rw => write!(f, "RW"),
                Self::Sa => write!(f, "SA"),
                Self::Sb => write!(f, "SB"),
                Self::Sc => write!(f, "SC"),
                Self::Sd => write!(f, "SD"),
                Self::Se => write!(f, "SE"),
                Self::Sg => write!(f, "SG"),
                Self::Sh => write!(f, "SH"),
                Self::Si => write!(f, "SI"),
                Self::Sj => write!(f, "SJ"),
                Self::Sk => write!(f, "SK"),
                Self::Sl => write!(f, "SL"),
                Self::Sm => write!(f, "SM"),
                Self::Sn => write!(f, "SN"),
                Self::So => write!(f, "SO"),
                Self::Sr => write!(f, "SR"),
                Self::Ss => write!(f, "SS"),
                Self::St => write!(f, "ST"),
                Self::Sv => write!(f, "SV"),
                Self::Sx => write!(f, "SX"),
                Self::Sy => write!(f, "SY"),
                Self::Sz => write!(f, "SZ"),
                Self::Tc => write!(f, "TC"),
                Self::Td => write!(f, "TD"),
                Self::Tg => write!(f, "TG"),
                Self::Th => write!(f, "TH"),
                Self::Tj => write!(f, "TJ"),
                Self::Tk => write!(f, "TK"),
                Self::Tl => write!(f, "TL"),
                Self::Tm => write!(f, "TM"),
                Self::Tn => write!(f, "TN"),
                Self::To => write!(f, "TO"),
                Self::Tr => write!(f, "TR"),
                Self::Tt => write!(f, "TT"),
                Self::Tv => write!(f, "TV"),
                Self::Tw => write!(f, "TW"),
                Self::Tz => write!(f, "TZ"),
                Self::Ua => write!(f, "UA"),
                Self::Ug => write!(f, "UG"),
                Self::Us => write!(f, "US"),
                Self::Uy => write!(f, "UY"),
                Self::Uz => write!(f, "UZ"),
                Self::Va => write!(f, "VA"),
                Self::Vc => write!(f, "VC"),
                Self::Ve => write!(f, "VE"),
                Self::Vg => write!(f, "VG"),
                Self::Vi => write!(f, "VI"),
                Self::Vn => write!(f, "VN"),
                Self::Vu => write!(f, "VU"),
                Self::Wf => write!(f, "WF"),
                Self::Ws => write!(f, "WS"),
                Self::Xk => write!(f, "XK"),
                Self::Ye => write!(f, "YE"),
                Self::Yt => write!(f, "YT"),
                Self::Za => write!(f, "ZA"),
                Self::Zm => write!(f, "ZM"),
                Self::Zw => write!(f, "ZW"),
            }
        }
    }

    impl std::str::FromStr for CountryCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AD" => Ok(Self::Ad),
                "AE" => Ok(Self::Ae),
                "AF" => Ok(Self::Af),
                "AG" => Ok(Self::Ag),
                "AI" => Ok(Self::Ai),
                "AL" => Ok(Self::Al),
                "AM" => Ok(Self::Am),
                "AN" => Ok(Self::An),
                "AO" => Ok(Self::Ao),
                "AQ" => Ok(Self::Aq),
                "AR" => Ok(Self::Ar),
                "AS" => Ok(Self::As),
                "AT" => Ok(Self::At),
                "AU" => Ok(Self::Au),
                "AW" => Ok(Self::Aw),
                "AZ" => Ok(Self::Az),
                "BA" => Ok(Self::Ba),
                "BB" => Ok(Self::Bb),
                "BD" => Ok(Self::Bd),
                "BE" => Ok(Self::Be),
                "BF" => Ok(Self::Bf),
                "BG" => Ok(Self::Bg),
                "BH" => Ok(Self::Bh),
                "BI" => Ok(Self::Bi),
                "BJ" => Ok(Self::Bj),
                "BL" => Ok(Self::Bl),
                "BM" => Ok(Self::Bm),
                "BN" => Ok(Self::Bn),
                "BO" => Ok(Self::Bo),
                "BR" => Ok(Self::Br),
                "BS" => Ok(Self::Bs),
                "BT" => Ok(Self::Bt),
                "BW" => Ok(Self::Bw),
                "BY" => Ok(Self::By),
                "BZ" => Ok(Self::Bz),
                "CA" => Ok(Self::Ca),
                "CC" => Ok(Self::Cc),
                "CD" => Ok(Self::Cd),
                "CF" => Ok(Self::Cf),
                "CG" => Ok(Self::Cg),
                "CH" => Ok(Self::Ch),
                "CI" => Ok(Self::Ci),
                "CK" => Ok(Self::Ck),
                "CL" => Ok(Self::Cl),
                "CM" => Ok(Self::Cm),
                "CN" => Ok(Self::Cn),
                "CO" => Ok(Self::Co),
                "CR" => Ok(Self::Cr),
                "CU" => Ok(Self::Cu),
                "CV" => Ok(Self::Cv),
                "CW" => Ok(Self::Cw),
                "CX" => Ok(Self::Cx),
                "CY" => Ok(Self::Cy),
                "CZ" => Ok(Self::Cz),
                "DE" => Ok(Self::De),
                "DJ" => Ok(Self::Dj),
                "DK" => Ok(Self::Dk),
                "DM" => Ok(Self::Dm),
                "DO" => Ok(Self::Do),
                "DZ" => Ok(Self::Dz),
                "EC" => Ok(Self::Ec),
                "EE" => Ok(Self::Ee),
                "EG" => Ok(Self::Eg),
                "EH" => Ok(Self::Eh),
                "ER" => Ok(Self::Er),
                "ES" => Ok(Self::Es),
                "ET" => Ok(Self::Et),
                "FI" => Ok(Self::Fi),
                "FJ" => Ok(Self::Fj),
                "FK" => Ok(Self::Fk),
                "FM" => Ok(Self::Fm),
                "FO" => Ok(Self::Fo),
                "FR" => Ok(Self::Fr),
                "GA" => Ok(Self::Ga),
                "GB" => Ok(Self::Gb),
                "GD" => Ok(Self::Gd),
                "GE" => Ok(Self::Ge),
                "GG" => Ok(Self::Gg),
                "GH" => Ok(Self::Gh),
                "GI" => Ok(Self::Gi),
                "GL" => Ok(Self::Gl),
                "GM" => Ok(Self::Gm),
                "GN" => Ok(Self::Gn),
                "GQ" => Ok(Self::Gq),
                "GR" => Ok(Self::Gr),
                "GT" => Ok(Self::Gt),
                "GU" => Ok(Self::Gu),
                "GW" => Ok(Self::Gw),
                "GY" => Ok(Self::Gy),
                "HK" => Ok(Self::Hk),
                "HN" => Ok(Self::Hn),
                "HR" => Ok(Self::Hr),
                "HT" => Ok(Self::Ht),
                "HU" => Ok(Self::Hu),
                "ID" => Ok(Self::Id),
                "IE" => Ok(Self::Ie),
                "IL" => Ok(Self::Il),
                "IM" => Ok(Self::Im),
                "IN" => Ok(Self::In),
                "IO" => Ok(Self::Io),
                "IQ" => Ok(Self::Iq),
                "IR" => Ok(Self::Ir),
                "IS" => Ok(Self::Is),
                "IT" => Ok(Self::It),
                "JE" => Ok(Self::Je),
                "JM" => Ok(Self::Jm),
                "JO" => Ok(Self::Jo),
                "JP" => Ok(Self::Jp),
                "KE" => Ok(Self::Ke),
                "KG" => Ok(Self::Kg),
                "KH" => Ok(Self::Kh),
                "KI" => Ok(Self::Ki),
                "KM" => Ok(Self::Km),
                "KN" => Ok(Self::Kn),
                "KP" => Ok(Self::Kp),
                "KR" => Ok(Self::Kr),
                "KW" => Ok(Self::Kw),
                "KY" => Ok(Self::Ky),
                "KZ" => Ok(Self::Kz),
                "LA" => Ok(Self::La),
                "LB" => Ok(Self::Lb),
                "LC" => Ok(Self::Lc),
                "LI" => Ok(Self::Li),
                "LK" => Ok(Self::Lk),
                "LR" => Ok(Self::Lr),
                "LS" => Ok(Self::Ls),
                "LT" => Ok(Self::Lt),
                "LU" => Ok(Self::Lu),
                "LV" => Ok(Self::Lv),
                "LY" => Ok(Self::Ly),
                "MA" => Ok(Self::Ma),
                "MC" => Ok(Self::Mc),
                "MD" => Ok(Self::Md),
                "ME" => Ok(Self::Me),
                "MF" => Ok(Self::Mf),
                "MG" => Ok(Self::Mg),
                "MH" => Ok(Self::Mh),
                "MK" => Ok(Self::Mk),
                "ML" => Ok(Self::Ml),
                "MM" => Ok(Self::Mm),
                "MN" => Ok(Self::Mn),
                "MO" => Ok(Self::Mo),
                "MP" => Ok(Self::Mp),
                "MR" => Ok(Self::Mr),
                "MS" => Ok(Self::Ms),
                "MT" => Ok(Self::Mt),
                "MU" => Ok(Self::Mu),
                "MV" => Ok(Self::Mv),
                "MW" => Ok(Self::Mw),
                "MX" => Ok(Self::Mx),
                "MY" => Ok(Self::My),
                "MZ" => Ok(Self::Mz),
                "NA" => Ok(Self::Na),
                "NC" => Ok(Self::Nc),
                "NE" => Ok(Self::Ne),
                "NG" => Ok(Self::Ng),
                "NI" => Ok(Self::Ni),
                "NL" => Ok(Self::Nl),
                "NO" => Ok(Self::No),
                "NP" => Ok(Self::Np),
                "NR" => Ok(Self::Nr),
                "NU" => Ok(Self::Nu),
                "NZ" => Ok(Self::Nz),
                "OM" => Ok(Self::Om),
                "PA" => Ok(Self::Pa),
                "PE" => Ok(Self::Pe),
                "PF" => Ok(Self::Pf),
                "PG" => Ok(Self::Pg),
                "PH" => Ok(Self::Ph),
                "PK" => Ok(Self::Pk),
                "PL" => Ok(Self::Pl),
                "PM" => Ok(Self::Pm),
                "PN" => Ok(Self::Pn),
                "PR" => Ok(Self::Pr),
                "PS" => Ok(Self::Ps),
                "PT" => Ok(Self::Pt),
                "PW" => Ok(Self::Pw),
                "PY" => Ok(Self::Py),
                "QA" => Ok(Self::Qa),
                "RE" => Ok(Self::Re),
                "RO" => Ok(Self::Ro),
                "RS" => Ok(Self::Rs),
                "RU" => Ok(Self::Ru),
                "RW" => Ok(Self::Rw),
                "SA" => Ok(Self::Sa),
                "SB" => Ok(Self::Sb),
                "SC" => Ok(Self::Sc),
                "SD" => Ok(Self::Sd),
                "SE" => Ok(Self::Se),
                "SG" => Ok(Self::Sg),
                "SH" => Ok(Self::Sh),
                "SI" => Ok(Self::Si),
                "SJ" => Ok(Self::Sj),
                "SK" => Ok(Self::Sk),
                "SL" => Ok(Self::Sl),
                "SM" => Ok(Self::Sm),
                "SN" => Ok(Self::Sn),
                "SO" => Ok(Self::So),
                "SR" => Ok(Self::Sr),
                "SS" => Ok(Self::Ss),
                "ST" => Ok(Self::St),
                "SV" => Ok(Self::Sv),
                "SX" => Ok(Self::Sx),
                "SY" => Ok(Self::Sy),
                "SZ" => Ok(Self::Sz),
                "TC" => Ok(Self::Tc),
                "TD" => Ok(Self::Td),
                "TG" => Ok(Self::Tg),
                "TH" => Ok(Self::Th),
                "TJ" => Ok(Self::Tj),
                "TK" => Ok(Self::Tk),
                "TL" => Ok(Self::Tl),
                "TM" => Ok(Self::Tm),
                "TN" => Ok(Self::Tn),
                "TO" => Ok(Self::To),
                "TR" => Ok(Self::Tr),
                "TT" => Ok(Self::Tt),
                "TV" => Ok(Self::Tv),
                "TW" => Ok(Self::Tw),
                "TZ" => Ok(Self::Tz),
                "UA" => Ok(Self::Ua),
                "UG" => Ok(Self::Ug),
                "US" => Ok(Self::Us),
                "UY" => Ok(Self::Uy),
                "UZ" => Ok(Self::Uz),
                "VA" => Ok(Self::Va),
                "VC" => Ok(Self::Vc),
                "VE" => Ok(Self::Ve),
                "VG" => Ok(Self::Vg),
                "VI" => Ok(Self::Vi),
                "VN" => Ok(Self::Vn),
                "VU" => Ok(Self::Vu),
                "WF" => Ok(Self::Wf),
                "WS" => Ok(Self::Ws),
                "XK" => Ok(Self::Xk),
                "YE" => Ok(Self::Ye),
                "YT" => Ok(Self::Yt),
                "ZA" => Ok(Self::Za),
                "ZM" => Ok(Self::Zm),
                "ZW" => Ok(Self::Zw),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///CreditNote
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Allocations": {
    ///      "description": "See Allocations",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Allocation"
    ///      }
    ///    },
    ///    "AppliedAmount": {
    ///      "description": "The amount of applied to an invoice",
    ///      "examples": [
    ///        2.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BrandingThemeID": {
    ///      "description": "See BrandingThemes",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CISDeduction": {
    ///      "description": "CIS deduction for UK contractors",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "CISRate": {
    ///      "description": "CIS Deduction rate for the organisation",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CreditNoteID": {
    ///      "description": "Xero generated unique identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CreditNoteNumber": {
    ///      "description": "ACCRECCREDIT – Unique alpha numeric code
    /// identifying credit note (when missing will auto-generate from your
    /// Organisation Invoice Settings)",
    ///      "type": "string"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency invoice. If
    /// no rate is specified, the XE.com day rate is used",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "The date the credit note is issued YYYY-MM-DD. If
    /// the Date element is not specified then it will default to the current
    /// date based on the timezone setting of the organisation",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DueDate": {
    ///      "description": "Date invoice is due – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "FullyPaidOnDate": {
    ///      "description": "Date when credit note was fully paid(UTC format)",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if a credit note has an
    /// attachment",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "HasErrors": {
    ///      "description": "A boolean to indicate if a credit note has an
    /// validation errors",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "InvoiceAddresses": {
    ///      "description": "An array of addresses used to auto calculate sales
    /// tax",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InvoiceAddress"
    ///      }
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See Invoice Line Items",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "Payments": {
    ///      "description": "See Payments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "Reference": {
    ///      "description": "ACCRECCREDIT only – additional reference number",
    ///      "type": "string"
    ///    },
    ///    "RemainingCredit": {
    ///      "description": "The remaining credit balance on the Credit Note",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "SentToContact": {
    ///      "description": "Boolean to set whether the credit note in the Xero
    /// app should be marked as “sent”. This can be set only on credit notes
    /// that have been approved",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "See Credit Note Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "SUBMITTED",
    ///        "DELETED",
    ///        "AUTHORISED",
    ///        "PAID",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "SubTotal": {
    ///      "description": "The subtotal of the credit note excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "The total of the Credit Note(subtotal + total
    /// tax)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "The total tax on the credit note",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Credit Note Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCPAYCREDIT",
    ///        "ACCRECCREDIT"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to the credit note",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreditNote {
        ///See Allocations
        #[serde(rename = "Allocations", default, skip_serializing_if = "Vec::is_empty")]
        pub allocations: Vec<Allocation>,
        #[serde(
            rename = "AppliedAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub applied_amount: Option<f64>,
        ///See BrandingThemes
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        #[serde(
            rename = "CISDeduction",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cis_deduction: Option<f64>,
        #[serde(rename = "CISRate", default, skip_serializing_if = "Option::is_none")]
        pub cis_rate: Option<f64>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        ///Xero generated unique identifier
        #[serde(
            rename = "CreditNoteID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note_id: Option<uuid::Uuid>,
        ///ACCRECCREDIT – Unique alpha numeric code identifying credit note
        /// (when missing will auto-generate from your Organisation Invoice
        /// Settings)
        #[serde(
            rename = "CreditNoteNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note_number: Option<String>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///The date the credit note is issued YYYY-MM-DD. If the Date element
        /// is not specified then it will default to the current date based on
        /// the timezone setting of the organisation
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Date invoice is due – YYYY-MM-DD
        #[serde(rename = "DueDate", default, skip_serializing_if = "Option::is_none")]
        pub due_date: Option<String>,
        ///Date when credit note was fully paid(UTC format)
        #[serde(
            rename = "FullyPaidOnDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub fully_paid_on_date: Option<String>,
        ///boolean to indicate if a credit note has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///A boolean to indicate if a credit note has an validation errors
        #[serde(rename = "HasErrors", default)]
        pub has_errors: bool,
        ///An array of addresses used to auto calculate sales tax
        #[serde(
            rename = "InvoiceAddresses",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub invoice_addresses: Vec<InvoiceAddress>,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See Invoice Line Items
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///See Payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///ACCRECCREDIT only – additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        #[serde(
            rename = "RemainingCredit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remaining_credit: Option<f64>,
        ///Boolean to set whether the credit note in the Xero app should be
        /// marked as “sent”. This can be set only on credit notes that have
        /// been approved
        #[serde(
            rename = "SentToContact",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sent_to_contact: Option<bool>,
        ///See Credit Note Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<CreditNoteStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Credit Note Types
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<CreditNoteType>,
        ///UTC timestamp of last update to the credit note
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&CreditNote> for CreditNote {
        fn from(value: &CreditNote) -> Self {
            value.clone()
        }
    }

    ///See Credit Note Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Credit Note Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SUBMITTED",
    ///    "DELETED",
    ///    "AUTHORISED",
    ///    "PAID",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreditNoteStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "DELETED")]
        Deleted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "PAID")]
        Paid,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&CreditNoteStatus> for CreditNoteStatus {
        fn from(value: &CreditNoteStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreditNoteStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Deleted => write!(f, "DELETED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Paid => write!(f, "PAID"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for CreditNoteStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SUBMITTED" => Ok(Self::Submitted),
                "DELETED" => Ok(Self::Deleted),
                "AUTHORISED" => Ok(Self::Authorised),
                "PAID" => Ok(Self::Paid),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CreditNoteStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CreditNoteStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CreditNoteStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Credit Note Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Credit Note Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCPAYCREDIT",
    ///    "ACCRECCREDIT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreditNoteType {
        #[serde(rename = "ACCPAYCREDIT")]
        Accpaycredit,
        #[serde(rename = "ACCRECCREDIT")]
        Accreccredit,
    }

    impl From<&CreditNoteType> for CreditNoteType {
        fn from(value: &CreditNoteType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreditNoteType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accpaycredit => write!(f, "ACCPAYCREDIT"),
                Self::Accreccredit => write!(f, "ACCRECCREDIT"),
            }
        }
    }

    impl std::str::FromStr for CreditNoteType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCPAYCREDIT" => Ok(Self::Accpaycredit),
                "ACCRECCREDIT" => Ok(Self::Accreccredit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CreditNoteType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CreditNoteType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CreditNoteType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///CreditNotes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "CreditNotes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CreditNote"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "credit_notes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreditNotes {
        #[serde(rename = "CreditNotes", default, skip_serializing_if = "Vec::is_empty")]
        pub credit_notes: Vec<CreditNote>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&CreditNotes> for CreditNotes {
        fn from(value: &CreditNotes) -> Self {
            value.clone()
        }
    }

    ///Currencies
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Currencies": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Currency"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "currencies"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Currencies {
        #[serde(rename = "Currencies", default, skip_serializing_if = "Vec::is_empty")]
        pub currencies: Vec<Currency>,
    }

    impl From<&Currencies> for Currencies {
        fn from(value: &Currencies) -> Self {
            value.clone()
        }
    }

    ///Currency
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Code": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "Description": {
    ///      "description": "Name of Currency",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Currency {
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<CurrencyCode>,
        ///Name of Currency
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
    }

    impl From<&Currency> for Currency {
        fn from(value: &Currency) -> Self {
            value.clone()
        }
    }

    ///3 letter alpha code for the currency – see list of currency codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "3 letter alpha code for the currency – see list of
    /// currency codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "AED",
    ///    "AFN",
    ///    "ALL",
    ///    "AMD",
    ///    "ANG",
    ///    "AOA",
    ///    "ARS",
    ///    "AUD",
    ///    "AWG",
    ///    "AZN",
    ///    "BAM",
    ///    "BBD",
    ///    "BDT",
    ///    "BGN",
    ///    "BHD",
    ///    "BIF",
    ///    "BMD",
    ///    "BND",
    ///    "BOB",
    ///    "BRL",
    ///    "BSD",
    ///    "BTN",
    ///    "BWP",
    ///    "BYN",
    ///    "BYR",
    ///    "BZD",
    ///    "CAD",
    ///    "CDF",
    ///    "CHF",
    ///    "CLF",
    ///    "CLP",
    ///    "CNY",
    ///    "COP",
    ///    "CRC",
    ///    "CUC",
    ///    "CUP",
    ///    "CVE",
    ///    "CZK",
    ///    "DJF",
    ///    "DKK",
    ///    "DOP",
    ///    "DZD",
    ///    "EEK",
    ///    "EGP",
    ///    "ERN",
    ///    "ETB",
    ///    "EUR",
    ///    "FJD",
    ///    "FKP",
    ///    "GBP",
    ///    "GEL",
    ///    "GHS",
    ///    "GIP",
    ///    "GMD",
    ///    "GNF",
    ///    "GTQ",
    ///    "GYD",
    ///    "HKD",
    ///    "HNL",
    ///    "HRK",
    ///    "HTG",
    ///    "HUF",
    ///    "IDR",
    ///    "ILS",
    ///    "INR",
    ///    "IQD",
    ///    "IRR",
    ///    "ISK",
    ///    "JMD",
    ///    "JOD",
    ///    "JPY",
    ///    "KES",
    ///    "KGS",
    ///    "KHR",
    ///    "KMF",
    ///    "KPW",
    ///    "KRW",
    ///    "KWD",
    ///    "KYD",
    ///    "KZT",
    ///    "LAK",
    ///    "LBP",
    ///    "LKR",
    ///    "LRD",
    ///    "LSL",
    ///    "LTL",
    ///    "LVL",
    ///    "LYD",
    ///    "MAD",
    ///    "MDL",
    ///    "MGA",
    ///    "MKD",
    ///    "MMK",
    ///    "MNT",
    ///    "MOP",
    ///    "MRO",
    ///    "MRU",
    ///    "MUR",
    ///    "MVR",
    ///    "MWK",
    ///    "MXN",
    ///    "MXV",
    ///    "MYR",
    ///    "MZN",
    ///    "NAD",
    ///    "NGN",
    ///    "NIO",
    ///    "NOK",
    ///    "NPR",
    ///    "NZD",
    ///    "OMR",
    ///    "PAB",
    ///    "PEN",
    ///    "PGK",
    ///    "PHP",
    ///    "PKR",
    ///    "PLN",
    ///    "PYG",
    ///    "QAR",
    ///    "RON",
    ///    "RSD",
    ///    "RUB",
    ///    "RWF",
    ///    "SAR",
    ///    "SBD",
    ///    "SCR",
    ///    "SDG",
    ///    "SEK",
    ///    "SGD",
    ///    "SHP",
    ///    "SKK",
    ///    "SLE",
    ///    "SLL",
    ///    "SOS",
    ///    "SRD",
    ///    "STD",
    ///    "STN",
    ///    "SVC",
    ///    "SYP",
    ///    "SZL",
    ///    "THB",
    ///    "TJS",
    ///    "TMT",
    ///    "TND",
    ///    "TOP",
    ///    "TRY",
    ///    "TTD",
    ///    "TWD",
    ///    "TZS",
    ///    "UAH",
    ///    "UGX",
    ///    "USD",
    ///    "UYU",
    ///    "UZS",
    ///    "VEF",
    ///    "VES",
    ///    "VND",
    ///    "VUV",
    ///    "WST",
    ///    "XAF",
    ///    "XCD",
    ///    "XOF",
    ///    "XPF",
    ///    "YER",
    ///    "ZAR",
    ///    "ZMW",
    ///    "ZMK",
    ///    "ZWD"
    ///  ],
    ///  "x-enum-varnames": [
    ///    "AED",
    ///    "AFN",
    ///    "ALL",
    ///    "AMD",
    ///    "ANG",
    ///    "AOA",
    ///    "ARS",
    ///    "AUD",
    ///    "AWG",
    ///    "AZN",
    ///    "BAM",
    ///    "BBD",
    ///    "BDT",
    ///    "BGN",
    ///    "BHD",
    ///    "BIF",
    ///    "BMD",
    ///    "BND",
    ///    "BOB",
    ///    "BRL",
    ///    "BSD",
    ///    "BTN",
    ///    "BWP",
    ///    "BYN",
    ///    "BYR",
    ///    "BZD",
    ///    "CAD",
    ///    "CDF",
    ///    "CHF",
    ///    "CLF",
    ///    "CLP",
    ///    "CNY",
    ///    "COP",
    ///    "CRC",
    ///    "CUC",
    ///    "CUP",
    ///    "CVE",
    ///    "CZK",
    ///    "DJF",
    ///    "DKK",
    ///    "DOP",
    ///    "DZD",
    ///    "EEK",
    ///    "EGP",
    ///    "ERN",
    ///    "ETB",
    ///    "EUR",
    ///    "FJD",
    ///    "FKP",
    ///    "GBP",
    ///    "GEL",
    ///    "GHS",
    ///    "GIP",
    ///    "GMD",
    ///    "GNF",
    ///    "GTQ",
    ///    "GYD",
    ///    "HKD",
    ///    "HNL",
    ///    "HRK",
    ///    "HTG",
    ///    "HUF",
    ///    "IDR",
    ///    "ILS",
    ///    "INR",
    ///    "IQD",
    ///    "IRR",
    ///    "ISK",
    ///    "JMD",
    ///    "JOD",
    ///    "JPY",
    ///    "KES",
    ///    "KGS",
    ///    "KHR",
    ///    "KMF",
    ///    "KPW",
    ///    "KRW",
    ///    "KWD",
    ///    "KYD",
    ///    "KZT",
    ///    "LAK",
    ///    "LBP",
    ///    "LKR",
    ///    "LRD",
    ///    "LSL",
    ///    "LTL",
    ///    "LVL",
    ///    "LYD",
    ///    "MAD",
    ///    "MDL",
    ///    "MGA",
    ///    "MKD",
    ///    "MMK",
    ///    "MNT",
    ///    "MOP",
    ///    "MRO",
    ///    "MRU",
    ///    "MUR",
    ///    "MVR",
    ///    "MWK",
    ///    "MXN",
    ///    "MXV",
    ///    "MYR",
    ///    "MZN",
    ///    "NAD",
    ///    "NGN",
    ///    "NIO",
    ///    "NOK",
    ///    "NPR",
    ///    "NZD",
    ///    "OMR",
    ///    "PAB",
    ///    "PEN",
    ///    "PGK",
    ///    "PHP",
    ///    "PKR",
    ///    "PLN",
    ///    "PYG",
    ///    "QAR",
    ///    "RON",
    ///    "RSD",
    ///    "RUB",
    ///    "RWF",
    ///    "SAR",
    ///    "SBD",
    ///    "SCR",
    ///    "SDG",
    ///    "SEK",
    ///    "SGD",
    ///    "SHP",
    ///    "SKK",
    ///    "SLE",
    ///    "SLL",
    ///    "SOS",
    ///    "SRD",
    ///    "STN",
    ///    "STD",
    ///    "SVC",
    ///    "SYP",
    ///    "SZL",
    ///    "THB",
    ///    "TJS",
    ///    "TMT",
    ///    "TND",
    ///    "TOP",
    ///    "TRY_LIRA",
    ///    "TTD",
    ///    "TWD",
    ///    "TZS",
    ///    "UAH",
    ///    "UGX",
    ///    "USD",
    ///    "UYU",
    ///    "UZS",
    ///    "VEF",
    ///    "VES",
    ///    "VND",
    ///    "VUV",
    ///    "WST",
    ///    "XAF",
    ///    "XCD",
    ///    "XOF",
    ///    "XPF",
    ///    "YER",
    ///    "ZAR",
    ///    "ZMW",
    ///    "ZMK",
    ///    "ZWD",
    ///    "EMPTY_CURRENCY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CurrencyCode {
        #[serde(rename = "AED")]
        Aed,
        #[serde(rename = "AFN")]
        Afn,
        #[serde(rename = "ALL")]
        All,
        #[serde(rename = "AMD")]
        Amd,
        #[serde(rename = "ANG")]
        Ang,
        #[serde(rename = "AOA")]
        Aoa,
        #[serde(rename = "ARS")]
        Ars,
        #[serde(rename = "AUD")]
        Aud,
        #[serde(rename = "AWG")]
        Awg,
        #[serde(rename = "AZN")]
        Azn,
        #[serde(rename = "BAM")]
        Bam,
        #[serde(rename = "BBD")]
        Bbd,
        #[serde(rename = "BDT")]
        Bdt,
        #[serde(rename = "BGN")]
        Bgn,
        #[serde(rename = "BHD")]
        Bhd,
        #[serde(rename = "BIF")]
        Bif,
        #[serde(rename = "BMD")]
        Bmd,
        #[serde(rename = "BND")]
        Bnd,
        #[serde(rename = "BOB")]
        Bob,
        #[serde(rename = "BRL")]
        Brl,
        #[serde(rename = "BSD")]
        Bsd,
        #[serde(rename = "BTN")]
        Btn,
        #[serde(rename = "BWP")]
        Bwp,
        #[serde(rename = "BYN")]
        Byn,
        #[serde(rename = "BYR")]
        Byr,
        #[serde(rename = "BZD")]
        Bzd,
        #[serde(rename = "CAD")]
        Cad,
        #[serde(rename = "CDF")]
        Cdf,
        #[serde(rename = "CHF")]
        Chf,
        #[serde(rename = "CLF")]
        Clf,
        #[serde(rename = "CLP")]
        Clp,
        #[serde(rename = "CNY")]
        Cny,
        #[serde(rename = "COP")]
        Cop,
        #[serde(rename = "CRC")]
        Crc,
        #[serde(rename = "CUC")]
        Cuc,
        #[serde(rename = "CUP")]
        Cup,
        #[serde(rename = "CVE")]
        Cve,
        #[serde(rename = "CZK")]
        Czk,
        #[serde(rename = "DJF")]
        Djf,
        #[serde(rename = "DKK")]
        Dkk,
        #[serde(rename = "DOP")]
        Dop,
        #[serde(rename = "DZD")]
        Dzd,
        #[serde(rename = "EEK")]
        Eek,
        #[serde(rename = "EGP")]
        Egp,
        #[serde(rename = "ERN")]
        Ern,
        #[serde(rename = "ETB")]
        Etb,
        #[serde(rename = "EUR")]
        Eur,
        #[serde(rename = "FJD")]
        Fjd,
        #[serde(rename = "FKP")]
        Fkp,
        #[serde(rename = "GBP")]
        Gbp,
        #[serde(rename = "GEL")]
        Gel,
        #[serde(rename = "GHS")]
        Ghs,
        #[serde(rename = "GIP")]
        Gip,
        #[serde(rename = "GMD")]
        Gmd,
        #[serde(rename = "GNF")]
        Gnf,
        #[serde(rename = "GTQ")]
        Gtq,
        #[serde(rename = "GYD")]
        Gyd,
        #[serde(rename = "HKD")]
        Hkd,
        #[serde(rename = "HNL")]
        Hnl,
        #[serde(rename = "HRK")]
        Hrk,
        #[serde(rename = "HTG")]
        Htg,
        #[serde(rename = "HUF")]
        Huf,
        #[serde(rename = "IDR")]
        Idr,
        #[serde(rename = "ILS")]
        Ils,
        #[serde(rename = "INR")]
        Inr,
        #[serde(rename = "IQD")]
        Iqd,
        #[serde(rename = "IRR")]
        Irr,
        #[serde(rename = "ISK")]
        Isk,
        #[serde(rename = "JMD")]
        Jmd,
        #[serde(rename = "JOD")]
        Jod,
        #[serde(rename = "JPY")]
        Jpy,
        #[serde(rename = "KES")]
        Kes,
        #[serde(rename = "KGS")]
        Kgs,
        #[serde(rename = "KHR")]
        Khr,
        #[serde(rename = "KMF")]
        Kmf,
        #[serde(rename = "KPW")]
        Kpw,
        #[serde(rename = "KRW")]
        Krw,
        #[serde(rename = "KWD")]
        Kwd,
        #[serde(rename = "KYD")]
        Kyd,
        #[serde(rename = "KZT")]
        Kzt,
        #[serde(rename = "LAK")]
        Lak,
        #[serde(rename = "LBP")]
        Lbp,
        #[serde(rename = "LKR")]
        Lkr,
        #[serde(rename = "LRD")]
        Lrd,
        #[serde(rename = "LSL")]
        Lsl,
        #[serde(rename = "LTL")]
        Ltl,
        #[serde(rename = "LVL")]
        Lvl,
        #[serde(rename = "LYD")]
        Lyd,
        #[serde(rename = "MAD")]
        Mad,
        #[serde(rename = "MDL")]
        Mdl,
        #[serde(rename = "MGA")]
        Mga,
        #[serde(rename = "MKD")]
        Mkd,
        #[serde(rename = "MMK")]
        Mmk,
        #[serde(rename = "MNT")]
        Mnt,
        #[serde(rename = "MOP")]
        Mop,
        #[serde(rename = "MRO")]
        Mro,
        #[serde(rename = "MRU")]
        Mru,
        #[serde(rename = "MUR")]
        Mur,
        #[serde(rename = "MVR")]
        Mvr,
        #[serde(rename = "MWK")]
        Mwk,
        #[serde(rename = "MXN")]
        Mxn,
        #[serde(rename = "MXV")]
        Mxv,
        #[serde(rename = "MYR")]
        Myr,
        #[serde(rename = "MZN")]
        Mzn,
        #[serde(rename = "NAD")]
        Nad,
        #[serde(rename = "NGN")]
        Ngn,
        #[serde(rename = "NIO")]
        Nio,
        #[serde(rename = "NOK")]
        Nok,
        #[serde(rename = "NPR")]
        Npr,
        #[serde(rename = "NZD")]
        Nzd,
        #[serde(rename = "OMR")]
        Omr,
        #[serde(rename = "PAB")]
        Pab,
        #[serde(rename = "PEN")]
        Pen,
        #[serde(rename = "PGK")]
        Pgk,
        #[serde(rename = "PHP")]
        Php,
        #[serde(rename = "PKR")]
        Pkr,
        #[serde(rename = "PLN")]
        Pln,
        #[serde(rename = "PYG")]
        Pyg,
        #[serde(rename = "QAR")]
        Qar,
        #[serde(rename = "RON")]
        Ron,
        #[serde(rename = "RSD")]
        Rsd,
        #[serde(rename = "RUB")]
        Rub,
        #[serde(rename = "RWF")]
        Rwf,
        #[serde(rename = "SAR")]
        Sar,
        #[serde(rename = "SBD")]
        Sbd,
        #[serde(rename = "SCR")]
        Scr,
        #[serde(rename = "SDG")]
        Sdg,
        #[serde(rename = "SEK")]
        Sek,
        #[serde(rename = "SGD")]
        Sgd,
        #[serde(rename = "SHP")]
        Shp,
        #[serde(rename = "SKK")]
        Skk,
        #[serde(rename = "SLE")]
        Sle,
        #[serde(rename = "SLL")]
        Sll,
        #[serde(rename = "SOS")]
        Sos,
        #[serde(rename = "SRD")]
        Srd,
        #[serde(rename = "STD")]
        Std,
        #[serde(rename = "STN")]
        Stn,
        #[serde(rename = "SVC")]
        Svc,
        #[serde(rename = "SYP")]
        Syp,
        #[serde(rename = "SZL")]
        Szl,
        #[serde(rename = "THB")]
        Thb,
        #[serde(rename = "TJS")]
        Tjs,
        #[serde(rename = "TMT")]
        Tmt,
        #[serde(rename = "TND")]
        Tnd,
        #[serde(rename = "TOP")]
        Top,
        #[serde(rename = "TRY")]
        Try,
        #[serde(rename = "TTD")]
        Ttd,
        #[serde(rename = "TWD")]
        Twd,
        #[serde(rename = "TZS")]
        Tzs,
        #[serde(rename = "UAH")]
        Uah,
        #[serde(rename = "UGX")]
        Ugx,
        #[serde(rename = "USD")]
        Usd,
        #[serde(rename = "UYU")]
        Uyu,
        #[serde(rename = "UZS")]
        Uzs,
        #[serde(rename = "VEF")]
        Vef,
        #[serde(rename = "VES")]
        Ves,
        #[serde(rename = "VND")]
        Vnd,
        #[serde(rename = "VUV")]
        Vuv,
        #[serde(rename = "WST")]
        Wst,
        #[serde(rename = "XAF")]
        Xaf,
        #[serde(rename = "XCD")]
        Xcd,
        #[serde(rename = "XOF")]
        Xof,
        #[serde(rename = "XPF")]
        Xpf,
        #[serde(rename = "YER")]
        Yer,
        #[serde(rename = "ZAR")]
        Zar,
        #[serde(rename = "ZMW")]
        Zmw,
        #[serde(rename = "ZMK")]
        Zmk,
        #[serde(rename = "ZWD")]
        Zwd,
    }

    impl From<&CurrencyCode> for CurrencyCode {
        fn from(value: &CurrencyCode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CurrencyCode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Aed => write!(f, "AED"),
                Self::Afn => write!(f, "AFN"),
                Self::All => write!(f, "ALL"),
                Self::Amd => write!(f, "AMD"),
                Self::Ang => write!(f, "ANG"),
                Self::Aoa => write!(f, "AOA"),
                Self::Ars => write!(f, "ARS"),
                Self::Aud => write!(f, "AUD"),
                Self::Awg => write!(f, "AWG"),
                Self::Azn => write!(f, "AZN"),
                Self::Bam => write!(f, "BAM"),
                Self::Bbd => write!(f, "BBD"),
                Self::Bdt => write!(f, "BDT"),
                Self::Bgn => write!(f, "BGN"),
                Self::Bhd => write!(f, "BHD"),
                Self::Bif => write!(f, "BIF"),
                Self::Bmd => write!(f, "BMD"),
                Self::Bnd => write!(f, "BND"),
                Self::Bob => write!(f, "BOB"),
                Self::Brl => write!(f, "BRL"),
                Self::Bsd => write!(f, "BSD"),
                Self::Btn => write!(f, "BTN"),
                Self::Bwp => write!(f, "BWP"),
                Self::Byn => write!(f, "BYN"),
                Self::Byr => write!(f, "BYR"),
                Self::Bzd => write!(f, "BZD"),
                Self::Cad => write!(f, "CAD"),
                Self::Cdf => write!(f, "CDF"),
                Self::Chf => write!(f, "CHF"),
                Self::Clf => write!(f, "CLF"),
                Self::Clp => write!(f, "CLP"),
                Self::Cny => write!(f, "CNY"),
                Self::Cop => write!(f, "COP"),
                Self::Crc => write!(f, "CRC"),
                Self::Cuc => write!(f, "CUC"),
                Self::Cup => write!(f, "CUP"),
                Self::Cve => write!(f, "CVE"),
                Self::Czk => write!(f, "CZK"),
                Self::Djf => write!(f, "DJF"),
                Self::Dkk => write!(f, "DKK"),
                Self::Dop => write!(f, "DOP"),
                Self::Dzd => write!(f, "DZD"),
                Self::Eek => write!(f, "EEK"),
                Self::Egp => write!(f, "EGP"),
                Self::Ern => write!(f, "ERN"),
                Self::Etb => write!(f, "ETB"),
                Self::Eur => write!(f, "EUR"),
                Self::Fjd => write!(f, "FJD"),
                Self::Fkp => write!(f, "FKP"),
                Self::Gbp => write!(f, "GBP"),
                Self::Gel => write!(f, "GEL"),
                Self::Ghs => write!(f, "GHS"),
                Self::Gip => write!(f, "GIP"),
                Self::Gmd => write!(f, "GMD"),
                Self::Gnf => write!(f, "GNF"),
                Self::Gtq => write!(f, "GTQ"),
                Self::Gyd => write!(f, "GYD"),
                Self::Hkd => write!(f, "HKD"),
                Self::Hnl => write!(f, "HNL"),
                Self::Hrk => write!(f, "HRK"),
                Self::Htg => write!(f, "HTG"),
                Self::Huf => write!(f, "HUF"),
                Self::Idr => write!(f, "IDR"),
                Self::Ils => write!(f, "ILS"),
                Self::Inr => write!(f, "INR"),
                Self::Iqd => write!(f, "IQD"),
                Self::Irr => write!(f, "IRR"),
                Self::Isk => write!(f, "ISK"),
                Self::Jmd => write!(f, "JMD"),
                Self::Jod => write!(f, "JOD"),
                Self::Jpy => write!(f, "JPY"),
                Self::Kes => write!(f, "KES"),
                Self::Kgs => write!(f, "KGS"),
                Self::Khr => write!(f, "KHR"),
                Self::Kmf => write!(f, "KMF"),
                Self::Kpw => write!(f, "KPW"),
                Self::Krw => write!(f, "KRW"),
                Self::Kwd => write!(f, "KWD"),
                Self::Kyd => write!(f, "KYD"),
                Self::Kzt => write!(f, "KZT"),
                Self::Lak => write!(f, "LAK"),
                Self::Lbp => write!(f, "LBP"),
                Self::Lkr => write!(f, "LKR"),
                Self::Lrd => write!(f, "LRD"),
                Self::Lsl => write!(f, "LSL"),
                Self::Ltl => write!(f, "LTL"),
                Self::Lvl => write!(f, "LVL"),
                Self::Lyd => write!(f, "LYD"),
                Self::Mad => write!(f, "MAD"),
                Self::Mdl => write!(f, "MDL"),
                Self::Mga => write!(f, "MGA"),
                Self::Mkd => write!(f, "MKD"),
                Self::Mmk => write!(f, "MMK"),
                Self::Mnt => write!(f, "MNT"),
                Self::Mop => write!(f, "MOP"),
                Self::Mro => write!(f, "MRO"),
                Self::Mru => write!(f, "MRU"),
                Self::Mur => write!(f, "MUR"),
                Self::Mvr => write!(f, "MVR"),
                Self::Mwk => write!(f, "MWK"),
                Self::Mxn => write!(f, "MXN"),
                Self::Mxv => write!(f, "MXV"),
                Self::Myr => write!(f, "MYR"),
                Self::Mzn => write!(f, "MZN"),
                Self::Nad => write!(f, "NAD"),
                Self::Ngn => write!(f, "NGN"),
                Self::Nio => write!(f, "NIO"),
                Self::Nok => write!(f, "NOK"),
                Self::Npr => write!(f, "NPR"),
                Self::Nzd => write!(f, "NZD"),
                Self::Omr => write!(f, "OMR"),
                Self::Pab => write!(f, "PAB"),
                Self::Pen => write!(f, "PEN"),
                Self::Pgk => write!(f, "PGK"),
                Self::Php => write!(f, "PHP"),
                Self::Pkr => write!(f, "PKR"),
                Self::Pln => write!(f, "PLN"),
                Self::Pyg => write!(f, "PYG"),
                Self::Qar => write!(f, "QAR"),
                Self::Ron => write!(f, "RON"),
                Self::Rsd => write!(f, "RSD"),
                Self::Rub => write!(f, "RUB"),
                Self::Rwf => write!(f, "RWF"),
                Self::Sar => write!(f, "SAR"),
                Self::Sbd => write!(f, "SBD"),
                Self::Scr => write!(f, "SCR"),
                Self::Sdg => write!(f, "SDG"),
                Self::Sek => write!(f, "SEK"),
                Self::Sgd => write!(f, "SGD"),
                Self::Shp => write!(f, "SHP"),
                Self::Skk => write!(f, "SKK"),
                Self::Sle => write!(f, "SLE"),
                Self::Sll => write!(f, "SLL"),
                Self::Sos => write!(f, "SOS"),
                Self::Srd => write!(f, "SRD"),
                Self::Std => write!(f, "STD"),
                Self::Stn => write!(f, "STN"),
                Self::Svc => write!(f, "SVC"),
                Self::Syp => write!(f, "SYP"),
                Self::Szl => write!(f, "SZL"),
                Self::Thb => write!(f, "THB"),
                Self::Tjs => write!(f, "TJS"),
                Self::Tmt => write!(f, "TMT"),
                Self::Tnd => write!(f, "TND"),
                Self::Top => write!(f, "TOP"),
                Self::Try => write!(f, "TRY"),
                Self::Ttd => write!(f, "TTD"),
                Self::Twd => write!(f, "TWD"),
                Self::Tzs => write!(f, "TZS"),
                Self::Uah => write!(f, "UAH"),
                Self::Ugx => write!(f, "UGX"),
                Self::Usd => write!(f, "USD"),
                Self::Uyu => write!(f, "UYU"),
                Self::Uzs => write!(f, "UZS"),
                Self::Vef => write!(f, "VEF"),
                Self::Ves => write!(f, "VES"),
                Self::Vnd => write!(f, "VND"),
                Self::Vuv => write!(f, "VUV"),
                Self::Wst => write!(f, "WST"),
                Self::Xaf => write!(f, "XAF"),
                Self::Xcd => write!(f, "XCD"),
                Self::Xof => write!(f, "XOF"),
                Self::Xpf => write!(f, "XPF"),
                Self::Yer => write!(f, "YER"),
                Self::Zar => write!(f, "ZAR"),
                Self::Zmw => write!(f, "ZMW"),
                Self::Zmk => write!(f, "ZMK"),
                Self::Zwd => write!(f, "ZWD"),
            }
        }
    }

    impl std::str::FromStr for CurrencyCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AED" => Ok(Self::Aed),
                "AFN" => Ok(Self::Afn),
                "ALL" => Ok(Self::All),
                "AMD" => Ok(Self::Amd),
                "ANG" => Ok(Self::Ang),
                "AOA" => Ok(Self::Aoa),
                "ARS" => Ok(Self::Ars),
                "AUD" => Ok(Self::Aud),
                "AWG" => Ok(Self::Awg),
                "AZN" => Ok(Self::Azn),
                "BAM" => Ok(Self::Bam),
                "BBD" => Ok(Self::Bbd),
                "BDT" => Ok(Self::Bdt),
                "BGN" => Ok(Self::Bgn),
                "BHD" => Ok(Self::Bhd),
                "BIF" => Ok(Self::Bif),
                "BMD" => Ok(Self::Bmd),
                "BND" => Ok(Self::Bnd),
                "BOB" => Ok(Self::Bob),
                "BRL" => Ok(Self::Brl),
                "BSD" => Ok(Self::Bsd),
                "BTN" => Ok(Self::Btn),
                "BWP" => Ok(Self::Bwp),
                "BYN" => Ok(Self::Byn),
                "BYR" => Ok(Self::Byr),
                "BZD" => Ok(Self::Bzd),
                "CAD" => Ok(Self::Cad),
                "CDF" => Ok(Self::Cdf),
                "CHF" => Ok(Self::Chf),
                "CLF" => Ok(Self::Clf),
                "CLP" => Ok(Self::Clp),
                "CNY" => Ok(Self::Cny),
                "COP" => Ok(Self::Cop),
                "CRC" => Ok(Self::Crc),
                "CUC" => Ok(Self::Cuc),
                "CUP" => Ok(Self::Cup),
                "CVE" => Ok(Self::Cve),
                "CZK" => Ok(Self::Czk),
                "DJF" => Ok(Self::Djf),
                "DKK" => Ok(Self::Dkk),
                "DOP" => Ok(Self::Dop),
                "DZD" => Ok(Self::Dzd),
                "EEK" => Ok(Self::Eek),
                "EGP" => Ok(Self::Egp),
                "ERN" => Ok(Self::Ern),
                "ETB" => Ok(Self::Etb),
                "EUR" => Ok(Self::Eur),
                "FJD" => Ok(Self::Fjd),
                "FKP" => Ok(Self::Fkp),
                "GBP" => Ok(Self::Gbp),
                "GEL" => Ok(Self::Gel),
                "GHS" => Ok(Self::Ghs),
                "GIP" => Ok(Self::Gip),
                "GMD" => Ok(Self::Gmd),
                "GNF" => Ok(Self::Gnf),
                "GTQ" => Ok(Self::Gtq),
                "GYD" => Ok(Self::Gyd),
                "HKD" => Ok(Self::Hkd),
                "HNL" => Ok(Self::Hnl),
                "HRK" => Ok(Self::Hrk),
                "HTG" => Ok(Self::Htg),
                "HUF" => Ok(Self::Huf),
                "IDR" => Ok(Self::Idr),
                "ILS" => Ok(Self::Ils),
                "INR" => Ok(Self::Inr),
                "IQD" => Ok(Self::Iqd),
                "IRR" => Ok(Self::Irr),
                "ISK" => Ok(Self::Isk),
                "JMD" => Ok(Self::Jmd),
                "JOD" => Ok(Self::Jod),
                "JPY" => Ok(Self::Jpy),
                "KES" => Ok(Self::Kes),
                "KGS" => Ok(Self::Kgs),
                "KHR" => Ok(Self::Khr),
                "KMF" => Ok(Self::Kmf),
                "KPW" => Ok(Self::Kpw),
                "KRW" => Ok(Self::Krw),
                "KWD" => Ok(Self::Kwd),
                "KYD" => Ok(Self::Kyd),
                "KZT" => Ok(Self::Kzt),
                "LAK" => Ok(Self::Lak),
                "LBP" => Ok(Self::Lbp),
                "LKR" => Ok(Self::Lkr),
                "LRD" => Ok(Self::Lrd),
                "LSL" => Ok(Self::Lsl),
                "LTL" => Ok(Self::Ltl),
                "LVL" => Ok(Self::Lvl),
                "LYD" => Ok(Self::Lyd),
                "MAD" => Ok(Self::Mad),
                "MDL" => Ok(Self::Mdl),
                "MGA" => Ok(Self::Mga),
                "MKD" => Ok(Self::Mkd),
                "MMK" => Ok(Self::Mmk),
                "MNT" => Ok(Self::Mnt),
                "MOP" => Ok(Self::Mop),
                "MRO" => Ok(Self::Mro),
                "MRU" => Ok(Self::Mru),
                "MUR" => Ok(Self::Mur),
                "MVR" => Ok(Self::Mvr),
                "MWK" => Ok(Self::Mwk),
                "MXN" => Ok(Self::Mxn),
                "MXV" => Ok(Self::Mxv),
                "MYR" => Ok(Self::Myr),
                "MZN" => Ok(Self::Mzn),
                "NAD" => Ok(Self::Nad),
                "NGN" => Ok(Self::Ngn),
                "NIO" => Ok(Self::Nio),
                "NOK" => Ok(Self::Nok),
                "NPR" => Ok(Self::Npr),
                "NZD" => Ok(Self::Nzd),
                "OMR" => Ok(Self::Omr),
                "PAB" => Ok(Self::Pab),
                "PEN" => Ok(Self::Pen),
                "PGK" => Ok(Self::Pgk),
                "PHP" => Ok(Self::Php),
                "PKR" => Ok(Self::Pkr),
                "PLN" => Ok(Self::Pln),
                "PYG" => Ok(Self::Pyg),
                "QAR" => Ok(Self::Qar),
                "RON" => Ok(Self::Ron),
                "RSD" => Ok(Self::Rsd),
                "RUB" => Ok(Self::Rub),
                "RWF" => Ok(Self::Rwf),
                "SAR" => Ok(Self::Sar),
                "SBD" => Ok(Self::Sbd),
                "SCR" => Ok(Self::Scr),
                "SDG" => Ok(Self::Sdg),
                "SEK" => Ok(Self::Sek),
                "SGD" => Ok(Self::Sgd),
                "SHP" => Ok(Self::Shp),
                "SKK" => Ok(Self::Skk),
                "SLE" => Ok(Self::Sle),
                "SLL" => Ok(Self::Sll),
                "SOS" => Ok(Self::Sos),
                "SRD" => Ok(Self::Srd),
                "STD" => Ok(Self::Std),
                "STN" => Ok(Self::Stn),
                "SVC" => Ok(Self::Svc),
                "SYP" => Ok(Self::Syp),
                "SZL" => Ok(Self::Szl),
                "THB" => Ok(Self::Thb),
                "TJS" => Ok(Self::Tjs),
                "TMT" => Ok(Self::Tmt),
                "TND" => Ok(Self::Tnd),
                "TOP" => Ok(Self::Top),
                "TRY" => Ok(Self::Try),
                "TTD" => Ok(Self::Ttd),
                "TWD" => Ok(Self::Twd),
                "TZS" => Ok(Self::Tzs),
                "UAH" => Ok(Self::Uah),
                "UGX" => Ok(Self::Ugx),
                "USD" => Ok(Self::Usd),
                "UYU" => Ok(Self::Uyu),
                "UZS" => Ok(Self::Uzs),
                "VEF" => Ok(Self::Vef),
                "VES" => Ok(Self::Ves),
                "VND" => Ok(Self::Vnd),
                "VUV" => Ok(Self::Vuv),
                "WST" => Ok(Self::Wst),
                "XAF" => Ok(Self::Xaf),
                "XCD" => Ok(Self::Xcd),
                "XOF" => Ok(Self::Xof),
                "XPF" => Ok(Self::Xpf),
                "YER" => Ok(Self::Yer),
                "ZAR" => Ok(Self::Zar),
                "ZMW" => Ok(Self::Zmw),
                "ZMK" => Ok(Self::Zmk),
                "ZWD" => Ok(Self::Zwd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CurrencyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CurrencyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CurrencyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Element
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BankTransactionID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "BatchPaymentID": {
    ///      "description": "Unique ID for batch payment object with validation
    /// error",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ContactID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CreditNoteID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "InvoiceID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ItemID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PurchaseOrderID": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Array of Validation Error message",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Element {
        #[serde(
            rename = "BankTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_transaction_id: Option<uuid::Uuid>,
        ///Unique ID for batch payment object with validation error
        #[serde(
            rename = "BatchPaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub batch_payment_id: Option<uuid::Uuid>,
        #[serde(rename = "ContactID", default, skip_serializing_if = "Option::is_none")]
        pub contact_id: Option<uuid::Uuid>,
        #[serde(
            rename = "CreditNoteID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note_id: Option<uuid::Uuid>,
        #[serde(rename = "InvoiceID", default, skip_serializing_if = "Option::is_none")]
        pub invoice_id: Option<uuid::Uuid>,
        #[serde(rename = "ItemID", default, skip_serializing_if = "Option::is_none")]
        pub item_id: Option<uuid::Uuid>,
        #[serde(
            rename = "PurchaseOrderID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchase_order_id: Option<uuid::Uuid>,
        ///Array of Validation Error message
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Element> for Element {
        fn from(value: &Element) -> Self {
            value.clone()
        }
    }

    ///Employee
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "EmployeeID": {
    ///      "description": "The Xero identifier for an employee e.g.
    /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ExternalLink": {
    ///      "$ref": "#/components/schemas/ExternalLink"
    ///    },
    ///    "FirstName": {
    ///      "description": "First name of an employee (max length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "LastName": {
    ///      "description": "Last name of an employee (max length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Status": {
    ///      "description": "Current status of an employee – see contact status
    /// types",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "ARCHIVED",
    ///        "GDPRREQUEST",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "examples": [
    ///        "ERROR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Employee {
        ///The Xero identifier for an employee e.g.
        /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(
            rename = "EmployeeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub employee_id: Option<uuid::Uuid>,
        #[serde(
            rename = "ExternalLink",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub external_link: Option<ExternalLink>,
        ///First name of an employee (max length = 255)
        #[serde(rename = "FirstName", default, skip_serializing_if = "Option::is_none")]
        pub first_name: Option<EmployeeFirstName>,
        ///Last name of an employee (max length = 255)
        #[serde(rename = "LastName", default, skip_serializing_if = "Option::is_none")]
        pub last_name: Option<EmployeeLastName>,
        ///Current status of an employee – see contact status types
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<EmployeeStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Employee> for Employee {
        fn from(value: &Employee) -> Self {
            value.clone()
        }
    }

    ///First name of an employee (max length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "First name of an employee (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct EmployeeFirstName(String);
    impl ::std::ops::Deref for EmployeeFirstName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<EmployeeFirstName> for String {
        fn from(value: EmployeeFirstName) -> Self {
            value.0
        }
    }

    impl From<&EmployeeFirstName> for EmployeeFirstName {
        fn from(value: &EmployeeFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EmployeeFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EmployeeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for EmployeeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for EmployeeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EmployeeFirstName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Last name of an employee (max length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Last name of an employee (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct EmployeeLastName(String);
    impl ::std::ops::Deref for EmployeeLastName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<EmployeeLastName> for String {
        fn from(value: EmployeeLastName) -> Self {
            value.0
        }
    }

    impl From<&EmployeeLastName> for EmployeeLastName {
        fn from(value: &EmployeeLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EmployeeLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EmployeeLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for EmployeeLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for EmployeeLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EmployeeLastName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Current status of an employee – see contact status types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Current status of an employee – see contact status
    /// types",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "ARCHIVED",
    ///    "GDPRREQUEST",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EmployeeStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "GDPRREQUEST")]
        Gdprrequest,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&EmployeeStatus> for EmployeeStatus {
        fn from(value: &EmployeeStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EmployeeStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Gdprrequest => write!(f, "GDPRREQUEST"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for EmployeeStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "ARCHIVED" => Ok(Self::Archived),
                "GDPRREQUEST" => Ok(Self::Gdprrequest),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for EmployeeStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for EmployeeStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for EmployeeStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Employees
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Employees": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Employee"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "employees"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Employees {
        #[serde(rename = "Employees", default, skip_serializing_if = "Vec::is_empty")]
        pub employees: Vec<Employee>,
    }

    impl From<&Employees> for Employees {
        fn from(value: &Employees) -> Self {
            value.clone()
        }
    }

    ///Error
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Elements": {
    ///      "description": "Array of Elements of validation Errors",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Element"
    ///      }
    ///    },
    ///    "ErrorNumber": {
    ///      "description": "Exception number",
    ///      "type": "integer"
    ///    },
    ///    "Message": {
    ///      "description": "Exception message",
    ///      "type": "string"
    ///    },
    ///    "Type": {
    ///      "description": "Exception type",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Error {
        ///Array of Elements of validation Errors
        #[serde(rename = "Elements", default, skip_serializing_if = "Vec::is_empty")]
        pub elements: Vec<Element>,
        ///Exception number
        #[serde(
            rename = "ErrorNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub error_number: Option<i64>,
        ///Exception message
        #[serde(rename = "Message", default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        ///Exception type
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<String>,
    }

    impl From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    ///ExpenseClaim
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AmountDue": {
    ///      "description": "The amount due to be paid for an expense claim",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "AmountPaid": {
    ///      "description": "The amount still to pay for an expense claim",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "ExpenseClaimID": {
    ///      "description": "Xero generated unique identifier for an expense
    /// claim",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PaymentDueDate": {
    ///      "description": "The date when the expense claim is due to be paid
    /// YYYY-MM-DD",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Payments": {
    ///      "description": "See Payments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "ReceiptID": {
    ///      "description": "The Xero identifier for the Receipt e.g.
    /// e59a2c7f-1306-4078-a0f3-73537afcbba9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Receipts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Receipt"
    ///      }
    ///    },
    ///    "ReportingDate": {
    ///      "description": "The date the expense claim will be reported in Xero
    /// YYYY-MM-DD",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Status": {
    ///      "description": "Current status of an expense claim – see status
    /// types",
    ///      "type": "string",
    ///      "enum": [
    ///        "SUBMITTED",
    ///        "AUTHORISED",
    ///        "PAID",
    ///        "VOIDED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "Total": {
    ///      "description": "The total of an expense claim being paid",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "User": {
    ///      "$ref": "#/components/schemas/User"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExpenseClaim {
        #[serde(rename = "AmountDue", default, skip_serializing_if = "Option::is_none")]
        pub amount_due: Option<f64>,
        #[serde(
            rename = "AmountPaid",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub amount_paid: Option<f64>,
        ///Xero generated unique identifier for an expense claim
        #[serde(
            rename = "ExpenseClaimID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expense_claim_id: Option<uuid::Uuid>,
        ///The date when the expense claim is due to be paid YYYY-MM-DD
        #[serde(
            rename = "PaymentDueDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_due_date: Option<String>,
        ///See Payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///The Xero identifier for the Receipt e.g.
        /// e59a2c7f-1306-4078-a0f3-73537afcbba9
        #[serde(rename = "ReceiptID", default, skip_serializing_if = "Option::is_none")]
        pub receipt_id: Option<uuid::Uuid>,
        #[serde(rename = "Receipts", default, skip_serializing_if = "Vec::is_empty")]
        pub receipts: Vec<Receipt>,
        ///The date the expense claim will be reported in Xero YYYY-MM-DD
        #[serde(
            rename = "ReportingDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_date: Option<String>,
        ///Current status of an expense claim – see status types
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ExpenseClaimStatus>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        #[serde(rename = "User", default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    impl From<&ExpenseClaim> for ExpenseClaim {
        fn from(value: &ExpenseClaim) -> Self {
            value.clone()
        }
    }

    ///Current status of an expense claim – see status types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Current status of an expense claim – see status types",
    ///  "type": "string",
    ///  "enum": [
    ///    "SUBMITTED",
    ///    "AUTHORISED",
    ///    "PAID",
    ///    "VOIDED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExpenseClaimStatus {
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "PAID")]
        Paid,
        #[serde(rename = "VOIDED")]
        Voided,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&ExpenseClaimStatus> for ExpenseClaimStatus {
        fn from(value: &ExpenseClaimStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ExpenseClaimStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Paid => write!(f, "PAID"),
                Self::Voided => write!(f, "VOIDED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for ExpenseClaimStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SUBMITTED" => Ok(Self::Submitted),
                "AUTHORISED" => Ok(Self::Authorised),
                "PAID" => Ok(Self::Paid),
                "VOIDED" => Ok(Self::Voided),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExpenseClaimStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExpenseClaimStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExpenseClaimStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///ExpenseClaims
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ExpenseClaims": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExpenseClaim"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "expense_claims"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExpenseClaims {
        #[serde(
            rename = "ExpenseClaims",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub expense_claims: Vec<ExpenseClaim>,
    }

    impl From<&ExpenseClaims> for ExpenseClaims {
        fn from(value: &ExpenseClaims) -> Self {
            value.clone()
        }
    }

    ///ExternalLink
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Description": {
    ///      "type": "string"
    ///    },
    ///    "LinkType": {
    ///      "description": "See External link types",
    ///      "type": "string",
    ///      "enum": [
    ///        "Facebook",
    ///        "GooglePlus",
    ///        "LinkedIn",
    ///        "Twitter",
    ///        "Website"
    ///      ]
    ///    },
    ///    "Url": {
    ///      "description": "URL for service e.g. http://twitter.com/xeroapi",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExternalLink {
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        ///See External link types
        #[serde(rename = "LinkType", default, skip_serializing_if = "Option::is_none")]
        pub link_type: Option<ExternalLinkLinkType>,
        ///URL for service e.g. http://twitter.com/xeroapi
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
    }

    impl From<&ExternalLink> for ExternalLink {
        fn from(value: &ExternalLink) -> Self {
            value.clone()
        }
    }

    ///See External link types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See External link types",
    ///  "type": "string",
    ///  "enum": [
    ///    "Facebook",
    ///    "GooglePlus",
    ///    "LinkedIn",
    ///    "Twitter",
    ///    "Website"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExternalLinkLinkType {
        Facebook,
        GooglePlus,
        LinkedIn,
        Twitter,
        Website,
    }

    impl From<&ExternalLinkLinkType> for ExternalLinkLinkType {
        fn from(value: &ExternalLinkLinkType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ExternalLinkLinkType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Facebook => write!(f, "Facebook"),
                Self::GooglePlus => write!(f, "GooglePlus"),
                Self::LinkedIn => write!(f, "LinkedIn"),
                Self::Twitter => write!(f, "Twitter"),
                Self::Website => write!(f, "Website"),
            }
        }
    }

    impl std::str::FromStr for ExternalLinkLinkType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Facebook" => Ok(Self::Facebook),
                "GooglePlus" => Ok(Self::GooglePlus),
                "LinkedIn" => Ok(Self::LinkedIn),
                "Twitter" => Ok(Self::Twitter),
                "Website" => Ok(Self::Website),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExternalLinkLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExternalLinkLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExternalLinkLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///GetPurchaseOrdersStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SUBMITTED",
    ///    "AUTHORISED",
    ///    "BILLED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetPurchaseOrdersStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "BILLED")]
        Billed,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&GetPurchaseOrdersStatus> for GetPurchaseOrdersStatus {
        fn from(value: &GetPurchaseOrdersStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetPurchaseOrdersStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Billed => write!(f, "BILLED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for GetPurchaseOrdersStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SUBMITTED" => Ok(Self::Submitted),
                "AUTHORISED" => Ok(Self::Authorised),
                "BILLED" => Ok(Self::Billed),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for GetPurchaseOrdersStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for GetPurchaseOrdersStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for GetPurchaseOrdersStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///GetReportBalanceSheetTimeframe
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONTH",
    ///    "QUARTER",
    ///    "YEAR"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetReportBalanceSheetTimeframe {
        #[serde(rename = "MONTH")]
        Month,
        #[serde(rename = "QUARTER")]
        Quarter,
        #[serde(rename = "YEAR")]
        Year,
    }

    impl From<&GetReportBalanceSheetTimeframe> for GetReportBalanceSheetTimeframe {
        fn from(value: &GetReportBalanceSheetTimeframe) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetReportBalanceSheetTimeframe {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Month => write!(f, "MONTH"),
                Self::Quarter => write!(f, "QUARTER"),
                Self::Year => write!(f, "YEAR"),
            }
        }
    }

    impl std::str::FromStr for GetReportBalanceSheetTimeframe {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MONTH" => Ok(Self::Month),
                "QUARTER" => Ok(Self::Quarter),
                "YEAR" => Ok(Self::Year),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for GetReportBalanceSheetTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for GetReportBalanceSheetTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for GetReportBalanceSheetTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///GetReportProfitAndLossTimeframe
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONTH",
    ///    "QUARTER",
    ///    "YEAR"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetReportProfitAndLossTimeframe {
        #[serde(rename = "MONTH")]
        Month,
        #[serde(rename = "QUARTER")]
        Quarter,
        #[serde(rename = "YEAR")]
        Year,
    }

    impl From<&GetReportProfitAndLossTimeframe> for GetReportProfitAndLossTimeframe {
        fn from(value: &GetReportProfitAndLossTimeframe) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetReportProfitAndLossTimeframe {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Month => write!(f, "MONTH"),
                Self::Quarter => write!(f, "QUARTER"),
                Self::Year => write!(f, "YEAR"),
            }
        }
    }

    impl std::str::FromStr for GetReportProfitAndLossTimeframe {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MONTH" => Ok(Self::Month),
                "QUARTER" => Ok(Self::Quarter),
                "YEAR" => Ok(Self::Year),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for GetReportProfitAndLossTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for GetReportProfitAndLossTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for GetReportProfitAndLossTimeframe {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///HistoryRecord
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Changes": {
    ///      "description": "Name of branding theme",
    ///      "type": "string"
    ///    },
    ///    "DateUTC": {
    ///      "description": "UTC timestamp of creation date of branding theme",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "Details": {
    ///      "description": "details",
    ///      "type": "string"
    ///    },
    ///    "User": {
    ///      "description": "has a value of 0",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HistoryRecord {
        ///Name of branding theme
        #[serde(rename = "Changes", default, skip_serializing_if = "Option::is_none")]
        pub changes: Option<String>,
        ///UTC timestamp of creation date of branding theme
        #[serde(rename = "DateUTC", default, skip_serializing_if = "Option::is_none")]
        pub date_utc: Option<String>,
        ///details
        #[serde(rename = "Details", default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        ///has a value of 0
        #[serde(rename = "User", default, skip_serializing_if = "Option::is_none")]
        pub user: Option<String>,
    }

    impl From<&HistoryRecord> for HistoryRecord {
        fn from(value: &HistoryRecord) -> Self {
            value.clone()
        }
    }

    ///HistoryRecords
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "HistoryRecords": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/HistoryRecord"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "history_records"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HistoryRecords {
        #[serde(
            rename = "HistoryRecords",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub history_records: Vec<HistoryRecord>,
    }

    impl From<&HistoryRecords> for HistoryRecords {
        fn from(value: &HistoryRecords) -> Self {
            value.clone()
        }
    }

    ///A summary of the import from setup endpoint
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A summary of the import from setup endpoint",
    ///  "type": "object",
    ///  "properties": {
    ///    "Accounts": {
    ///      "$ref": "#/components/schemas/ImportSummaryAccounts"
    ///    },
    ///    "Organisation": {
    ///      "$ref": "#/components/schemas/ImportSummaryOrganisation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImportSummary {
        #[serde(rename = "Accounts", default, skip_serializing_if = "Option::is_none")]
        pub accounts: Option<ImportSummaryAccounts>,
        #[serde(
            rename = "Organisation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation: Option<ImportSummaryOrganisation>,
    }

    impl From<&ImportSummary> for ImportSummary {
        fn from(value: &ImportSummary) -> Self {
            value.clone()
        }
    }

    ///A summary of the accounts changes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A summary of the accounts changes",
    ///  "type": "object",
    ///  "properties": {
    ///    "Deleted": {
    ///      "description": "The number of accounts deleted",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "Errored": {
    ///      "description": "The number of accounts that had an error",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "Locked": {
    ///      "description": "The number of locked accounts",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "New": {
    ///      "description": "The number of new accounts created",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "NewOrUpdated": {
    ///      "description": "The number of new or updated accounts",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "Present": {
    ///      "type": "boolean"
    ///    },
    ///    "System": {
    ///      "description": "The number of system accounts",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "Total": {
    ///      "description": "The total number of accounts in the org",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "Updated": {
    ///      "description": "The number of accounts updated",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImportSummaryAccounts {
        ///The number of accounts deleted
        #[serde(rename = "Deleted", default, skip_serializing_if = "Option::is_none")]
        pub deleted: Option<i32>,
        ///The number of accounts that had an error
        #[serde(rename = "Errored", default, skip_serializing_if = "Option::is_none")]
        pub errored: Option<i32>,
        ///The number of locked accounts
        #[serde(rename = "Locked", default, skip_serializing_if = "Option::is_none")]
        pub locked: Option<i32>,
        ///The number of new accounts created
        #[serde(rename = "New", default, skip_serializing_if = "Option::is_none")]
        pub new: Option<i32>,
        ///The number of new or updated accounts
        #[serde(
            rename = "NewOrUpdated",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub new_or_updated: Option<i32>,
        #[serde(rename = "Present", default, skip_serializing_if = "Option::is_none")]
        pub present: Option<bool>,
        ///The number of system accounts
        #[serde(rename = "System", default, skip_serializing_if = "Option::is_none")]
        pub system: Option<i32>,
        ///The total number of accounts in the org
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<i32>,
        ///The number of accounts updated
        #[serde(rename = "Updated", default, skip_serializing_if = "Option::is_none")]
        pub updated: Option<i32>,
    }

    impl From<&ImportSummaryAccounts> for ImportSummaryAccounts {
        fn from(value: &ImportSummaryAccounts) -> Self {
            value.clone()
        }
    }

    ///ImportSummaryObject
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "ImportSummary": {
    ///      "$ref": "#/components/schemas/ImportSummary"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImportSummaryObject {
        #[serde(
            rename = "ImportSummary",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub import_summary: Option<ImportSummary>,
    }

    impl From<&ImportSummaryObject> for ImportSummaryObject {
        fn from(value: &ImportSummaryObject) -> Self {
            value.clone()
        }
    }

    ///ImportSummaryOrganisation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Present": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImportSummaryOrganisation {
        #[serde(rename = "Present", default, skip_serializing_if = "Option::is_none")]
        pub present: Option<bool>,
    }

    impl From<&ImportSummaryOrganisation> for ImportSummaryOrganisation {
        fn from(value: &ImportSummaryOrganisation) -> Self {
            value.clone()
        }
    }

    ///Invoice
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AmountCredited": {
    ///      "description": "Sum of all credit notes, over-payments and
    /// pre-payments applied to invoice",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "AmountDue": {
    ///      "description": "Amount remaining to be paid on invoice",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "AmountPaid": {
    ///      "description": "Sum of payments received for invoice",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "BrandingThemeID": {
    ///      "description": "See BrandingThemes",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "CISDeduction": {
    ///      "description": "CIS deduction for UK contractors",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "CISRate": {
    ///      "description": "CIS Deduction rate for the organisation",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CreditNotes": {
    ///      "description": "Details of credit notes that have been applied to
    /// an invoice",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CreditNote"
    ///      }
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency invoice. If
    /// no rate is specified, the XE.com day rate is used. (max length =
    /// [18].[6])",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "Date invoice was issued – YYYY-MM-DD. If the Date
    /// element is not specified it will default to the current date based on
    /// the timezone setting of the organisation",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DueDate": {
    ///      "description": "Date invoice is due – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "ExpectedPaymentDate": {
    ///      "description": "Shown on sales invoices (Accounts Receivable) when
    /// this has been set",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "FullyPaidOnDate": {
    ///      "description": "The date the invoice was fully paid. Only returned
    /// on fully paid invoices",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if an invoice has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "HasErrors": {
    ///      "description": "A boolean to indicate if a invoice has an
    /// validation errors",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "InvoiceAddresses": {
    ///      "description": "An array of addresses used to auto calculate sales
    /// tax",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InvoiceAddress"
    ///      }
    ///    },
    ///    "InvoiceID": {
    ///      "description": "Xero generated unique identifier for invoice",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "InvoiceNumber": {
    ///      "description": "ACCREC – Unique alpha numeric code identifying
    /// invoice (when missing will auto-generate from your Organisation Invoice
    /// Settings) (max length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "IsDiscounted": {
    ///      "description": "boolean to indicate if an invoice has a discount",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See LineItems",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "Overpayments": {
    ///      "description": "See Overpayments",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Overpayment"
    ///      }
    ///    },
    ///    "Payments": {
    ///      "description": "See Payments",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "PlannedPaymentDate": {
    ///      "description": "Shown on bills (Accounts Payable) when this has
    /// been set",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Prepayments": {
    ///      "description": "See Prepayments",
    ///      "readOnly": true,
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Prepayment"
    ///      }
    ///    },
    ///    "Reference": {
    ///      "description": "ACCREC only – additional reference number",
    ///      "type": "string"
    ///    },
    ///    "RepeatingInvoiceID": {
    ///      "description": "Xero generated unique identifier for repeating
    /// invoices",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SentToContact": {
    ///      "description": "Boolean to set whether the invoice in the Xero app
    /// should be marked as “sent”. This can be set only on invoices that have
    /// been approved",
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "See Invoice Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "SUBMITTED",
    ///        "DELETED",
    ///        "AUTHORISED",
    ///        "PAID",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of invoice excluding taxes",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "Total of Invoice tax inclusive (i.e. SubTotal +
    /// TotalTax). This will be ignored if it doesn’t equal the sum of the
    /// LineAmounts",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalDiscount": {
    ///      "description": "Total of discounts applied on the invoice line
    /// items",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on invoice",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Invoice Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCPAY",
    ///        "ACCPAYCREDIT",
    ///        "APOVERPAYMENT",
    ///        "APPREPAYMENT",
    ///        "ACCREC",
    ///        "ACCRECCREDIT",
    ///        "AROVERPAYMENT",
    ///        "ARPREPAYMENT"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "Url": {
    ///      "description": "URL link to a source document – shown as “Go to
    /// [appName]” in the Xero app",
    ///      "type": "string"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Invoice {
        #[serde(
            rename = "AmountCredited",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub amount_credited: Option<f64>,
        #[serde(rename = "AmountDue", default, skip_serializing_if = "Option::is_none")]
        pub amount_due: Option<f64>,
        #[serde(
            rename = "AmountPaid",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub amount_paid: Option<f64>,
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        ///See BrandingThemes
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        #[serde(
            rename = "CISDeduction",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cis_deduction: Option<f64>,
        #[serde(rename = "CISRate", default, skip_serializing_if = "Option::is_none")]
        pub cis_rate: Option<f64>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        ///Details of credit notes that have been applied to an invoice
        #[serde(rename = "CreditNotes", default, skip_serializing_if = "Vec::is_empty")]
        pub credit_notes: Vec<CreditNote>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///Date invoice was issued – YYYY-MM-DD. If the Date element is not
        /// specified it will default to the current date based on the timezone
        /// setting of the organisation
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Date invoice is due – YYYY-MM-DD
        #[serde(rename = "DueDate", default, skip_serializing_if = "Option::is_none")]
        pub due_date: Option<String>,
        ///Shown on sales invoices (Accounts Receivable) when this has been set
        #[serde(
            rename = "ExpectedPaymentDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expected_payment_date: Option<String>,
        ///The date the invoice was fully paid. Only returned on fully paid
        /// invoices
        #[serde(
            rename = "FullyPaidOnDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub fully_paid_on_date: Option<String>,
        ///boolean to indicate if an invoice has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///A boolean to indicate if a invoice has an validation errors
        #[serde(rename = "HasErrors", default)]
        pub has_errors: bool,
        ///An array of addresses used to auto calculate sales tax
        #[serde(
            rename = "InvoiceAddresses",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub invoice_addresses: Vec<InvoiceAddress>,
        ///Xero generated unique identifier for invoice
        #[serde(rename = "InvoiceID", default, skip_serializing_if = "Option::is_none")]
        pub invoice_id: Option<uuid::Uuid>,
        ///ACCREC – Unique alpha numeric code identifying invoice (when missing
        /// will auto-generate from your Organisation Invoice Settings) (max
        /// length = 255)
        #[serde(
            rename = "InvoiceNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub invoice_number: Option<InvoiceInvoiceNumber>,
        ///boolean to indicate if an invoice has a discount
        #[serde(
            rename = "IsDiscounted",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_discounted: Option<bool>,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See LineItems
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///See Overpayments
        #[serde(
            rename = "Overpayments",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub overpayments: Vec<Overpayment>,
        ///See Payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///Shown on bills (Accounts Payable) when this has been set
        #[serde(
            rename = "PlannedPaymentDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub planned_payment_date: Option<String>,
        ///See Prepayments
        #[serde(rename = "Prepayments", default, skip_serializing_if = "Vec::is_empty")]
        pub prepayments: Vec<Prepayment>,
        ///ACCREC only – additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///Xero generated unique identifier for repeating invoices
        #[serde(
            rename = "RepeatingInvoiceID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub repeating_invoice_id: Option<uuid::Uuid>,
        ///Boolean to set whether the invoice in the Xero app should be marked
        /// as “sent”. This can be set only on invoices that have been approved
        #[serde(
            rename = "SentToContact",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sent_to_contact: Option<bool>,
        ///See Invoice Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<InvoiceStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(
            rename = "TotalDiscount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_discount: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Invoice Types
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<InvoiceType>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///URL link to a source document – shown as “Go to [appName]” in the
        /// Xero app
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Invoice> for Invoice {
        fn from(value: &Invoice) -> Self {
            value.clone()
        }
    }

    ///InvoiceAddress
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AddressLine1": {
    ///      "description": "First line of a physical address",
    ///      "type": "string"
    ///    },
    ///    "AddressLine2": {
    ///      "description": "Second line of a physical address",
    ///      "type": "string"
    ///    },
    ///    "AddressLine3": {
    ///      "description": "Third line of a physical address",
    ///      "type": "string"
    ///    },
    ///    "AddressLine4": {
    ///      "description": "Fourth line of a physical address",
    ///      "type": "string"
    ///    },
    ///    "City": {
    ///      "description": "City of a physical address",
    ///      "type": "string"
    ///    },
    ///    "Country": {
    ///      "description": "Country of a physical address",
    ///      "type": "string"
    ///    },
    ///    "InvoiceAddressType": {
    ///      "description": "Indicates whether the address is defined as origin
    /// (FROM) or destination (TO)",
    ///      "type": "string",
    ///      "enum": [
    ///        "FROM",
    ///        "TO"
    ///      ]
    ///    },
    ///    "PostalCode": {
    ///      "description": "Postal code of a physical address",
    ///      "type": "string"
    ///    },
    ///    "Region": {
    ///      "description": "Region or state of a physical address",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvoiceAddress {
        ///First line of a physical address
        #[serde(
            rename = "AddressLine1",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line1: Option<String>,
        ///Second line of a physical address
        #[serde(
            rename = "AddressLine2",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line2: Option<String>,
        ///Third line of a physical address
        #[serde(
            rename = "AddressLine3",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line3: Option<String>,
        ///Fourth line of a physical address
        #[serde(
            rename = "AddressLine4",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub address_line4: Option<String>,
        ///City of a physical address
        #[serde(rename = "City", default, skip_serializing_if = "Option::is_none")]
        pub city: Option<String>,
        ///Country of a physical address
        #[serde(rename = "Country", default, skip_serializing_if = "Option::is_none")]
        pub country: Option<String>,
        ///Indicates whether the address is defined as origin (FROM) or
        /// destination (TO)
        #[serde(
            rename = "InvoiceAddressType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub invoice_address_type: Option<InvoiceAddressInvoiceAddressType>,
        ///Postal code of a physical address
        #[serde(
            rename = "PostalCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub postal_code: Option<String>,
        ///Region or state of a physical address
        #[serde(rename = "Region", default, skip_serializing_if = "Option::is_none")]
        pub region: Option<String>,
    }

    impl From<&InvoiceAddress> for InvoiceAddress {
        fn from(value: &InvoiceAddress) -> Self {
            value.clone()
        }
    }

    ///Indicates whether the address is defined as origin (FROM) or destination
    /// (TO)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates whether the address is defined as origin
    /// (FROM) or destination (TO)",
    ///  "type": "string",
    ///  "enum": [
    ///    "FROM",
    ///    "TO"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InvoiceAddressInvoiceAddressType {
        #[serde(rename = "FROM")]
        From,
        #[serde(rename = "TO")]
        To,
    }

    impl From<&InvoiceAddressInvoiceAddressType> for InvoiceAddressInvoiceAddressType {
        fn from(value: &InvoiceAddressInvoiceAddressType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InvoiceAddressInvoiceAddressType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::From => write!(f, "FROM"),
                Self::To => write!(f, "TO"),
            }
        }
    }

    impl std::str::FromStr for InvoiceAddressInvoiceAddressType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FROM" => Ok(Self::From),
                "TO" => Ok(Self::To),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for InvoiceAddressInvoiceAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InvoiceAddressInvoiceAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InvoiceAddressInvoiceAddressType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///ACCREC – Unique alpha numeric code identifying invoice (when missing
    /// will auto-generate from your Organisation Invoice Settings) (max length
    /// = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "ACCREC – Unique alpha numeric code identifying invoice
    /// (when missing will auto-generate from your Organisation Invoice
    /// Settings) (max length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct InvoiceInvoiceNumber(String);
    impl ::std::ops::Deref for InvoiceInvoiceNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<InvoiceInvoiceNumber> for String {
        fn from(value: InvoiceInvoiceNumber) -> Self {
            value.0
        }
    }

    impl From<&InvoiceInvoiceNumber> for InvoiceInvoiceNumber {
        fn from(value: &InvoiceInvoiceNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InvoiceInvoiceNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InvoiceInvoiceNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for InvoiceInvoiceNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for InvoiceInvoiceNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InvoiceInvoiceNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///InvoiceReminder
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Enabled": {
    ///      "description": "setting for on or off",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvoiceReminder {
        ///setting for on or off
        #[serde(rename = "Enabled", default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    impl From<&InvoiceReminder> for InvoiceReminder {
        fn from(value: &InvoiceReminder) -> Self {
            value.clone()
        }
    }

    ///InvoiceReminders
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "InvoiceReminders": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InvoiceReminder"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "invoice_reminders"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvoiceReminders {
        #[serde(
            rename = "InvoiceReminders",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub invoice_reminders: Vec<InvoiceReminder>,
    }

    impl From<&InvoiceReminders> for InvoiceReminders {
        fn from(value: &InvoiceReminders) -> Self {
            value.clone()
        }
    }

    ///See Invoice Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Invoice Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SUBMITTED",
    ///    "DELETED",
    ///    "AUTHORISED",
    ///    "PAID",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InvoiceStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "DELETED")]
        Deleted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "PAID")]
        Paid,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&InvoiceStatus> for InvoiceStatus {
        fn from(value: &InvoiceStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InvoiceStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Deleted => write!(f, "DELETED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Paid => write!(f, "PAID"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for InvoiceStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SUBMITTED" => Ok(Self::Submitted),
                "DELETED" => Ok(Self::Deleted),
                "AUTHORISED" => Ok(Self::Authorised),
                "PAID" => Ok(Self::Paid),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Invoice Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Invoice Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCPAY",
    ///    "ACCPAYCREDIT",
    ///    "APOVERPAYMENT",
    ///    "APPREPAYMENT",
    ///    "ACCREC",
    ///    "ACCRECCREDIT",
    ///    "AROVERPAYMENT",
    ///    "ARPREPAYMENT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InvoiceType {
        #[serde(rename = "ACCPAY")]
        Accpay,
        #[serde(rename = "ACCPAYCREDIT")]
        Accpaycredit,
        #[serde(rename = "APOVERPAYMENT")]
        Apoverpayment,
        #[serde(rename = "APPREPAYMENT")]
        Apprepayment,
        #[serde(rename = "ACCREC")]
        Accrec,
        #[serde(rename = "ACCRECCREDIT")]
        Accreccredit,
        #[serde(rename = "AROVERPAYMENT")]
        Aroverpayment,
        #[serde(rename = "ARPREPAYMENT")]
        Arprepayment,
    }

    impl From<&InvoiceType> for InvoiceType {
        fn from(value: &InvoiceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InvoiceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accpay => write!(f, "ACCPAY"),
                Self::Accpaycredit => write!(f, "ACCPAYCREDIT"),
                Self::Apoverpayment => write!(f, "APOVERPAYMENT"),
                Self::Apprepayment => write!(f, "APPREPAYMENT"),
                Self::Accrec => write!(f, "ACCREC"),
                Self::Accreccredit => write!(f, "ACCRECCREDIT"),
                Self::Aroverpayment => write!(f, "AROVERPAYMENT"),
                Self::Arprepayment => write!(f, "ARPREPAYMENT"),
            }
        }
    }

    impl std::str::FromStr for InvoiceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCPAY" => Ok(Self::Accpay),
                "ACCPAYCREDIT" => Ok(Self::Accpaycredit),
                "APOVERPAYMENT" => Ok(Self::Apoverpayment),
                "APPREPAYMENT" => Ok(Self::Apprepayment),
                "ACCREC" => Ok(Self::Accrec),
                "ACCRECCREDIT" => Ok(Self::Accreccredit),
                "AROVERPAYMENT" => Ok(Self::Aroverpayment),
                "ARPREPAYMENT" => Ok(Self::Arprepayment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for InvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Invoices
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Invoices": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Invoice"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "invoices"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Invoices {
        #[serde(rename = "Invoices", default, skip_serializing_if = "Vec::is_empty")]
        pub invoices: Vec<Invoice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Invoices> for Invoices {
        fn from(value: &Invoices) -> Self {
            value.clone()
        }
    }

    ///Item
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Code"
    ///  ],
    ///  "properties": {
    ///    "Code": {
    ///      "description": "User defined item code (max length = 30)",
    ///      "type": "string",
    ///      "maxLength": 30
    ///    },
    ///    "Description": {
    ///      "description": "The sales description of the item (max length =
    /// 4000)",
    ///      "type": "string",
    ///      "maxLength": 4000
    ///    },
    ///    "InventoryAssetAccountCode": {
    ///      "description": "The inventory asset account for the item. The
    /// account must be of type INVENTORY. The  COGSAccountCode in
    /// PurchaseDetails is also required to create a tracked item",
    ///      "type": "string"
    ///    },
    ///    "IsPurchased": {
    ///      "description": "Boolean value, defaults to true. When IsPurchased
    /// is true the item is available for purchase transactions in the Xero UI.
    /// If IsPurchased is updated to false then PurchaseDescription and
    /// PurchaseDetails values will be nulled.",
    ///      "type": "boolean"
    ///    },
    ///    "IsSold": {
    ///      "description": "Boolean value, defaults to true. When IsSold is
    /// true the item will be available on sales transactions in the Xero UI. If
    /// IsSold is updated to false then Description and SalesDetails values will
    /// be nulled.",
    ///      "type": "boolean"
    ///    },
    ///    "IsTrackedAsInventory": {
    ///      "description": "True for items that are tracked as inventory. An
    /// item will be tracked as inventory if the InventoryAssetAccountCode and
    /// COGSAccountCode are set.",
    ///      "type": "boolean"
    ///    },
    ///    "ItemID": {
    ///      "description": "The Xero identifier for an Item",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Name": {
    ///      "description": "The name of the item (max length = 50)",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "PurchaseDescription": {
    ///      "description": "The purchase description of the item (max length =
    /// 4000)",
    ///      "type": "string",
    ///      "maxLength": 4000
    ///    },
    ///    "PurchaseDetails": {
    ///      "$ref": "#/components/schemas/Purchase"
    ///    },
    ///    "QuantityOnHand": {
    ///      "description": "The quantity of the item on hand",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "SalesDetails": {
    ///      "$ref": "#/components/schemas/Purchase"
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "Status of object",
    ///      "type": "string"
    ///    },
    ///    "TotalCostPool": {
    ///      "description": "The value of the item on hand. Calculated using
    /// average cost accounting.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date in UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Item {
        ///User defined item code (max length = 30)
        #[serde(rename = "Code")]
        pub code: ItemCode,
        ///The sales description of the item (max length = 4000)
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<ItemDescription>,
        ///The inventory asset account for the item. The account must be of
        /// type INVENTORY. The  COGSAccountCode in PurchaseDetails is also
        /// required to create a tracked item
        #[serde(
            rename = "InventoryAssetAccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub inventory_asset_account_code: Option<String>,
        ///Boolean value, defaults to true. When IsPurchased is true the item
        /// is available for purchase transactions in the Xero UI. If
        /// IsPurchased is updated to false then PurchaseDescription and
        /// PurchaseDetails values will be nulled.
        #[serde(
            rename = "IsPurchased",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_purchased: Option<bool>,
        ///Boolean value, defaults to true. When IsSold is true the item will
        /// be available on sales transactions in the Xero UI. If IsSold is
        /// updated to false then Description and SalesDetails values will be
        /// nulled.
        #[serde(rename = "IsSold", default, skip_serializing_if = "Option::is_none")]
        pub is_sold: Option<bool>,
        ///True for items that are tracked as inventory. An item will be
        /// tracked as inventory if the InventoryAssetAccountCode and
        /// COGSAccountCode are set.
        #[serde(
            rename = "IsTrackedAsInventory",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_tracked_as_inventory: Option<bool>,
        ///The Xero identifier for an Item
        #[serde(rename = "ItemID", default, skip_serializing_if = "Option::is_none")]
        pub item_id: Option<uuid::Uuid>,
        ///The name of the item (max length = 50)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<ItemName>,
        ///The purchase description of the item (max length = 4000)
        #[serde(
            rename = "PurchaseDescription",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchase_description: Option<ItemPurchaseDescription>,
        #[serde(
            rename = "PurchaseDetails",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchase_details: Option<Purchase>,
        #[serde(
            rename = "QuantityOnHand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub quantity_on_hand: Option<f64>,
        #[serde(
            rename = "SalesDetails",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_details: Option<Purchase>,
        ///Status of object
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(
            rename = "TotalCostPool",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_cost_pool: Option<f64>,
        ///Last modified date in UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Item> for Item {
        fn from(value: &Item) -> Self {
            value.clone()
        }
    }

    ///User defined item code (max length = 30)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "User defined item code (max length = 30)",
    ///  "type": "string",
    ///  "maxLength": 30
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ItemCode(String);
    impl ::std::ops::Deref for ItemCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ItemCode> for String {
        fn from(value: ItemCode) -> Self {
            value.0
        }
    }

    impl From<&ItemCode> for ItemCode {
        fn from(value: &ItemCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ItemCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 30usize {
                return Err("longer than 30 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ItemCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The sales description of the item (max length = 4000)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The sales description of the item (max length = 4000)",
    ///  "type": "string",
    ///  "maxLength": 4000
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ItemDescription(String);
    impl ::std::ops::Deref for ItemDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ItemDescription> for String {
        fn from(value: ItemDescription) -> Self {
            value.0
        }
    }

    impl From<&ItemDescription> for ItemDescription {
        fn from(value: &ItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 4000usize {
                return Err("longer than 4000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ItemDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The name of the item (max length = 50)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the item (max length = 50)",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ItemName(String);
    impl ::std::ops::Deref for ItemName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ItemName> for String {
        fn from(value: ItemName) -> Self {
            value.0
        }
    }

    impl From<&ItemName> for ItemName {
        fn from(value: &ItemName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ItemName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ItemName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The purchase description of the item (max length = 4000)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The purchase description of the item (max length =
    /// 4000)",
    ///  "type": "string",
    ///  "maxLength": 4000
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ItemPurchaseDescription(String);
    impl ::std::ops::Deref for ItemPurchaseDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ItemPurchaseDescription> for String {
        fn from(value: ItemPurchaseDescription) -> Self {
            value.0
        }
    }

    impl From<&ItemPurchaseDescription> for ItemPurchaseDescription {
        fn from(value: &ItemPurchaseDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ItemPurchaseDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 4000usize {
                return Err("longer than 4000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ItemPurchaseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ItemPurchaseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ItemPurchaseDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ItemPurchaseDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Items
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Item"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "items"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Items {
        #[serde(rename = "Items", default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<Item>,
    }

    impl From<&Items> for Items {
        fn from(value: &Items) -> Self {
            value.clone()
        }
    }

    ///Journal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "CreatedDateUTC": {
    ///      "description": "Created date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "JournalDate": {
    ///      "description": "Date the journal was posted",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "JournalID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "JournalLines": {
    ///      "description": "See JournalLines",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/JournalLine"
    ///      }
    ///    },
    ///    "JournalNumber": {
    ///      "description": "Xero generated journal number",
    ///      "type": "integer"
    ///    },
    ///    "Reference": {
    ///      "description": "reference field for additional indetifying
    /// information",
    ///      "type": "string"
    ///    },
    ///    "SourceID": {
    ///      "description": "The identifier for the source transaction (e.g.
    /// InvoiceID)",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SourceType": {
    ///      "description": "The journal source type. The type of transaction
    /// that created the journal",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCREC",
    ///        "ACCPAY",
    ///        "ACCRECCREDIT",
    ///        "ACCPAYCREDIT",
    ///        "ACCRECPAYMENT",
    ///        "ACCPAYPAYMENT",
    ///        "ARCREDITPAYMENT",
    ///        "APCREDITPAYMENT",
    ///        "CASHREC",
    ///        "CASHPAID",
    ///        "TRANSFER",
    ///        "ARPREPAYMENT",
    ///        "APPREPAYMENT",
    ///        "AROVERPAYMENT",
    ///        "APOVERPAYMENT",
    ///        "EXPCLAIM",
    ///        "EXPPAYMENT",
    ///        "MANJOURNAL",
    ///        "PAYSLIP",
    ///        "WAGEPAYABLE",
    ///        "INTEGRATEDPAYROLLPE",
    ///        "INTEGRATEDPAYROLLPT",
    ///        "EXTERNALSPENDMONEY",
    ///        "INTEGRATEDPAYROLLPTPAYMENT",
    ///        "INTEGRATEDPAYROLLCN"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Journal {
        ///Created date UTC format
        #[serde(
            rename = "CreatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub created_date_utc: Option<String>,
        ///Date the journal was posted
        #[serde(
            rename = "JournalDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub journal_date: Option<String>,
        ///Xero identifier
        #[serde(rename = "JournalID", default, skip_serializing_if = "Option::is_none")]
        pub journal_id: Option<uuid::Uuid>,
        ///See JournalLines
        #[serde(
            rename = "JournalLines",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub journal_lines: Vec<JournalLine>,
        ///Xero generated journal number
        #[serde(
            rename = "JournalNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub journal_number: Option<i64>,
        ///reference field for additional indetifying information
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///The identifier for the source transaction (e.g. InvoiceID)
        #[serde(rename = "SourceID", default, skip_serializing_if = "Option::is_none")]
        pub source_id: Option<uuid::Uuid>,
        ///The journal source type. The type of transaction that created the
        /// journal
        #[serde(
            rename = "SourceType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_type: Option<JournalSourceType>,
    }

    impl From<&Journal> for Journal {
        fn from(value: &Journal) -> Self {
            value.clone()
        }
    }

    ///JournalLine
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "See Accounts",
    ///      "examples": [
    ///        "090"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "AccountID": {
    ///      "description": "See Accounts",
    ///      "examples": [
    ///        "ceef66a5-a545-413b-9312-78a53caadbc4"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "AccountName": {
    ///      "description": "See AccountCodes",
    ///      "examples": [
    ///        "Checking Account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "AccountType": {
    ///      "$ref": "#/components/schemas/AccountType"
    ///    },
    ///    "Description": {
    ///      "description": "The description from the source transaction line
    /// item. Only returned if populated.",
    ///      "examples": [
    ///        "My business checking account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "GrossAmount": {
    ///      "description": "Gross amount of journal line (NetAmount +
    /// TaxAmount).",
    ///      "examples": [
    ///        4130.98
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "JournalLineID": {
    ///      "description": "Xero identifier for Journal",
    ///      "examples": [
    ///        "7be9db36-3598-4755-ba5c-c2dbc8c4a7a2"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "NetAmount": {
    ///      "description": "Net amount of journal line. This will be a positive
    /// value for a debit and negative for a credit",
    ///      "examples": [
    ///        4130.98
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TaxAmount": {
    ///      "description": "Total tax on a journal line",
    ///      "readOnly": true,
    ///      "examples": [
    ///        0.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TaxName": {
    ///      "description": "see TaxRates",
    ///      "examples": [
    ///        "Tax Exempt"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type from taxRates",
    ///      "type": "string"
    ///    },
    ///    "TrackingCategories": {
    ///      "description": "Optional Tracking Category – see Tracking. Any
    /// JournalLine can have a maximum of 2 <TrackingCategory> elements.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingCategory"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct JournalLine {
        ///See Accounts
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        ///See Accounts
        #[serde(rename = "AccountID", default, skip_serializing_if = "Option::is_none")]
        pub account_id: Option<uuid::Uuid>,
        ///See AccountCodes
        #[serde(
            rename = "AccountName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_name: Option<String>,
        #[serde(
            rename = "AccountType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_type: Option<AccountType>,
        ///The description from the source transaction line item. Only returned
        /// if populated.
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        #[serde(
            rename = "GrossAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub gross_amount: Option<f64>,
        ///Xero identifier for Journal
        #[serde(
            rename = "JournalLineID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub journal_line_id: Option<uuid::Uuid>,
        #[serde(rename = "NetAmount", default, skip_serializing_if = "Option::is_none")]
        pub net_amount: Option<f64>,
        #[serde(rename = "TaxAmount", default, skip_serializing_if = "Option::is_none")]
        pub tax_amount: Option<f64>,
        ///see TaxRates
        #[serde(rename = "TaxName", default, skip_serializing_if = "Option::is_none")]
        pub tax_name: Option<String>,
        ///The tax type from taxRates
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
        ///Optional Tracking Category – see Tracking. Any JournalLine can have
        /// a maximum of 2 <TrackingCategory> elements.
        #[serde(
            rename = "TrackingCategories",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tracking_categories: Vec<TrackingCategory>,
    }

    impl From<&JournalLine> for JournalLine {
        fn from(value: &JournalLine) -> Self {
            value.clone()
        }
    }

    ///The journal source type. The type of transaction that created the
    /// journal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The journal source type. The type of transaction that
    /// created the journal",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCREC",
    ///    "ACCPAY",
    ///    "ACCRECCREDIT",
    ///    "ACCPAYCREDIT",
    ///    "ACCRECPAYMENT",
    ///    "ACCPAYPAYMENT",
    ///    "ARCREDITPAYMENT",
    ///    "APCREDITPAYMENT",
    ///    "CASHREC",
    ///    "CASHPAID",
    ///    "TRANSFER",
    ///    "ARPREPAYMENT",
    ///    "APPREPAYMENT",
    ///    "AROVERPAYMENT",
    ///    "APOVERPAYMENT",
    ///    "EXPCLAIM",
    ///    "EXPPAYMENT",
    ///    "MANJOURNAL",
    ///    "PAYSLIP",
    ///    "WAGEPAYABLE",
    ///    "INTEGRATEDPAYROLLPE",
    ///    "INTEGRATEDPAYROLLPT",
    ///    "EXTERNALSPENDMONEY",
    ///    "INTEGRATEDPAYROLLPTPAYMENT",
    ///    "INTEGRATEDPAYROLLCN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum JournalSourceType {
        #[serde(rename = "ACCREC")]
        Accrec,
        #[serde(rename = "ACCPAY")]
        Accpay,
        #[serde(rename = "ACCRECCREDIT")]
        Accreccredit,
        #[serde(rename = "ACCPAYCREDIT")]
        Accpaycredit,
        #[serde(rename = "ACCRECPAYMENT")]
        Accrecpayment,
        #[serde(rename = "ACCPAYPAYMENT")]
        Accpaypayment,
        #[serde(rename = "ARCREDITPAYMENT")]
        Arcreditpayment,
        #[serde(rename = "APCREDITPAYMENT")]
        Apcreditpayment,
        #[serde(rename = "CASHREC")]
        Cashrec,
        #[serde(rename = "CASHPAID")]
        Cashpaid,
        #[serde(rename = "TRANSFER")]
        Transfer,
        #[serde(rename = "ARPREPAYMENT")]
        Arprepayment,
        #[serde(rename = "APPREPAYMENT")]
        Apprepayment,
        #[serde(rename = "AROVERPAYMENT")]
        Aroverpayment,
        #[serde(rename = "APOVERPAYMENT")]
        Apoverpayment,
        #[serde(rename = "EXPCLAIM")]
        Expclaim,
        #[serde(rename = "EXPPAYMENT")]
        Exppayment,
        #[serde(rename = "MANJOURNAL")]
        Manjournal,
        #[serde(rename = "PAYSLIP")]
        Payslip,
        #[serde(rename = "WAGEPAYABLE")]
        Wagepayable,
        #[serde(rename = "INTEGRATEDPAYROLLPE")]
        Integratedpayrollpe,
        #[serde(rename = "INTEGRATEDPAYROLLPT")]
        Integratedpayrollpt,
        #[serde(rename = "EXTERNALSPENDMONEY")]
        Externalspendmoney,
        #[serde(rename = "INTEGRATEDPAYROLLPTPAYMENT")]
        Integratedpayrollptpayment,
        #[serde(rename = "INTEGRATEDPAYROLLCN")]
        Integratedpayrollcn,
    }

    impl From<&JournalSourceType> for JournalSourceType {
        fn from(value: &JournalSourceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for JournalSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accrec => write!(f, "ACCREC"),
                Self::Accpay => write!(f, "ACCPAY"),
                Self::Accreccredit => write!(f, "ACCRECCREDIT"),
                Self::Accpaycredit => write!(f, "ACCPAYCREDIT"),
                Self::Accrecpayment => write!(f, "ACCRECPAYMENT"),
                Self::Accpaypayment => write!(f, "ACCPAYPAYMENT"),
                Self::Arcreditpayment => write!(f, "ARCREDITPAYMENT"),
                Self::Apcreditpayment => write!(f, "APCREDITPAYMENT"),
                Self::Cashrec => write!(f, "CASHREC"),
                Self::Cashpaid => write!(f, "CASHPAID"),
                Self::Transfer => write!(f, "TRANSFER"),
                Self::Arprepayment => write!(f, "ARPREPAYMENT"),
                Self::Apprepayment => write!(f, "APPREPAYMENT"),
                Self::Aroverpayment => write!(f, "AROVERPAYMENT"),
                Self::Apoverpayment => write!(f, "APOVERPAYMENT"),
                Self::Expclaim => write!(f, "EXPCLAIM"),
                Self::Exppayment => write!(f, "EXPPAYMENT"),
                Self::Manjournal => write!(f, "MANJOURNAL"),
                Self::Payslip => write!(f, "PAYSLIP"),
                Self::Wagepayable => write!(f, "WAGEPAYABLE"),
                Self::Integratedpayrollpe => write!(f, "INTEGRATEDPAYROLLPE"),
                Self::Integratedpayrollpt => write!(f, "INTEGRATEDPAYROLLPT"),
                Self::Externalspendmoney => write!(f, "EXTERNALSPENDMONEY"),
                Self::Integratedpayrollptpayment => write!(f, "INTEGRATEDPAYROLLPTPAYMENT"),
                Self::Integratedpayrollcn => write!(f, "INTEGRATEDPAYROLLCN"),
            }
        }
    }

    impl std::str::FromStr for JournalSourceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCREC" => Ok(Self::Accrec),
                "ACCPAY" => Ok(Self::Accpay),
                "ACCRECCREDIT" => Ok(Self::Accreccredit),
                "ACCPAYCREDIT" => Ok(Self::Accpaycredit),
                "ACCRECPAYMENT" => Ok(Self::Accrecpayment),
                "ACCPAYPAYMENT" => Ok(Self::Accpaypayment),
                "ARCREDITPAYMENT" => Ok(Self::Arcreditpayment),
                "APCREDITPAYMENT" => Ok(Self::Apcreditpayment),
                "CASHREC" => Ok(Self::Cashrec),
                "CASHPAID" => Ok(Self::Cashpaid),
                "TRANSFER" => Ok(Self::Transfer),
                "ARPREPAYMENT" => Ok(Self::Arprepayment),
                "APPREPAYMENT" => Ok(Self::Apprepayment),
                "AROVERPAYMENT" => Ok(Self::Aroverpayment),
                "APOVERPAYMENT" => Ok(Self::Apoverpayment),
                "EXPCLAIM" => Ok(Self::Expclaim),
                "EXPPAYMENT" => Ok(Self::Exppayment),
                "MANJOURNAL" => Ok(Self::Manjournal),
                "PAYSLIP" => Ok(Self::Payslip),
                "WAGEPAYABLE" => Ok(Self::Wagepayable),
                "INTEGRATEDPAYROLLPE" => Ok(Self::Integratedpayrollpe),
                "INTEGRATEDPAYROLLPT" => Ok(Self::Integratedpayrollpt),
                "EXTERNALSPENDMONEY" => Ok(Self::Externalspendmoney),
                "INTEGRATEDPAYROLLPTPAYMENT" => Ok(Self::Integratedpayrollptpayment),
                "INTEGRATEDPAYROLLCN" => Ok(Self::Integratedpayrollcn),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for JournalSourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for JournalSourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for JournalSourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Journals
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Journals": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Journal"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "journals"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Journals {
        #[serde(rename = "Journals", default, skip_serializing_if = "Vec::is_empty")]
        pub journals: Vec<Journal>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Journals> for Journals {
        fn from(value: &Journals) -> Self {
            value.clone()
        }
    }

    ///Line amounts are exclusive of tax by default if you don’t specify this
    /// element. See Line Amount Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Line amounts are exclusive of tax by default if you
    /// don’t specify this element. See Line Amount Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "Exclusive",
    ///    "Inclusive",
    ///    "NoTax"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LineAmountTypes {
        Exclusive,
        Inclusive,
        NoTax,
    }

    impl From<&LineAmountTypes> for LineAmountTypes {
        fn from(value: &LineAmountTypes) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LineAmountTypes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exclusive => write!(f, "Exclusive"),
                Self::Inclusive => write!(f, "Inclusive"),
                Self::NoTax => write!(f, "NoTax"),
            }
        }
    }

    impl std::str::FromStr for LineAmountTypes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Exclusive" => Ok(Self::Exclusive),
                "Inclusive" => Ok(Self::Inclusive),
                "NoTax" => Ok(Self::NoTax),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LineItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "See Accounts",
    ///      "type": "string"
    ///    },
    ///    "AccountID": {
    ///      "description": "The associated account ID related to this line
    /// item",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Description": {
    ///      "description": "Description needs to be at least 1 char long. A
    /// line item with just a description (i.e no unit amount or quantity) can
    /// be created by specifying just a <Description> element that contains at
    /// least 1 character",
    ///      "type": "string"
    ///    },
    ///    "DiscountAmount": {
    ///      "description": "Discount amount being applied to a line item. Only
    /// supported on ACCREC invoices and quotes. ACCPAY invoices and credit
    /// notes in Xero do not support discounts.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "DiscountRate": {
    ///      "description": "Percentage discount being applied to a line item
    /// (only supported on  ACCREC invoices – ACC PAY invoices and credit notes
    /// in Xero do not support discounts",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Item": {
    ///      "$ref": "#/components/schemas/LineItemItem"
    ///    },
    ///    "ItemCode": {
    ///      "description": "See Items",
    ///      "type": "string"
    ///    },
    ///    "LineAmount": {
    ///      "description": "If you wish to omit either the Quantity or
    /// UnitAmount you can provide a LineAmount and Xero will calculate the
    /// missing amount for you. The line amount reflects the discounted price if
    /// either a DiscountRate or DiscountAmount has been used i.e. LineAmount =
    /// Quantity * Unit Amount * ((100 - DiscountRate)/100) or LineAmount =
    /// (Quantity * UnitAmount) - DiscountAmount",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "LineItemID": {
    ///      "description": "LineItem unique ID",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Quantity": {
    ///      "description": "LineItem Quantity",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "RepeatingInvoiceID": {
    ///      "description": "The Xero identifier for a Repeating Invoice",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SalesTaxCodeId": {
    ///      "description": "The ID of the sales tax code",
    ///      "type": "number"
    ///    },
    ///    "TaxAmount": {
    ///      "description": "The tax amount is auto calculated as a percentage
    /// of the line amount (see below) based on the tax rate. This value can be
    /// overriden if the calculated <TaxAmount> is not correct.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TaxBreakdown": {
    ///      "description": "An array of tax components defined for this line
    /// item",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaxBreakdownComponent"
    ///      }
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type from TaxRates",
    ///      "type": "string"
    ///    },
    ///    "Taxability": {
    ///      "description": "The type of taxability",
    ///      "type": "string",
    ///      "enum": [
    ///        "TAXABLE",
    ///        "NON_TAXABLE",
    ///        "EXEMPT",
    ///        "PART_TAXABLE",
    ///        "NOT_APPLICABLE"
    ///      ]
    ///    },
    ///    "Tracking": {
    ///      "description": "Optional Tracking Category – see Tracking.  Any
    /// LineItem can have a  maximum of 2 <TrackingCategory> elements.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItemTracking"
    ///      }
    ///    },
    ///    "UnitAmount": {
    ///      "description": "LineItem Unit Amount",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LineItem {
        ///See Accounts
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        ///The associated account ID related to this line item
        #[serde(rename = "AccountID", default, skip_serializing_if = "Option::is_none")]
        pub account_id: Option<uuid::Uuid>,
        ///Description needs to be at least 1 char long. A line item with just
        /// a description (i.e no unit amount or quantity) can be created by
        /// specifying just a <Description> element that contains at least 1
        /// character
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        #[serde(
            rename = "DiscountAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub discount_amount: Option<f64>,
        #[serde(
            rename = "DiscountRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub discount_rate: Option<f64>,
        #[serde(rename = "Item", default, skip_serializing_if = "Option::is_none")]
        pub item: Option<LineItemItem>,
        ///See Items
        #[serde(rename = "ItemCode", default, skip_serializing_if = "Option::is_none")]
        pub item_code: Option<String>,
        #[serde(
            rename = "LineAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount: Option<f64>,
        ///LineItem unique ID
        #[serde(
            rename = "LineItemID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_item_id: Option<uuid::Uuid>,
        #[serde(rename = "Quantity", default, skip_serializing_if = "Option::is_none")]
        pub quantity: Option<f64>,
        ///The Xero identifier for a Repeating Invoice
        #[serde(
            rename = "RepeatingInvoiceID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub repeating_invoice_id: Option<uuid::Uuid>,
        #[serde(
            rename = "SalesTaxCodeId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_tax_code_id: Option<f64>,
        #[serde(rename = "TaxAmount", default, skip_serializing_if = "Option::is_none")]
        pub tax_amount: Option<f64>,
        ///An array of tax components defined for this line item
        #[serde(
            rename = "TaxBreakdown",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tax_breakdown: Vec<TaxBreakdownComponent>,
        ///The tax type from TaxRates
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
        ///The type of taxability
        #[serde(
            rename = "Taxability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub taxability: Option<LineItemTaxability>,
        ///Optional Tracking Category – see Tracking.  Any LineItem can have a
        /// maximum of 2 <TrackingCategory> elements.
        #[serde(rename = "Tracking", default, skip_serializing_if = "Vec::is_empty")]
        pub tracking: Vec<LineItemTracking>,
        #[serde(
            rename = "UnitAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub unit_amount: Option<f64>,
    }

    impl From<&LineItem> for LineItem {
        fn from(value: &LineItem) -> Self {
            value.clone()
        }
    }

    ///LineItemItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Code": {
    ///      "description": "User defined item code (max length = 30)",
    ///      "type": "string",
    ///      "maxLength": 30
    ///    },
    ///    "ItemID": {
    ///      "description": "The Xero identifier for an Item",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Name": {
    ///      "description": "The name of the item (max length = 50)",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LineItemItem {
        ///User defined item code (max length = 30)
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<LineItemItemCode>,
        ///The Xero identifier for an Item
        #[serde(rename = "ItemID", default, skip_serializing_if = "Option::is_none")]
        pub item_id: Option<uuid::Uuid>,
        ///The name of the item (max length = 50)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<LineItemItemName>,
    }

    impl From<&LineItemItem> for LineItemItem {
        fn from(value: &LineItemItem) -> Self {
            value.clone()
        }
    }

    ///User defined item code (max length = 30)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "User defined item code (max length = 30)",
    ///  "type": "string",
    ///  "maxLength": 30
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct LineItemItemCode(String);
    impl ::std::ops::Deref for LineItemItemCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LineItemItemCode> for String {
        fn from(value: LineItemItemCode) -> Self {
            value.0
        }
    }

    impl From<&LineItemItemCode> for LineItemItemCode {
        fn from(value: &LineItemItemCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LineItemItemCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 30usize {
                return Err("longer than 30 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LineItemItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for LineItemItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for LineItemItemCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LineItemItemCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The name of the item (max length = 50)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the item (max length = 50)",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct LineItemItemName(String);
    impl ::std::ops::Deref for LineItemItemName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LineItemItemName> for String {
        fn from(value: LineItemItemName) -> Self {
            value.0
        }
    }

    impl From<&LineItemItemName> for LineItemItemName {
        fn from(value: &LineItemItemName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LineItemItemName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LineItemItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for LineItemItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for LineItemItemName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LineItemItemName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The type of taxability
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of taxability",
    ///  "type": "string",
    ///  "enum": [
    ///    "TAXABLE",
    ///    "NON_TAXABLE",
    ///    "EXEMPT",
    ///    "PART_TAXABLE",
    ///    "NOT_APPLICABLE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LineItemTaxability {
        #[serde(rename = "TAXABLE")]
        Taxable,
        #[serde(rename = "NON_TAXABLE")]
        NonTaxable,
        #[serde(rename = "EXEMPT")]
        Exempt,
        #[serde(rename = "PART_TAXABLE")]
        PartTaxable,
        #[serde(rename = "NOT_APPLICABLE")]
        NotApplicable,
    }

    impl From<&LineItemTaxability> for LineItemTaxability {
        fn from(value: &LineItemTaxability) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LineItemTaxability {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Taxable => write!(f, "TAXABLE"),
                Self::NonTaxable => write!(f, "NON_TAXABLE"),
                Self::Exempt => write!(f, "EXEMPT"),
                Self::PartTaxable => write!(f, "PART_TAXABLE"),
                Self::NotApplicable => write!(f, "NOT_APPLICABLE"),
            }
        }
    }

    impl std::str::FromStr for LineItemTaxability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TAXABLE" => Ok(Self::Taxable),
                "NON_TAXABLE" => Ok(Self::NonTaxable),
                "EXEMPT" => Ok(Self::Exempt),
                "PART_TAXABLE" => Ok(Self::PartTaxable),
                "NOT_APPLICABLE" => Ok(Self::NotApplicable),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LineItemTaxability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LineItemTaxability {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LineItemTaxability {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LineItemTracking
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Name": {
    ///      "description": "The name of the tracking category",
    ///      "examples": [
    ///        "Region"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "Option": {
    ///      "description": "See Tracking Options",
    ///      "examples": [
    ///        "North"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "TrackingCategoryID": {
    ///      "description": "The Xero identifier for a tracking category",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "TrackingOptionID": {
    ///      "description": "The Xero identifier for a tracking category
    /// option",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LineItemTracking {
        ///The name of the tracking category
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<LineItemTrackingName>,
        ///See Tracking Options
        #[serde(rename = "Option", default, skip_serializing_if = "Option::is_none")]
        pub option: Option<String>,
        ///The Xero identifier for a tracking category
        #[serde(
            rename = "TrackingCategoryID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_id: Option<uuid::Uuid>,
        ///The Xero identifier for a tracking category option
        #[serde(
            rename = "TrackingOptionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_option_id: Option<uuid::Uuid>,
    }

    impl From<&LineItemTracking> for LineItemTracking {
        fn from(value: &LineItemTracking) -> Self {
            value.clone()
        }
    }

    ///The name of the tracking category
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the tracking category",
    ///  "examples": [
    ///    "Region"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct LineItemTrackingName(String);
    impl ::std::ops::Deref for LineItemTrackingName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LineItemTrackingName> for String {
        fn from(value: LineItemTrackingName) -> Self {
            value.0
        }
    }

    impl From<&LineItemTrackingName> for LineItemTrackingName {
        fn from(value: &LineItemTrackingName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LineItemTrackingName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LineItemTrackingName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for LineItemTrackingName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for LineItemTrackingName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LineItemTrackingName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///LinkedTransaction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ContactID": {
    ///      "description": "Filter by the combination of ContactID and Status.
    /// Get all the linked transactions that have been assigned to a particular
    /// customer and have a particular status e.g. GET
    /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
    /// Status=APPROVED.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "LinkedTransactionID": {
    ///      "description": "The Xero identifier for an Linked Transaction
    /// e.g./LinkedTransactions/297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SourceLineItemID": {
    ///      "description": "The line item identifier from the source
    /// transaction.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SourceTransactionID": {
    ///      "description": "Filter by the SourceTransactionID. Get all the
    /// linked transactions created from a particular ACCPAY invoice",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "SourceTransactionTypeCode": {
    ///      "description": "The Type of the source tranasction. This will be
    /// ACCPAY if the linked transaction was created from an invoice and SPEND
    /// if it was created from a bank transaction.",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCPAY",
    ///        "SPEND"
    ///      ]
    ///    },
    ///    "Status": {
    ///      "description": "Filter by the combination of ContactID and Status.
    /// Get all the linked transactions that have been assigned to a particular
    /// customer and have a particular status e.g. GET
    /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
    /// Status=APPROVED.",
    ///      "type": "string",
    ///      "enum": [
    ///        "APPROVED",
    ///        "DRAFT",
    ///        "ONDRAFT",
    ///        "BILLED",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "TargetLineItemID": {
    ///      "description": "The line item identifier from the target
    /// transaction. It is possible  to link multiple billable expenses to the
    /// same TargetLineItemID.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "TargetTransactionID": {
    ///      "description": "Filter by the TargetTransactionID. Get all the
    /// linked transactions  allocated to a particular ACCREC invoice",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Type": {
    ///      "description": "This will always be BILLABLEEXPENSE. More types may
    /// be added in future.",
    ///      "type": "string",
    ///      "enum": [
    ///        "BILLABLEEXPENSE"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "The last modified date in UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedTransaction {
        ///Filter by the combination of ContactID and Status. Get all the
        /// linked transactions that have been assigned to a particular customer
        /// and have a particular status e.g. GET
        /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
        /// Status=APPROVED.
        #[serde(rename = "ContactID", default, skip_serializing_if = "Option::is_none")]
        pub contact_id: Option<uuid::Uuid>,
        ///The Xero identifier for an Linked Transaction
        /// e.g./LinkedTransactions/297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(
            rename = "LinkedTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub linked_transaction_id: Option<uuid::Uuid>,
        ///The line item identifier from the source transaction.
        #[serde(
            rename = "SourceLineItemID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_line_item_id: Option<uuid::Uuid>,
        ///Filter by the SourceTransactionID. Get all the linked transactions
        /// created from a particular ACCPAY invoice
        #[serde(
            rename = "SourceTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_transaction_id: Option<uuid::Uuid>,
        ///The Type of the source tranasction. This will be ACCPAY if the
        /// linked transaction was created from an invoice and SPEND if it was
        /// created from a bank transaction.
        #[serde(
            rename = "SourceTransactionTypeCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_transaction_type_code: Option<LinkedTransactionSourceTransactionTypeCode>,
        ///Filter by the combination of ContactID and Status. Get all the
        /// linked transactions that have been assigned to a particular customer
        /// and have a particular status e.g. GET
        /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
        /// Status=APPROVED.
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<LinkedTransactionStatus>,
        ///The line item identifier from the target transaction. It is possible
        /// to link multiple billable expenses to the same TargetLineItemID.
        #[serde(
            rename = "TargetLineItemID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_line_item_id: Option<uuid::Uuid>,
        ///Filter by the TargetTransactionID. Get all the linked transactions
        /// allocated to a particular ACCREC invoice
        #[serde(
            rename = "TargetTransactionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_transaction_id: Option<uuid::Uuid>,
        ///This will always be BILLABLEEXPENSE. More types may be added in
        /// future.
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<LinkedTransactionType>,
        ///The last modified date in UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&LinkedTransaction> for LinkedTransaction {
        fn from(value: &LinkedTransaction) -> Self {
            value.clone()
        }
    }

    ///The Type of the source tranasction. This will be ACCPAY if the linked
    /// transaction was created from an invoice and SPEND if it was created from
    /// a bank transaction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Type of the source tranasction. This will be ACCPAY
    /// if the linked transaction was created from an invoice and SPEND if it
    /// was created from a bank transaction.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCPAY",
    ///    "SPEND"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedTransactionSourceTransactionTypeCode {
        #[serde(rename = "ACCPAY")]
        Accpay,
        #[serde(rename = "SPEND")]
        Spend,
    }

    impl From<&LinkedTransactionSourceTransactionTypeCode>
        for LinkedTransactionSourceTransactionTypeCode
    {
        fn from(value: &LinkedTransactionSourceTransactionTypeCode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedTransactionSourceTransactionTypeCode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accpay => write!(f, "ACCPAY"),
                Self::Spend => write!(f, "SPEND"),
            }
        }
    }

    impl std::str::FromStr for LinkedTransactionSourceTransactionTypeCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCPAY" => Ok(Self::Accpay),
                "SPEND" => Ok(Self::Spend),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LinkedTransactionSourceTransactionTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LinkedTransactionSourceTransactionTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LinkedTransactionSourceTransactionTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Filter by the combination of ContactID and Status. Get all the linked
    /// transactions that have been assigned to a particular customer and have a
    /// particular status e.g. GET
    /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
    /// Status=APPROVED.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Filter by the combination of ContactID and Status. Get
    /// all the linked transactions that have been assigned to a particular
    /// customer and have a particular status e.g. GET
    /// /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&
    /// Status=APPROVED.",
    ///  "type": "string",
    ///  "enum": [
    ///    "APPROVED",
    ///    "DRAFT",
    ///    "ONDRAFT",
    ///    "BILLED",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedTransactionStatus {
        #[serde(rename = "APPROVED")]
        Approved,
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "ONDRAFT")]
        Ondraft,
        #[serde(rename = "BILLED")]
        Billed,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&LinkedTransactionStatus> for LinkedTransactionStatus {
        fn from(value: &LinkedTransactionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedTransactionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Approved => write!(f, "APPROVED"),
                Self::Draft => write!(f, "DRAFT"),
                Self::Ondraft => write!(f, "ONDRAFT"),
                Self::Billed => write!(f, "BILLED"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for LinkedTransactionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "APPROVED" => Ok(Self::Approved),
                "DRAFT" => Ok(Self::Draft),
                "ONDRAFT" => Ok(Self::Ondraft),
                "BILLED" => Ok(Self::Billed),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LinkedTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LinkedTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LinkedTransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///This will always be BILLABLEEXPENSE. More types may be added in future.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This will always be BILLABLEEXPENSE. More types may be
    /// added in future.",
    ///  "type": "string",
    ///  "enum": [
    ///    "BILLABLEEXPENSE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedTransactionType {
        #[serde(rename = "BILLABLEEXPENSE")]
        Billableexpense,
    }

    impl From<&LinkedTransactionType> for LinkedTransactionType {
        fn from(value: &LinkedTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Billableexpense => write!(f, "BILLABLEEXPENSE"),
            }
        }
    }

    impl std::str::FromStr for LinkedTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BILLABLEEXPENSE" => Ok(Self::Billableexpense),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LinkedTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LinkedTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LinkedTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LinkedTransactions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "LinkedTransactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LinkedTransaction"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "linked_transactions"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedTransactions {
        #[serde(
            rename = "LinkedTransactions",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub linked_transactions: Vec<LinkedTransaction>,
    }

    impl From<&LinkedTransactions> for LinkedTransactions {
        fn from(value: &LinkedTransactions) -> Self {
            value.clone()
        }
    }

    ///ManualJournal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Narration"
    ///  ],
    ///  "properties": {
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "Date": {
    ///      "description": "Date journal was posted – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "Boolean to indicate if a manual journal has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "JournalLines": {
    ///      "description": "See JournalLines",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ManualJournalLine"
    ///      }
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "ManualJournalID": {
    ///      "description": "The Xero identifier for a Manual Journal",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Narration": {
    ///      "description": "Description of journal being posted",
    ///      "type": "string"
    ///    },
    ///    "ShowOnCashBasisReports": {
    ///      "description": "Boolean – default is true if not specified",
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "See Manual Journal Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "POSTED",
    ///        "DELETED",
    ///        "VOIDED",
    ///        "ARCHIVED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "examples": [
    ///        "ERROR"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "Url": {
    ///      "description": "Url link to a source document – shown as “Go to
    /// [appName]” in the Xero app",
    ///      "type": "string"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManualJournal {
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        ///Date journal was posted – YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Boolean to indicate if a manual journal has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///See JournalLines
        #[serde(
            rename = "JournalLines",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub journal_lines: Vec<ManualJournalLine>,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///The Xero identifier for a Manual Journal
        #[serde(
            rename = "ManualJournalID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub manual_journal_id: Option<uuid::Uuid>,
        ///Description of journal being posted
        #[serde(rename = "Narration")]
        pub narration: String,
        ///Boolean – default is true if not specified
        #[serde(
            rename = "ShowOnCashBasisReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub show_on_cash_basis_reports: Option<bool>,
        ///See Manual Journal Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ManualJournalStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Url link to a source document – shown as “Go to [appName]” in the
        /// Xero app
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&ManualJournal> for ManualJournal {
        fn from(value: &ManualJournal) -> Self {
            value.clone()
        }
    }

    ///ManualJournalLine
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "See Accounts",
    ///      "examples": [
    ///        720
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "AccountID": {
    ///      "description": "See Accounts",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Description": {
    ///      "description": "Description for journal line",
    ///      "examples": [
    ///        "Coded incorrectly Office Equipment should be Computer Equipment"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "IsBlank": {
    ///      "description": "is the line blank",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmount": {
    ///      "description": "total for line. Debits are positive, credits are
    /// negative value",
    ///      "examples": [
    ///        -2569.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TaxAmount": {
    ///      "description": "The calculated tax amount based on the TaxType and
    /// LineAmount",
    ///      "examples": [
    ///        0.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type from TaxRates",
    ///      "type": "string"
    ///    },
    ///    "Tracking": {
    ///      "description": "Optional Tracking Category – see Tracking. Any
    /// JournalLine can have a maximum of 2 <TrackingCategory> elements.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingCategory"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManualJournalLine {
        ///See Accounts
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        ///See Accounts
        #[serde(rename = "AccountID", default, skip_serializing_if = "Option::is_none")]
        pub account_id: Option<uuid::Uuid>,
        ///Description for journal line
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        ///is the line blank
        #[serde(rename = "IsBlank", default, skip_serializing_if = "Option::is_none")]
        pub is_blank: Option<bool>,
        #[serde(
            rename = "LineAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount: Option<f64>,
        #[serde(rename = "TaxAmount", default, skip_serializing_if = "Option::is_none")]
        pub tax_amount: Option<f64>,
        ///The tax type from TaxRates
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
        ///Optional Tracking Category – see Tracking. Any JournalLine can have
        /// a maximum of 2 <TrackingCategory> elements.
        #[serde(rename = "Tracking", default, skip_serializing_if = "Vec::is_empty")]
        pub tracking: Vec<TrackingCategory>,
    }

    impl From<&ManualJournalLine> for ManualJournalLine {
        fn from(value: &ManualJournalLine) -> Self {
            value.clone()
        }
    }

    ///See Manual Journal Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Manual Journal Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "POSTED",
    ///    "DELETED",
    ///    "VOIDED",
    ///    "ARCHIVED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ManualJournalStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "POSTED")]
        Posted,
        #[serde(rename = "DELETED")]
        Deleted,
        #[serde(rename = "VOIDED")]
        Voided,
        #[serde(rename = "ARCHIVED")]
        Archived,
    }

    impl From<&ManualJournalStatus> for ManualJournalStatus {
        fn from(value: &ManualJournalStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ManualJournalStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Posted => write!(f, "POSTED"),
                Self::Deleted => write!(f, "DELETED"),
                Self::Voided => write!(f, "VOIDED"),
                Self::Archived => write!(f, "ARCHIVED"),
            }
        }
    }

    impl std::str::FromStr for ManualJournalStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "POSTED" => Ok(Self::Posted),
                "DELETED" => Ok(Self::Deleted),
                "VOIDED" => Ok(Self::Voided),
                "ARCHIVED" => Ok(Self::Archived),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ManualJournalStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ManualJournalStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ManualJournalStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///ManualJournals
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ManualJournals": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ManualJournal"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "manual_journals"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManualJournals {
        #[serde(
            rename = "ManualJournals",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub manual_journals: Vec<ManualJournal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&ManualJournals> for ManualJournals {
        fn from(value: &ManualJournals) -> Self {
            value.clone()
        }
    }

    ///OnlineInvoice
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "OnlineInvoiceUrl": {
    ///      "description": "the URL to an online invoice",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OnlineInvoice {
        ///the URL to an online invoice
        #[serde(
            rename = "OnlineInvoiceUrl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub online_invoice_url: Option<String>,
    }

    impl From<&OnlineInvoice> for OnlineInvoice {
        fn from(value: &OnlineInvoice) -> Self {
            value.clone()
        }
    }

    ///OnlineInvoices
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "OnlineInvoices": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OnlineInvoice"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "online_invoices"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OnlineInvoices {
        #[serde(
            rename = "OnlineInvoices",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub online_invoices: Vec<OnlineInvoice>,
    }

    impl From<&OnlineInvoices> for OnlineInvoices {
        fn from(value: &OnlineInvoices) -> Self {
            value.clone()
        }
    }

    ///Organisation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "APIKey": {
    ///      "description": "Display a unique key used for Xero-to-Xero
    /// transactions",
    ///      "type": "string"
    ///    },
    ///    "Addresses": {
    ///      "description": "Address details for organisation – see Addresses",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressForOrganisation"
    ///      }
    ///    },
    ///    "BaseCurrency": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "Class": {
    ///      "description": "Organisation Classes describe which plan the Xero
    /// organisation is on (e.g. DEMO, TRIAL, PREMIUM)",
    ///      "type": "string",
    ///      "enum": [
    ///        "DEMO",
    ///        "TRIAL",
    ///        "STARTER",
    ///        "STANDARD",
    ///        "PREMIUM",
    ///        "PREMIUM_20",
    ///        "PREMIUM_50",
    ///        "PREMIUM_100",
    ///        "LEDGER",
    ///        "GST_CASHBOOK",
    ///        "NON_GST_CASHBOOK",
    ///        "ULTIMATE",
    ///        "LITE",
    ///        "ULTIMATE_10",
    ///        "ULTIMATE_20",
    ///        "ULTIMATE_50",
    ///        "ULTIMATE_100",
    ///        "IGNITE",
    ///        "GROW",
    ///        "COMPREHENSIVE"
    ///      ]
    ///    },
    ///    "CountryCode": {
    ///      "$ref": "#/components/schemas/CountryCode"
    ///    },
    ///    "CreatedDateUTC": {
    ///      "description": "Timestamp when the organisation was created in
    /// Xero",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "DefaultPurchasesTax": {
    ///      "description": "The default for LineAmountTypes on purchase
    /// transactions",
    ///      "type": "string"
    ///    },
    ///    "DefaultSalesTax": {
    ///      "description": "The default for LineAmountTypes on sales
    /// transactions",
    ///      "type": "string"
    ///    },
    ///    "Edition": {
    ///      "description": "BUSINESS or PARTNER. Partner edition organisations
    /// are sold exclusively through accounting partners and have restricted
    /// functionality (e.g. no access to invoicing)",
    ///      "type": "string",
    ///      "enum": [
    ///        "BUSINESS",
    ///        "PARTNER"
    ///      ]
    ///    },
    ///    "EmployerIdentificationNumber": {
    ///      "description": "Shown if set. US Only.",
    ///      "type": "string"
    ///    },
    ///    "EndOfYearLockDate": {
    ///      "description": "Shown if set. See lock dates",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "ExternalLinks": {
    ///      "description": "Organisation profile links for popular services
    /// such as Facebook,Twitter, GooglePlus and LinkedIn. You can also add link
    /// to your website here. Shown if Organisation settings  is updated in
    /// Xero. See ExternalLinks below",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalLink"
    ///      }
    ///    },
    ///    "FinancialYearEndDay": {
    ///      "description": "Calendar day e.g. 0-31",
    ///      "type": "integer"
    ///    },
    ///    "FinancialYearEndMonth": {
    ///      "description": "Calendar Month e.g. 1-12",
    ///      "type": "integer"
    ///    },
    ///    "IsDemoCompany": {
    ///      "description": "Boolean to describe if organisation is a demo
    /// company.",
    ///      "type": "boolean"
    ///    },
    ///    "LegalName": {
    ///      "description": "Organisation name shown on Reports",
    ///      "type": "string"
    ///    },
    ///    "LineOfBusiness": {
    ///      "description": "Description of business type as defined in
    /// Organisation settings",
    ///      "type": "string"
    ///    },
    ///    "Name": {
    ///      "description": "Display name of organisation shown in Xero",
    ///      "type": "string"
    ///    },
    ///    "OrganisationEntityType": {
    ///      "description": "Organisation Entity Type",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCOUNTING_PRACTICE",
    ///        "COMPANY",
    ///        "CHARITY",
    ///        "CLUB_OR_SOCIETY",
    ///        "INDIVIDUAL",
    ///        "LOOK_THROUGH_COMPANY",
    ///        "NOT_FOR_PROFIT",
    ///        "PARTNERSHIP",
    ///        "S_CORPORATION",
    ///        "SELF_MANAGED_SUPERANNUATION_FUND",
    ///        "SOLE_TRADER",
    ///        "SUPERANNUATION_FUND",
    ///        "TRUST"
    ///      ]
    ///    },
    ///    "OrganisationID": {
    ///      "description": "Unique Xero identifier",
    ///      "examples": [
    ///        "8be9db36-3598-4755-ba5c-c2dbc8c4a7a2"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "OrganisationStatus": {
    ///      "description": "Will be set to ACTIVE if you can connect to
    /// organisation via the Xero API",
    ///      "type": "string"
    ///    },
    ///    "OrganisationType": {
    ///      "description": "Organisation Type",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCOUNTING_PRACTICE",
    ///        "COMPANY",
    ///        "CHARITY",
    ///        "CLUB_OR_SOCIETY",
    ///        "INDIVIDUAL",
    ///        "LOOK_THROUGH_COMPANY",
    ///        "NOT_FOR_PROFIT",
    ///        "PARTNERSHIP",
    ///        "S_CORPORATION",
    ///        "SELF_MANAGED_SUPERANNUATION_FUND",
    ///        "SOLE_TRADER",
    ///        "SUPERANNUATION_FUND",
    ///        "TRUST"
    ///      ]
    ///    },
    ///    "PaymentTerms": {
    ///      "$ref": "#/components/schemas/PaymentTerm"
    ///    },
    ///    "PaysTax": {
    ///      "description": "Boolean to describe if organisation is registered
    /// with a local tax authority i.e. true, false",
    ///      "type": "boolean"
    ///    },
    ///    "PeriodLockDate": {
    ///      "description": "Shown if set. See lock dates",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Phones": {
    ///      "description": "Phones details for organisation – see Phones",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Phone"
    ///      }
    ///    },
    ///    "RegistrationNumber": {
    ///      "description": "Shows for New Zealand, Australian and UK
    /// organisations",
    ///      "type": "string"
    ///    },
    ///    "SalesTaxBasis": {
    ///      "description": "The accounting basis used for tax returns. See
    /// Sales Tax Basis",
    ///      "type": "string",
    ///      "enum": [
    ///        "PAYMENTS",
    ///        "INVOICE",
    ///        "NONE",
    ///        "CASH",
    ///        "ACCRUAL",
    ///        "FLATRATECASH",
    ///        "FLATRATEACCRUAL",
    ///        "ACCRUALS"
    ///      ]
    ///    },
    ///    "SalesTaxPeriod": {
    ///      "description": "The frequency with which tax returns are processed.
    /// See Sales Tax Period",
    ///      "type": "string",
    ///      "enum": [
    ///        "MONTHLY",
    ///        "QUARTERLY1",
    ///        "QUARTERLY2",
    ///        "QUARTERLY3",
    ///        "ANNUALLY",
    ///        "ONEMONTHS",
    ///        "TWOMONTHS",
    ///        "SIXMONTHS",
    ///        "1MONTHLY",
    ///        "2MONTHLY",
    ///        "3MONTHLY",
    ///        "6MONTHLY",
    ///        "QUARTERLY",
    ///        "YEARLY",
    ///        "NONE"
    ///      ]
    ///    },
    ///    "ShortCode": {
    ///      "description": "A unique identifier for the organisation. Potential
    /// uses.",
    ///      "type": "string"
    ///    },
    ///    "TaxNumber": {
    ///      "description": "Shown if set. Displays in the Xero UI as Tax File
    /// Number (AU), GST Number (NZ), VAT Number (UK) and Tax ID Number (US &
    /// Global).",
    ///      "type": "string"
    ///    },
    ///    "Timezone": {
    ///      "$ref": "#/components/schemas/TimeZone"
    ///    },
    ///    "Version": {
    ///      "description": "See Version Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "AU",
    ///        "NZ",
    ///        "GLOBAL",
    ///        "UK",
    ///        "US",
    ///        "AUONRAMP",
    ///        "NZONRAMP",
    ///        "GLOBALONRAMP",
    ///        "UKONRAMP",
    ///        "USONRAMP"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Organisation {
        ///Address details for organisation – see Addresses
        #[serde(rename = "Addresses", default, skip_serializing_if = "Vec::is_empty")]
        pub addresses: Vec<AddressForOrganisation>,
        ///Display a unique key used for Xero-to-Xero transactions
        #[serde(rename = "APIKey", default, skip_serializing_if = "Option::is_none")]
        pub api_key: Option<String>,
        #[serde(
            rename = "BaseCurrency",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub base_currency: Option<CurrencyCode>,
        ///Organisation Classes describe which plan the Xero organisation is on
        /// (e.g. DEMO, TRIAL, PREMIUM)
        #[serde(rename = "Class", default, skip_serializing_if = "Option::is_none")]
        pub class: Option<OrganisationClass>,
        #[serde(
            rename = "CountryCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub country_code: Option<CountryCode>,
        ///Timestamp when the organisation was created in Xero
        #[serde(
            rename = "CreatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub created_date_utc: Option<String>,
        ///The default for LineAmountTypes on purchase transactions
        #[serde(
            rename = "DefaultPurchasesTax",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub default_purchases_tax: Option<String>,
        ///The default for LineAmountTypes on sales transactions
        #[serde(
            rename = "DefaultSalesTax",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub default_sales_tax: Option<String>,
        ///BUSINESS or PARTNER. Partner edition organisations are sold
        /// exclusively through accounting partners and have restricted
        /// functionality (e.g. no access to invoicing)
        #[serde(rename = "Edition", default, skip_serializing_if = "Option::is_none")]
        pub edition: Option<OrganisationEdition>,
        ///Shown if set. US Only.
        #[serde(
            rename = "EmployerIdentificationNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub employer_identification_number: Option<String>,
        ///Shown if set. See lock dates
        #[serde(
            rename = "EndOfYearLockDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub end_of_year_lock_date: Option<String>,
        ///Organisation profile links for popular services such as
        /// Facebook,Twitter, GooglePlus and LinkedIn. You can also add link to
        /// your website here. Shown if Organisation settings  is updated in
        /// Xero. See ExternalLinks below
        #[serde(
            rename = "ExternalLinks",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub external_links: Vec<ExternalLink>,
        ///Calendar day e.g. 0-31
        #[serde(
            rename = "FinancialYearEndDay",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub financial_year_end_day: Option<i64>,
        ///Calendar Month e.g. 1-12
        #[serde(
            rename = "FinancialYearEndMonth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub financial_year_end_month: Option<i64>,
        ///Boolean to describe if organisation is a demo company.
        #[serde(
            rename = "IsDemoCompany",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_demo_company: Option<bool>,
        ///Organisation name shown on Reports
        #[serde(rename = "LegalName", default, skip_serializing_if = "Option::is_none")]
        pub legal_name: Option<String>,
        ///Description of business type as defined in Organisation settings
        #[serde(
            rename = "LineOfBusiness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_of_business: Option<String>,
        ///Display name of organisation shown in Xero
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///Organisation Entity Type
        #[serde(
            rename = "OrganisationEntityType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation_entity_type: Option<OrganisationOrganisationEntityType>,
        ///Unique Xero identifier
        #[serde(
            rename = "OrganisationID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation_id: Option<uuid::Uuid>,
        ///Will be set to ACTIVE if you can connect to organisation via the
        /// Xero API
        #[serde(
            rename = "OrganisationStatus",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation_status: Option<String>,
        ///Organisation Type
        #[serde(
            rename = "OrganisationType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation_type: Option<OrganisationOrganisationType>,
        #[serde(
            rename = "PaymentTerms",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_terms: Option<PaymentTerm>,
        ///Boolean to describe if organisation is registered with a local tax
        /// authority i.e. true, false
        #[serde(rename = "PaysTax", default, skip_serializing_if = "Option::is_none")]
        pub pays_tax: Option<bool>,
        ///Shown if set. See lock dates
        #[serde(
            rename = "PeriodLockDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub period_lock_date: Option<String>,
        ///Phones details for organisation – see Phones
        #[serde(rename = "Phones", default, skip_serializing_if = "Vec::is_empty")]
        pub phones: Vec<Phone>,
        ///Shows for New Zealand, Australian and UK organisations
        #[serde(
            rename = "RegistrationNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub registration_number: Option<String>,
        ///The accounting basis used for tax returns. See Sales Tax Basis
        #[serde(
            rename = "SalesTaxBasis",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_tax_basis: Option<OrganisationSalesTaxBasis>,
        ///The frequency with which tax returns are processed. See Sales Tax
        /// Period
        #[serde(
            rename = "SalesTaxPeriod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sales_tax_period: Option<OrganisationSalesTaxPeriod>,
        ///A unique identifier for the organisation. Potential uses.
        #[serde(rename = "ShortCode", default, skip_serializing_if = "Option::is_none")]
        pub short_code: Option<String>,
        ///Shown if set. Displays in the Xero UI as Tax File Number (AU), GST
        /// Number (NZ), VAT Number (UK) and Tax ID Number (US & Global).
        #[serde(rename = "TaxNumber", default, skip_serializing_if = "Option::is_none")]
        pub tax_number: Option<String>,
        #[serde(rename = "Timezone", default, skip_serializing_if = "Option::is_none")]
        pub timezone: Option<TimeZone>,
        ///See Version Types
        #[serde(rename = "Version", default, skip_serializing_if = "Option::is_none")]
        pub version: Option<OrganisationVersion>,
    }

    impl From<&Organisation> for Organisation {
        fn from(value: &Organisation) -> Self {
            value.clone()
        }
    }

    ///Organisation Classes describe which plan the Xero organisation is on
    /// (e.g. DEMO, TRIAL, PREMIUM)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Organisation Classes describe which plan the Xero
    /// organisation is on (e.g. DEMO, TRIAL, PREMIUM)",
    ///  "type": "string",
    ///  "enum": [
    ///    "DEMO",
    ///    "TRIAL",
    ///    "STARTER",
    ///    "STANDARD",
    ///    "PREMIUM",
    ///    "PREMIUM_20",
    ///    "PREMIUM_50",
    ///    "PREMIUM_100",
    ///    "LEDGER",
    ///    "GST_CASHBOOK",
    ///    "NON_GST_CASHBOOK",
    ///    "ULTIMATE",
    ///    "LITE",
    ///    "ULTIMATE_10",
    ///    "ULTIMATE_20",
    ///    "ULTIMATE_50",
    ///    "ULTIMATE_100",
    ///    "IGNITE",
    ///    "GROW",
    ///    "COMPREHENSIVE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationClass {
        #[serde(rename = "DEMO")]
        Demo,
        #[serde(rename = "TRIAL")]
        Trial,
        #[serde(rename = "STARTER")]
        Starter,
        #[serde(rename = "STANDARD")]
        Standard,
        #[serde(rename = "PREMIUM")]
        Premium,
        #[serde(rename = "PREMIUM_20")]
        Premium20,
        #[serde(rename = "PREMIUM_50")]
        Premium50,
        #[serde(rename = "PREMIUM_100")]
        Premium100,
        #[serde(rename = "LEDGER")]
        Ledger,
        #[serde(rename = "GST_CASHBOOK")]
        GstCashbook,
        #[serde(rename = "NON_GST_CASHBOOK")]
        NonGstCashbook,
        #[serde(rename = "ULTIMATE")]
        Ultimate,
        #[serde(rename = "LITE")]
        Lite,
        #[serde(rename = "ULTIMATE_10")]
        Ultimate10,
        #[serde(rename = "ULTIMATE_20")]
        Ultimate20,
        #[serde(rename = "ULTIMATE_50")]
        Ultimate50,
        #[serde(rename = "ULTIMATE_100")]
        Ultimate100,
        #[serde(rename = "IGNITE")]
        Ignite,
        #[serde(rename = "GROW")]
        Grow,
        #[serde(rename = "COMPREHENSIVE")]
        Comprehensive,
    }

    impl From<&OrganisationClass> for OrganisationClass {
        fn from(value: &OrganisationClass) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationClass {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Demo => write!(f, "DEMO"),
                Self::Trial => write!(f, "TRIAL"),
                Self::Starter => write!(f, "STARTER"),
                Self::Standard => write!(f, "STANDARD"),
                Self::Premium => write!(f, "PREMIUM"),
                Self::Premium20 => write!(f, "PREMIUM_20"),
                Self::Premium50 => write!(f, "PREMIUM_50"),
                Self::Premium100 => write!(f, "PREMIUM_100"),
                Self::Ledger => write!(f, "LEDGER"),
                Self::GstCashbook => write!(f, "GST_CASHBOOK"),
                Self::NonGstCashbook => write!(f, "NON_GST_CASHBOOK"),
                Self::Ultimate => write!(f, "ULTIMATE"),
                Self::Lite => write!(f, "LITE"),
                Self::Ultimate10 => write!(f, "ULTIMATE_10"),
                Self::Ultimate20 => write!(f, "ULTIMATE_20"),
                Self::Ultimate50 => write!(f, "ULTIMATE_50"),
                Self::Ultimate100 => write!(f, "ULTIMATE_100"),
                Self::Ignite => write!(f, "IGNITE"),
                Self::Grow => write!(f, "GROW"),
                Self::Comprehensive => write!(f, "COMPREHENSIVE"),
            }
        }
    }

    impl std::str::FromStr for OrganisationClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DEMO" => Ok(Self::Demo),
                "TRIAL" => Ok(Self::Trial),
                "STARTER" => Ok(Self::Starter),
                "STANDARD" => Ok(Self::Standard),
                "PREMIUM" => Ok(Self::Premium),
                "PREMIUM_20" => Ok(Self::Premium20),
                "PREMIUM_50" => Ok(Self::Premium50),
                "PREMIUM_100" => Ok(Self::Premium100),
                "LEDGER" => Ok(Self::Ledger),
                "GST_CASHBOOK" => Ok(Self::GstCashbook),
                "NON_GST_CASHBOOK" => Ok(Self::NonGstCashbook),
                "ULTIMATE" => Ok(Self::Ultimate),
                "LITE" => Ok(Self::Lite),
                "ULTIMATE_10" => Ok(Self::Ultimate10),
                "ULTIMATE_20" => Ok(Self::Ultimate20),
                "ULTIMATE_50" => Ok(Self::Ultimate50),
                "ULTIMATE_100" => Ok(Self::Ultimate100),
                "IGNITE" => Ok(Self::Ignite),
                "GROW" => Ok(Self::Grow),
                "COMPREHENSIVE" => Ok(Self::Comprehensive),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///BUSINESS or PARTNER. Partner edition organisations are sold exclusively
    /// through accounting partners and have restricted functionality (e.g. no
    /// access to invoicing)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "BUSINESS or PARTNER. Partner edition organisations are
    /// sold exclusively through accounting partners and have restricted
    /// functionality (e.g. no access to invoicing)",
    ///  "type": "string",
    ///  "enum": [
    ///    "BUSINESS",
    ///    "PARTNER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationEdition {
        #[serde(rename = "BUSINESS")]
        Business,
        #[serde(rename = "PARTNER")]
        Partner,
    }

    impl From<&OrganisationEdition> for OrganisationEdition {
        fn from(value: &OrganisationEdition) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationEdition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Business => write!(f, "BUSINESS"),
                Self::Partner => write!(f, "PARTNER"),
            }
        }
    }

    impl std::str::FromStr for OrganisationEdition {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BUSINESS" => Ok(Self::Business),
                "PARTNER" => Ok(Self::Partner),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationEdition {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationEdition {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationEdition {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Organisation Entity Type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Organisation Entity Type",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCOUNTING_PRACTICE",
    ///    "COMPANY",
    ///    "CHARITY",
    ///    "CLUB_OR_SOCIETY",
    ///    "INDIVIDUAL",
    ///    "LOOK_THROUGH_COMPANY",
    ///    "NOT_FOR_PROFIT",
    ///    "PARTNERSHIP",
    ///    "S_CORPORATION",
    ///    "SELF_MANAGED_SUPERANNUATION_FUND",
    ///    "SOLE_TRADER",
    ///    "SUPERANNUATION_FUND",
    ///    "TRUST"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationOrganisationEntityType {
        #[serde(rename = "ACCOUNTING_PRACTICE")]
        AccountingPractice,
        #[serde(rename = "COMPANY")]
        Company,
        #[serde(rename = "CHARITY")]
        Charity,
        #[serde(rename = "CLUB_OR_SOCIETY")]
        ClubOrSociety,
        #[serde(rename = "INDIVIDUAL")]
        Individual,
        #[serde(rename = "LOOK_THROUGH_COMPANY")]
        LookThroughCompany,
        #[serde(rename = "NOT_FOR_PROFIT")]
        NotForProfit,
        #[serde(rename = "PARTNERSHIP")]
        Partnership,
        #[serde(rename = "S_CORPORATION")]
        SCorporation,
        #[serde(rename = "SELF_MANAGED_SUPERANNUATION_FUND")]
        SelfManagedSuperannuationFund,
        #[serde(rename = "SOLE_TRADER")]
        SoleTrader,
        #[serde(rename = "SUPERANNUATION_FUND")]
        SuperannuationFund,
        #[serde(rename = "TRUST")]
        Trust,
    }

    impl From<&OrganisationOrganisationEntityType> for OrganisationOrganisationEntityType {
        fn from(value: &OrganisationOrganisationEntityType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationOrganisationEntityType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AccountingPractice => write!(f, "ACCOUNTING_PRACTICE"),
                Self::Company => write!(f, "COMPANY"),
                Self::Charity => write!(f, "CHARITY"),
                Self::ClubOrSociety => write!(f, "CLUB_OR_SOCIETY"),
                Self::Individual => write!(f, "INDIVIDUAL"),
                Self::LookThroughCompany => write!(f, "LOOK_THROUGH_COMPANY"),
                Self::NotForProfit => write!(f, "NOT_FOR_PROFIT"),
                Self::Partnership => write!(f, "PARTNERSHIP"),
                Self::SCorporation => write!(f, "S_CORPORATION"),
                Self::SelfManagedSuperannuationFund => {
                    write!(f, "SELF_MANAGED_SUPERANNUATION_FUND")
                }
                Self::SoleTrader => write!(f, "SOLE_TRADER"),
                Self::SuperannuationFund => write!(f, "SUPERANNUATION_FUND"),
                Self::Trust => write!(f, "TRUST"),
            }
        }
    }

    impl std::str::FromStr for OrganisationOrganisationEntityType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCOUNTING_PRACTICE" => Ok(Self::AccountingPractice),
                "COMPANY" => Ok(Self::Company),
                "CHARITY" => Ok(Self::Charity),
                "CLUB_OR_SOCIETY" => Ok(Self::ClubOrSociety),
                "INDIVIDUAL" => Ok(Self::Individual),
                "LOOK_THROUGH_COMPANY" => Ok(Self::LookThroughCompany),
                "NOT_FOR_PROFIT" => Ok(Self::NotForProfit),
                "PARTNERSHIP" => Ok(Self::Partnership),
                "S_CORPORATION" => Ok(Self::SCorporation),
                "SELF_MANAGED_SUPERANNUATION_FUND" => Ok(Self::SelfManagedSuperannuationFund),
                "SOLE_TRADER" => Ok(Self::SoleTrader),
                "SUPERANNUATION_FUND" => Ok(Self::SuperannuationFund),
                "TRUST" => Ok(Self::Trust),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationOrganisationEntityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationOrganisationEntityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationOrganisationEntityType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Organisation Type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Organisation Type",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCOUNTING_PRACTICE",
    ///    "COMPANY",
    ///    "CHARITY",
    ///    "CLUB_OR_SOCIETY",
    ///    "INDIVIDUAL",
    ///    "LOOK_THROUGH_COMPANY",
    ///    "NOT_FOR_PROFIT",
    ///    "PARTNERSHIP",
    ///    "S_CORPORATION",
    ///    "SELF_MANAGED_SUPERANNUATION_FUND",
    ///    "SOLE_TRADER",
    ///    "SUPERANNUATION_FUND",
    ///    "TRUST"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationOrganisationType {
        #[serde(rename = "ACCOUNTING_PRACTICE")]
        AccountingPractice,
        #[serde(rename = "COMPANY")]
        Company,
        #[serde(rename = "CHARITY")]
        Charity,
        #[serde(rename = "CLUB_OR_SOCIETY")]
        ClubOrSociety,
        #[serde(rename = "INDIVIDUAL")]
        Individual,
        #[serde(rename = "LOOK_THROUGH_COMPANY")]
        LookThroughCompany,
        #[serde(rename = "NOT_FOR_PROFIT")]
        NotForProfit,
        #[serde(rename = "PARTNERSHIP")]
        Partnership,
        #[serde(rename = "S_CORPORATION")]
        SCorporation,
        #[serde(rename = "SELF_MANAGED_SUPERANNUATION_FUND")]
        SelfManagedSuperannuationFund,
        #[serde(rename = "SOLE_TRADER")]
        SoleTrader,
        #[serde(rename = "SUPERANNUATION_FUND")]
        SuperannuationFund,
        #[serde(rename = "TRUST")]
        Trust,
    }

    impl From<&OrganisationOrganisationType> for OrganisationOrganisationType {
        fn from(value: &OrganisationOrganisationType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationOrganisationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AccountingPractice => write!(f, "ACCOUNTING_PRACTICE"),
                Self::Company => write!(f, "COMPANY"),
                Self::Charity => write!(f, "CHARITY"),
                Self::ClubOrSociety => write!(f, "CLUB_OR_SOCIETY"),
                Self::Individual => write!(f, "INDIVIDUAL"),
                Self::LookThroughCompany => write!(f, "LOOK_THROUGH_COMPANY"),
                Self::NotForProfit => write!(f, "NOT_FOR_PROFIT"),
                Self::Partnership => write!(f, "PARTNERSHIP"),
                Self::SCorporation => write!(f, "S_CORPORATION"),
                Self::SelfManagedSuperannuationFund => {
                    write!(f, "SELF_MANAGED_SUPERANNUATION_FUND")
                }
                Self::SoleTrader => write!(f, "SOLE_TRADER"),
                Self::SuperannuationFund => write!(f, "SUPERANNUATION_FUND"),
                Self::Trust => write!(f, "TRUST"),
            }
        }
    }

    impl std::str::FromStr for OrganisationOrganisationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCOUNTING_PRACTICE" => Ok(Self::AccountingPractice),
                "COMPANY" => Ok(Self::Company),
                "CHARITY" => Ok(Self::Charity),
                "CLUB_OR_SOCIETY" => Ok(Self::ClubOrSociety),
                "INDIVIDUAL" => Ok(Self::Individual),
                "LOOK_THROUGH_COMPANY" => Ok(Self::LookThroughCompany),
                "NOT_FOR_PROFIT" => Ok(Self::NotForProfit),
                "PARTNERSHIP" => Ok(Self::Partnership),
                "S_CORPORATION" => Ok(Self::SCorporation),
                "SELF_MANAGED_SUPERANNUATION_FUND" => Ok(Self::SelfManagedSuperannuationFund),
                "SOLE_TRADER" => Ok(Self::SoleTrader),
                "SUPERANNUATION_FUND" => Ok(Self::SuperannuationFund),
                "TRUST" => Ok(Self::Trust),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationOrganisationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationOrganisationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationOrganisationType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The accounting basis used for tax returns. See Sales Tax Basis
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The accounting basis used for tax returns. See Sales
    /// Tax Basis",
    ///  "type": "string",
    ///  "enum": [
    ///    "PAYMENTS",
    ///    "INVOICE",
    ///    "NONE",
    ///    "CASH",
    ///    "ACCRUAL",
    ///    "FLATRATECASH",
    ///    "FLATRATEACCRUAL",
    ///    "ACCRUALS"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationSalesTaxBasis {
        #[serde(rename = "PAYMENTS")]
        Payments,
        #[serde(rename = "INVOICE")]
        Invoice,
        #[serde(rename = "NONE")]
        None,
        #[serde(rename = "CASH")]
        Cash,
        #[serde(rename = "ACCRUAL")]
        Accrual,
        #[serde(rename = "FLATRATECASH")]
        Flatratecash,
        #[serde(rename = "FLATRATEACCRUAL")]
        Flatrateaccrual,
        #[serde(rename = "ACCRUALS")]
        Accruals,
    }

    impl From<&OrganisationSalesTaxBasis> for OrganisationSalesTaxBasis {
        fn from(value: &OrganisationSalesTaxBasis) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationSalesTaxBasis {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Payments => write!(f, "PAYMENTS"),
                Self::Invoice => write!(f, "INVOICE"),
                Self::None => write!(f, "NONE"),
                Self::Cash => write!(f, "CASH"),
                Self::Accrual => write!(f, "ACCRUAL"),
                Self::Flatratecash => write!(f, "FLATRATECASH"),
                Self::Flatrateaccrual => write!(f, "FLATRATEACCRUAL"),
                Self::Accruals => write!(f, "ACCRUALS"),
            }
        }
    }

    impl std::str::FromStr for OrganisationSalesTaxBasis {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PAYMENTS" => Ok(Self::Payments),
                "INVOICE" => Ok(Self::Invoice),
                "NONE" => Ok(Self::None),
                "CASH" => Ok(Self::Cash),
                "ACCRUAL" => Ok(Self::Accrual),
                "FLATRATECASH" => Ok(Self::Flatratecash),
                "FLATRATEACCRUAL" => Ok(Self::Flatrateaccrual),
                "ACCRUALS" => Ok(Self::Accruals),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationSalesTaxBasis {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationSalesTaxBasis {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationSalesTaxBasis {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The frequency with which tax returns are processed. See Sales Tax Period
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The frequency with which tax returns are processed. See
    /// Sales Tax Period",
    ///  "type": "string",
    ///  "enum": [
    ///    "MONTHLY",
    ///    "QUARTERLY1",
    ///    "QUARTERLY2",
    ///    "QUARTERLY3",
    ///    "ANNUALLY",
    ///    "ONEMONTHS",
    ///    "TWOMONTHS",
    ///    "SIXMONTHS",
    ///    "1MONTHLY",
    ///    "2MONTHLY",
    ///    "3MONTHLY",
    ///    "6MONTHLY",
    ///    "QUARTERLY",
    ///    "YEARLY",
    ///    "NONE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationSalesTaxPeriod {
        #[serde(rename = "MONTHLY")]
        Monthly,
        #[serde(rename = "QUARTERLY1")]
        Quarterly1,
        #[serde(rename = "QUARTERLY2")]
        Quarterly2,
        #[serde(rename = "QUARTERLY3")]
        Quarterly3,
        #[serde(rename = "ANNUALLY")]
        Annually,
        #[serde(rename = "ONEMONTHS")]
        Onemonths,
        #[serde(rename = "TWOMONTHS")]
        Twomonths,
        #[serde(rename = "SIXMONTHS")]
        Sixmonths,
        #[serde(rename = "1MONTHLY")]
        _1monthly,
        #[serde(rename = "2MONTHLY")]
        _2monthly,
        #[serde(rename = "3MONTHLY")]
        _3monthly,
        #[serde(rename = "6MONTHLY")]
        _6monthly,
        #[serde(rename = "QUARTERLY")]
        Quarterly,
        #[serde(rename = "YEARLY")]
        Yearly,
        #[serde(rename = "NONE")]
        None,
    }

    impl From<&OrganisationSalesTaxPeriod> for OrganisationSalesTaxPeriod {
        fn from(value: &OrganisationSalesTaxPeriod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationSalesTaxPeriod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Monthly => write!(f, "MONTHLY"),
                Self::Quarterly1 => write!(f, "QUARTERLY1"),
                Self::Quarterly2 => write!(f, "QUARTERLY2"),
                Self::Quarterly3 => write!(f, "QUARTERLY3"),
                Self::Annually => write!(f, "ANNUALLY"),
                Self::Onemonths => write!(f, "ONEMONTHS"),
                Self::Twomonths => write!(f, "TWOMONTHS"),
                Self::Sixmonths => write!(f, "SIXMONTHS"),
                Self::_1monthly => write!(f, "1MONTHLY"),
                Self::_2monthly => write!(f, "2MONTHLY"),
                Self::_3monthly => write!(f, "3MONTHLY"),
                Self::_6monthly => write!(f, "6MONTHLY"),
                Self::Quarterly => write!(f, "QUARTERLY"),
                Self::Yearly => write!(f, "YEARLY"),
                Self::None => write!(f, "NONE"),
            }
        }
    }

    impl std::str::FromStr for OrganisationSalesTaxPeriod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MONTHLY" => Ok(Self::Monthly),
                "QUARTERLY1" => Ok(Self::Quarterly1),
                "QUARTERLY2" => Ok(Self::Quarterly2),
                "QUARTERLY3" => Ok(Self::Quarterly3),
                "ANNUALLY" => Ok(Self::Annually),
                "ONEMONTHS" => Ok(Self::Onemonths),
                "TWOMONTHS" => Ok(Self::Twomonths),
                "SIXMONTHS" => Ok(Self::Sixmonths),
                "1MONTHLY" => Ok(Self::_1monthly),
                "2MONTHLY" => Ok(Self::_2monthly),
                "3MONTHLY" => Ok(Self::_3monthly),
                "6MONTHLY" => Ok(Self::_6monthly),
                "QUARTERLY" => Ok(Self::Quarterly),
                "YEARLY" => Ok(Self::Yearly),
                "NONE" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationSalesTaxPeriod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationSalesTaxPeriod {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationSalesTaxPeriod {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Version Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Version Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "AU",
    ///    "NZ",
    ///    "GLOBAL",
    ///    "UK",
    ///    "US",
    ///    "AUONRAMP",
    ///    "NZONRAMP",
    ///    "GLOBALONRAMP",
    ///    "UKONRAMP",
    ///    "USONRAMP"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganisationVersion {
        #[serde(rename = "AU")]
        Au,
        #[serde(rename = "NZ")]
        Nz,
        #[serde(rename = "GLOBAL")]
        Global,
        #[serde(rename = "UK")]
        Uk,
        #[serde(rename = "US")]
        Us,
        #[serde(rename = "AUONRAMP")]
        Auonramp,
        #[serde(rename = "NZONRAMP")]
        Nzonramp,
        #[serde(rename = "GLOBALONRAMP")]
        Globalonramp,
        #[serde(rename = "UKONRAMP")]
        Ukonramp,
        #[serde(rename = "USONRAMP")]
        Usonramp,
    }

    impl From<&OrganisationVersion> for OrganisationVersion {
        fn from(value: &OrganisationVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganisationVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Au => write!(f, "AU"),
                Self::Nz => write!(f, "NZ"),
                Self::Global => write!(f, "GLOBAL"),
                Self::Uk => write!(f, "UK"),
                Self::Us => write!(f, "US"),
                Self::Auonramp => write!(f, "AUONRAMP"),
                Self::Nzonramp => write!(f, "NZONRAMP"),
                Self::Globalonramp => write!(f, "GLOBALONRAMP"),
                Self::Ukonramp => write!(f, "UKONRAMP"),
                Self::Usonramp => write!(f, "USONRAMP"),
            }
        }
    }

    impl std::str::FromStr for OrganisationVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AU" => Ok(Self::Au),
                "NZ" => Ok(Self::Nz),
                "GLOBAL" => Ok(Self::Global),
                "UK" => Ok(Self::Uk),
                "US" => Ok(Self::Us),
                "AUONRAMP" => Ok(Self::Auonramp),
                "NZONRAMP" => Ok(Self::Nzonramp),
                "GLOBALONRAMP" => Ok(Self::Globalonramp),
                "UKONRAMP" => Ok(Self::Ukonramp),
                "USONRAMP" => Ok(Self::Usonramp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganisationVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganisationVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganisationVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Organisations
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Organisations": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Organisation"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "organisations"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Organisations {
        #[serde(
            rename = "Organisations",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub organisations: Vec<Organisation>,
    }

    impl From<&Organisations> for Organisations {
        fn from(value: &Organisations) -> Self {
            value.clone()
        }
    }

    ///Overpayment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Allocations": {
    ///      "description": "See Allocations",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Allocation"
    ///      }
    ///    },
    ///    "AppliedAmount": {
    ///      "description": "The amount of applied to an invoice",
    ///      "examples": [
    ///        2.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "Attachments": {
    ///      "description": "See Attachments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency overpayment.
    /// If no rate is specified, the XE.com day rate is used",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "The date the overpayment is created YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if a overpayment has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See Overpayment Line Items",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "OverpaymentID": {
    ///      "description": "Xero generated unique identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Payments": {
    ///      "description": "See Payments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "RemainingCredit": {
    ///      "description": "The remaining credit balance on the overpayment",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Status": {
    ///      "description": "See Overpayment Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "AUTHORISED",
    ///        "PAID",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "SubTotal": {
    ///      "description": "The subtotal of the overpayment excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "The total of the overpayment (subtotal + total
    /// tax)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "The total tax on the overpayment",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Overpayment Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "RECEIVE-OVERPAYMENT",
    ///        "SPEND-OVERPAYMENT",
    ///        "AROVERPAYMENT"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to the overpayment",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Overpayment {
        ///See Allocations
        #[serde(rename = "Allocations", default, skip_serializing_if = "Vec::is_empty")]
        pub allocations: Vec<Allocation>,
        #[serde(
            rename = "AppliedAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub applied_amount: Option<f64>,
        ///See Attachments
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///The date the overpayment is created YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///boolean to indicate if a overpayment has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See Overpayment Line Items
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///Xero generated unique identifier
        #[serde(
            rename = "OverpaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub overpayment_id: Option<uuid::Uuid>,
        ///See Payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        #[serde(
            rename = "RemainingCredit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remaining_credit: Option<f64>,
        ///See Overpayment Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<OverpaymentStatus>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Overpayment Types
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<OverpaymentType>,
        ///UTC timestamp of last update to the overpayment
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
    }

    impl From<&Overpayment> for Overpayment {
        fn from(value: &Overpayment) -> Self {
            value.clone()
        }
    }

    ///See Overpayment Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Overpayment Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORISED",
    ///    "PAID",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OverpaymentStatus {
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "PAID")]
        Paid,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&OverpaymentStatus> for OverpaymentStatus {
        fn from(value: &OverpaymentStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OverpaymentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Paid => write!(f, "PAID"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for OverpaymentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORISED" => Ok(Self::Authorised),
                "PAID" => Ok(Self::Paid),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OverpaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OverpaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OverpaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Overpayment Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Overpayment Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "RECEIVE-OVERPAYMENT",
    ///    "SPEND-OVERPAYMENT",
    ///    "AROVERPAYMENT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OverpaymentType {
        #[serde(rename = "RECEIVE-OVERPAYMENT")]
        ReceiveOverpayment,
        #[serde(rename = "SPEND-OVERPAYMENT")]
        SpendOverpayment,
        #[serde(rename = "AROVERPAYMENT")]
        Aroverpayment,
    }

    impl From<&OverpaymentType> for OverpaymentType {
        fn from(value: &OverpaymentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OverpaymentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ReceiveOverpayment => write!(f, "RECEIVE-OVERPAYMENT"),
                Self::SpendOverpayment => write!(f, "SPEND-OVERPAYMENT"),
                Self::Aroverpayment => write!(f, "AROVERPAYMENT"),
            }
        }
    }

    impl std::str::FromStr for OverpaymentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "RECEIVE-OVERPAYMENT" => Ok(Self::ReceiveOverpayment),
                "SPEND-OVERPAYMENT" => Ok(Self::SpendOverpayment),
                "AROVERPAYMENT" => Ok(Self::Aroverpayment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OverpaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OverpaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OverpaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Overpayments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Overpayments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Overpayment"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "overpayments"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Overpayments {
        #[serde(
            rename = "Overpayments",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub overpayments: Vec<Overpayment>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Overpayments> for Overpayments {
        fn from(value: &Overpayments) -> Self {
            value.clone()
        }
    }

    ///Pagination
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "itemCount": {
    ///      "type": "integer"
    ///    },
    ///    "page": {
    ///      "type": "integer"
    ///    },
    ///    "pageCount": {
    ///      "type": "integer"
    ///    },
    ///    "pageSize": {
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Pagination {
        #[serde(rename = "itemCount", default, skip_serializing_if = "Option::is_none")]
        pub item_count: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub page: Option<i64>,
        #[serde(rename = "pageCount", default, skip_serializing_if = "Option::is_none")]
        pub page_count: Option<i64>,
        #[serde(rename = "pageSize", default, skip_serializing_if = "Option::is_none")]
        pub page_size: Option<i64>,
    }

    impl From<&Pagination> for Pagination {
        fn from(value: &Pagination) -> Self {
            value.clone()
        }
    }

    ///Payment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Account": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "Amount": {
    ///      "description": "The amount of the payment. Must be less than or
    /// equal to the outstanding amount owing on the invoice e.g. 200.00",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BankAccountNumber": {
    ///      "description": "The suppliers bank account number the payment is
    /// being made to",
    ///      "type": "string"
    ///    },
    ///    "BankAmount": {
    ///      "description": "The amount of the payment in the currency of the
    /// bank account.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BatchPayment": {
    ///      "$ref": "#/components/schemas/BatchPayment"
    ///    },
    ///    "BatchPaymentID": {
    ///      "description": "Present if the payment was created as part of a
    /// batch.",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Code": {
    ///      "description": "Code of account you are using to make the payment
    /// e.g. 001 (note- not all accounts have a code value)",
    ///      "type": "string"
    ///    },
    ///    "CreditNote": {
    ///      "$ref": "#/components/schemas/CreditNote"
    ///    },
    ///    "CreditNoteNumber": {
    ///      "description": "Number of invoice or credit note you are applying
    /// payment to e.g. INV-4003",
    ///      "type": "string"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "Exchange rate when payment is received. Only used
    /// for non base currency invoices and credit notes e.g. 0.7500",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "Date the payment is being made (YYYY-MM-DD) e.g.
    /// 2009-09-06",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Details": {
    ///      "description": "The information to appear on the supplier's bank
    /// account",
    ///      "type": "string"
    ///    },
    ///    "HasAccount": {
    ///      "description": "A boolean to indicate if a contact has an
    /// validation errors",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "HasValidationErrors": {
    ///      "description": "A boolean to indicate if a contact has an
    /// validation errors",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Invoice": {
    ///      "$ref": "#/components/schemas/Invoice"
    ///    },
    ///    "InvoiceNumber": {
    ///      "description": "Number of invoice or credit note you are applying
    /// payment to e.g.INV-4003",
    ///      "type": "string"
    ///    },
    ///    "IsReconciled": {
    ///      "description": "An optional parameter for the payment. A boolean
    /// indicating whether you would like the payment to be created as
    /// reconciled when using PUT, or whether a payment has been reconciled when
    /// using GET",
    ///      "type": "boolean"
    ///    },
    ///    "Overpayment": {
    ///      "$ref": "#/components/schemas/Overpayment"
    ///    },
    ///    "Particulars": {
    ///      "description": "The suppliers bank account number the payment is
    /// being made to",
    ///      "type": "string"
    ///    },
    ///    "PaymentID": {
    ///      "description": "The Xero identifier for an Payment e.g.
    /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "examples": [
    ///        "00000000-0000-0000-0000-000000000000"
    ///      ],
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PaymentType": {
    ///      "description": "See Payment Types.",
    ///      "readOnly": true,
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCRECPAYMENT",
    ///        "ACCPAYPAYMENT",
    ///        "ARCREDITPAYMENT",
    ///        "APCREDITPAYMENT",
    ///        "AROVERPAYMENTPAYMENT",
    ///        "ARPREPAYMENTPAYMENT",
    ///        "APPREPAYMENTPAYMENT",
    ///        "APOVERPAYMENTPAYMENT"
    ///      ]
    ///    },
    ///    "Prepayment": {
    ///      "$ref": "#/components/schemas/Prepayment"
    ///    },
    ///    "Reference": {
    ///      "description": "An optional description for the payment e.g. Direct
    /// Debit",
    ///      "type": "string"
    ///    },
    ///    "Status": {
    ///      "description": "The status of the payment.",
    ///      "type": "string",
    ///      "enum": [
    ///        "AUTHORISED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to the payment",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Payment {
        #[serde(rename = "Account", default, skip_serializing_if = "Option::is_none")]
        pub account: Option<Account>,
        #[serde(rename = "Amount", default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
        ///The suppliers bank account number the payment is being made to
        #[serde(
            rename = "BankAccountNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_account_number: Option<String>,
        #[serde(
            rename = "BankAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub bank_amount: Option<f64>,
        #[serde(
            rename = "BatchPayment",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub batch_payment: Option<BatchPayment>,
        ///Present if the payment was created as part of a batch.
        #[serde(
            rename = "BatchPaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub batch_payment_id: Option<uuid::Uuid>,
        ///Code of account you are using to make the payment e.g. 001 (note-
        /// not all accounts have a code value)
        #[serde(rename = "Code", default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(
            rename = "CreditNote",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note: Option<CreditNote>,
        ///Number of invoice or credit note you are applying payment to e.g.
        /// INV-4003
        #[serde(
            rename = "CreditNoteNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub credit_note_number: Option<String>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///Date the payment is being made (YYYY-MM-DD) e.g. 2009-09-06
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///The information to appear on the supplier's bank account
        #[serde(rename = "Details", default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        ///A boolean to indicate if a contact has an validation errors
        #[serde(rename = "HasAccount", default)]
        pub has_account: bool,
        ///A boolean to indicate if a contact has an validation errors
        #[serde(rename = "HasValidationErrors", default)]
        pub has_validation_errors: bool,
        #[serde(rename = "Invoice", default, skip_serializing_if = "Option::is_none")]
        pub invoice: Option<Invoice>,
        ///Number of invoice or credit note you are applying payment to
        /// e.g.INV-4003
        #[serde(
            rename = "InvoiceNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub invoice_number: Option<String>,
        ///An optional parameter for the payment. A boolean indicating whether
        /// you would like the payment to be created as reconciled when using
        /// PUT, or whether a payment has been reconciled when using GET
        #[serde(
            rename = "IsReconciled",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_reconciled: Option<bool>,
        #[serde(
            rename = "Overpayment",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub overpayment: Option<Overpayment>,
        ///The suppliers bank account number the payment is being made to
        #[serde(
            rename = "Particulars",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub particulars: Option<String>,
        ///The Xero identifier for an Payment e.g.
        /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(rename = "PaymentID", default, skip_serializing_if = "Option::is_none")]
        pub payment_id: Option<uuid::Uuid>,
        ///See Payment Types.
        #[serde(
            rename = "PaymentType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_type: Option<PaymentPaymentType>,
        #[serde(
            rename = "Prepayment",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prepayment: Option<Prepayment>,
        ///An optional description for the payment e.g. Direct Debit
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///The status of the payment.
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<PaymentStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        ///UTC timestamp of last update to the payment
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Payment> for Payment {
        fn from(value: &Payment) -> Self {
            value.clone()
        }
    }

    ///PaymentDelete
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "Status"
    ///  ],
    ///  "properties": {
    ///    "Status": {
    ///      "description": "The status of the payment.",
    ///      "default": "DELETED",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentDelete {
        ///The status of the payment.
        #[serde(rename = "Status")]
        pub status: String,
    }

    impl From<&PaymentDelete> for PaymentDelete {
        fn from(value: &PaymentDelete) -> Self {
            value.clone()
        }
    }

    ///See Payment Types.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Payment Types.",
    ///  "readOnly": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCRECPAYMENT",
    ///    "ACCPAYPAYMENT",
    ///    "ARCREDITPAYMENT",
    ///    "APCREDITPAYMENT",
    ///    "AROVERPAYMENTPAYMENT",
    ///    "ARPREPAYMENTPAYMENT",
    ///    "APPREPAYMENTPAYMENT",
    ///    "APOVERPAYMENTPAYMENT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentPaymentType {
        #[serde(rename = "ACCRECPAYMENT")]
        Accrecpayment,
        #[serde(rename = "ACCPAYPAYMENT")]
        Accpaypayment,
        #[serde(rename = "ARCREDITPAYMENT")]
        Arcreditpayment,
        #[serde(rename = "APCREDITPAYMENT")]
        Apcreditpayment,
        #[serde(rename = "AROVERPAYMENTPAYMENT")]
        Aroverpaymentpayment,
        #[serde(rename = "ARPREPAYMENTPAYMENT")]
        Arprepaymentpayment,
        #[serde(rename = "APPREPAYMENTPAYMENT")]
        Apprepaymentpayment,
        #[serde(rename = "APOVERPAYMENTPAYMENT")]
        Apoverpaymentpayment,
    }

    impl From<&PaymentPaymentType> for PaymentPaymentType {
        fn from(value: &PaymentPaymentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentPaymentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accrecpayment => write!(f, "ACCRECPAYMENT"),
                Self::Accpaypayment => write!(f, "ACCPAYPAYMENT"),
                Self::Arcreditpayment => write!(f, "ARCREDITPAYMENT"),
                Self::Apcreditpayment => write!(f, "APCREDITPAYMENT"),
                Self::Aroverpaymentpayment => write!(f, "AROVERPAYMENTPAYMENT"),
                Self::Arprepaymentpayment => write!(f, "ARPREPAYMENTPAYMENT"),
                Self::Apprepaymentpayment => write!(f, "APPREPAYMENTPAYMENT"),
                Self::Apoverpaymentpayment => write!(f, "APOVERPAYMENTPAYMENT"),
            }
        }
    }

    impl std::str::FromStr for PaymentPaymentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCRECPAYMENT" => Ok(Self::Accrecpayment),
                "ACCPAYPAYMENT" => Ok(Self::Accpaypayment),
                "ARCREDITPAYMENT" => Ok(Self::Arcreditpayment),
                "APCREDITPAYMENT" => Ok(Self::Apcreditpayment),
                "AROVERPAYMENTPAYMENT" => Ok(Self::Aroverpaymentpayment),
                "ARPREPAYMENTPAYMENT" => Ok(Self::Arprepaymentpayment),
                "APPREPAYMENTPAYMENT" => Ok(Self::Apprepaymentpayment),
                "APOVERPAYMENTPAYMENT" => Ok(Self::Apoverpaymentpayment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PaymentPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PaymentPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PaymentPaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///PaymentService
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "PayNowText": {
    ///      "description": "The text displayed on the Pay Now button in Xero
    /// Online Invoicing. If this is not set it will default to Pay by credit
    /// card",
    ///      "type": "string"
    ///    },
    ///    "PaymentServiceID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PaymentServiceName": {
    ///      "description": "Name of payment service",
    ///      "type": "string"
    ///    },
    ///    "PaymentServiceType": {
    ///      "description": "This will always be CUSTOM for payment services
    /// created via the API.",
    ///      "type": "string"
    ///    },
    ///    "PaymentServiceUrl": {
    ///      "description": "The custom payment URL",
    ///      "type": "string"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentService {
        ///The text displayed on the Pay Now button in Xero Online Invoicing.
        /// If this is not set it will default to Pay by credit card
        #[serde(
            rename = "PayNowText",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pay_now_text: Option<String>,
        ///Xero identifier
        #[serde(
            rename = "PaymentServiceID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_service_id: Option<uuid::Uuid>,
        ///Name of payment service
        #[serde(
            rename = "PaymentServiceName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_service_name: Option<String>,
        ///This will always be CUSTOM for payment services created via the API.
        #[serde(
            rename = "PaymentServiceType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_service_type: Option<String>,
        ///The custom payment URL
        #[serde(
            rename = "PaymentServiceUrl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub payment_service_url: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&PaymentService> for PaymentService {
        fn from(value: &PaymentService) -> Self {
            value.clone()
        }
    }

    ///PaymentServices
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "PaymentServices": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PaymentService"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "payment_services"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentServices {
        #[serde(
            rename = "PaymentServices",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub payment_services: Vec<PaymentService>,
    }

    impl From<&PaymentServices> for PaymentServices {
        fn from(value: &PaymentServices) -> Self {
            value.clone()
        }
    }

    ///The status of the payment.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the payment.",
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORISED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentStatus {
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&PaymentStatus> for PaymentStatus {
        fn from(value: &PaymentStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for PaymentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORISED" => Ok(Self::Authorised),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///PaymentTerm
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Bills": {
    ///      "$ref": "#/components/schemas/Bill"
    ///    },
    ///    "Sales": {
    ///      "$ref": "#/components/schemas/Bill"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentTerm {
        #[serde(rename = "Bills", default, skip_serializing_if = "Option::is_none")]
        pub bills: Option<Bill>,
        #[serde(rename = "Sales", default, skip_serializing_if = "Option::is_none")]
        pub sales: Option<Bill>,
    }

    impl From<&PaymentTerm> for PaymentTerm {
        fn from(value: &PaymentTerm) -> Self {
            value.clone()
        }
    }

    ///PaymentTermType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "DAYSAFTERBILLDATE",
    ///    "DAYSAFTERBILLMONTH",
    ///    "OFCURRENTMONTH",
    ///    "OFFOLLOWINGMONTH"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PaymentTermType {
        #[serde(rename = "DAYSAFTERBILLDATE")]
        Daysafterbilldate,
        #[serde(rename = "DAYSAFTERBILLMONTH")]
        Daysafterbillmonth,
        #[serde(rename = "OFCURRENTMONTH")]
        Ofcurrentmonth,
        #[serde(rename = "OFFOLLOWINGMONTH")]
        Offollowingmonth,
    }

    impl From<&PaymentTermType> for PaymentTermType {
        fn from(value: &PaymentTermType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaymentTermType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Daysafterbilldate => write!(f, "DAYSAFTERBILLDATE"),
                Self::Daysafterbillmonth => write!(f, "DAYSAFTERBILLMONTH"),
                Self::Ofcurrentmonth => write!(f, "OFCURRENTMONTH"),
                Self::Offollowingmonth => write!(f, "OFFOLLOWINGMONTH"),
            }
        }
    }

    impl std::str::FromStr for PaymentTermType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DAYSAFTERBILLDATE" => Ok(Self::Daysafterbilldate),
                "DAYSAFTERBILLMONTH" => Ok(Self::Daysafterbillmonth),
                "OFCURRENTMONTH" => Ok(Self::Ofcurrentmonth),
                "OFFOLLOWINGMONTH" => Ok(Self::Offollowingmonth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PaymentTermType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PaymentTermType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PaymentTermType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Payments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "payments"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Payments {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Payments> for Payments {
        fn from(value: &Payments) -> Self {
            value.clone()
        }
    }

    ///Phone
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "PhoneAreaCode": {
    ///      "description": "max length = 10",
    ///      "type": "string",
    ///      "maxLength": 10
    ///    },
    ///    "PhoneCountryCode": {
    ///      "description": "max length = 20",
    ///      "type": "string",
    ///      "maxLength": 20
    ///    },
    ///    "PhoneNumber": {
    ///      "description": "max length = 50",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "PhoneType": {
    ///      "type": "string",
    ///      "enum": [
    ///        "DEFAULT",
    ///        "DDI",
    ///        "MOBILE",
    ///        "FAX",
    ///        "OFFICE"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Phone {
        ///max length = 10
        #[serde(
            rename = "PhoneAreaCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub phone_area_code: Option<PhonePhoneAreaCode>,
        ///max length = 20
        #[serde(
            rename = "PhoneCountryCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub phone_country_code: Option<PhonePhoneCountryCode>,
        ///max length = 50
        #[serde(
            rename = "PhoneNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub phone_number: Option<PhonePhoneNumber>,
        #[serde(rename = "PhoneType", default, skip_serializing_if = "Option::is_none")]
        pub phone_type: Option<PhonePhoneType>,
    }

    impl From<&Phone> for Phone {
        fn from(value: &Phone) -> Self {
            value.clone()
        }
    }

    ///max length = 10
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 10",
    ///  "type": "string",
    ///  "maxLength": 10
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PhonePhoneAreaCode(String);
    impl ::std::ops::Deref for PhonePhoneAreaCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<PhonePhoneAreaCode> for String {
        fn from(value: PhonePhoneAreaCode) -> Self {
            value.0
        }
    }

    impl From<&PhonePhoneAreaCode> for PhonePhoneAreaCode {
        fn from(value: &PhonePhoneAreaCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PhonePhoneAreaCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 10usize {
                return Err("longer than 10 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PhonePhoneAreaCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for PhonePhoneAreaCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for PhonePhoneAreaCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PhonePhoneAreaCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 20
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 20",
    ///  "type": "string",
    ///  "maxLength": 20
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PhonePhoneCountryCode(String);
    impl ::std::ops::Deref for PhonePhoneCountryCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<PhonePhoneCountryCode> for String {
        fn from(value: PhonePhoneCountryCode) -> Self {
            value.0
        }
    }

    impl From<&PhonePhoneCountryCode> for PhonePhoneCountryCode {
        fn from(value: &PhonePhoneCountryCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PhonePhoneCountryCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 20usize {
                return Err("longer than 20 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PhonePhoneCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for PhonePhoneCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for PhonePhoneCountryCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PhonePhoneCountryCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///max length = 50
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "max length = 50",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PhonePhoneNumber(String);
    impl ::std::ops::Deref for PhonePhoneNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<PhonePhoneNumber> for String {
        fn from(value: PhonePhoneNumber) -> Self {
            value.0
        }
    }

    impl From<&PhonePhoneNumber> for PhonePhoneNumber {
        fn from(value: &PhonePhoneNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PhonePhoneNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PhonePhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for PhonePhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for PhonePhoneNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PhonePhoneNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///PhonePhoneType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "DEFAULT",
    ///    "DDI",
    ///    "MOBILE",
    ///    "FAX",
    ///    "OFFICE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PhonePhoneType {
        #[serde(rename = "DEFAULT")]
        Default,
        #[serde(rename = "DDI")]
        Ddi,
        #[serde(rename = "MOBILE")]
        Mobile,
        #[serde(rename = "FAX")]
        Fax,
        #[serde(rename = "OFFICE")]
        Office,
    }

    impl From<&PhonePhoneType> for PhonePhoneType {
        fn from(value: &PhonePhoneType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PhonePhoneType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Default => write!(f, "DEFAULT"),
                Self::Ddi => write!(f, "DDI"),
                Self::Mobile => write!(f, "MOBILE"),
                Self::Fax => write!(f, "FAX"),
                Self::Office => write!(f, "OFFICE"),
            }
        }
    }

    impl std::str::FromStr for PhonePhoneType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DEFAULT" => Ok(Self::Default),
                "DDI" => Ok(Self::Ddi),
                "MOBILE" => Ok(Self::Mobile),
                "FAX" => Ok(Self::Fax),
                "OFFICE" => Ok(Self::Office),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PhonePhoneType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PhonePhoneType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PhonePhoneType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Prepayment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Allocations": {
    ///      "description": "See Allocations",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Allocation"
    ///      }
    ///    },
    ///    "AppliedAmount": {
    ///      "description": "The amount of applied to an invoice",
    ///      "examples": [
    ///        2.0
    ///      ],
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "Attachments": {
    ///      "description": "See Attachments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency prepayment.
    /// If no rate is specified, the XE.com day rate is used",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "The date the prepayment is created YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if a prepayment has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See Prepayment Line Items",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "Payments": {
    ///      "description": "See Payments",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Payment"
    ///      }
    ///    },
    ///    "PrepaymentID": {
    ///      "description": "Xero generated unique identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Reference": {
    ///      "description": "Returns Invoice number field. Reference field isn't
    /// available.",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "RemainingCredit": {
    ///      "description": "The remaining credit balance on the prepayment",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Status": {
    ///      "description": "See Prepayment Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "AUTHORISED",
    ///        "PAID",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "SubTotal": {
    ///      "description": "The subtotal of the prepayment excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "The total of the prepayment(subtotal + total tax)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "The total tax on the prepayment",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Prepayment Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "RECEIVE-PREPAYMENT",
    ///        "SPEND-PREPAYMENT",
    ///        "ARPREPAYMENT",
    ///        "APPREPAYMENT"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "UTC timestamp of last update to the prepayment",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Prepayment {
        ///See Allocations
        #[serde(rename = "Allocations", default, skip_serializing_if = "Vec::is_empty")]
        pub allocations: Vec<Allocation>,
        #[serde(
            rename = "AppliedAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub applied_amount: Option<f64>,
        ///See Attachments
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///The date the prepayment is created YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///boolean to indicate if a prepayment has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See Prepayment Line Items
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///See Payments
        #[serde(rename = "Payments", default, skip_serializing_if = "Vec::is_empty")]
        pub payments: Vec<Payment>,
        ///Xero generated unique identifier
        #[serde(
            rename = "PrepaymentID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prepayment_id: Option<uuid::Uuid>,
        ///Returns Invoice number field. Reference field isn't available.
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        #[serde(
            rename = "RemainingCredit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remaining_credit: Option<f64>,
        ///See Prepayment Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<PrepaymentStatus>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Prepayment Types
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<PrepaymentType>,
        ///UTC timestamp of last update to the prepayment
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
    }

    impl From<&Prepayment> for Prepayment {
        fn from(value: &Prepayment) -> Self {
            value.clone()
        }
    }

    ///See Prepayment Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Prepayment Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORISED",
    ///    "PAID",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrepaymentStatus {
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "PAID")]
        Paid,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&PrepaymentStatus> for PrepaymentStatus {
        fn from(value: &PrepaymentStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PrepaymentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Paid => write!(f, "PAID"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for PrepaymentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORISED" => Ok(Self::Authorised),
                "PAID" => Ok(Self::Paid),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PrepaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PrepaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PrepaymentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Prepayment Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Prepayment Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "RECEIVE-PREPAYMENT",
    ///    "SPEND-PREPAYMENT",
    ///    "ARPREPAYMENT",
    ///    "APPREPAYMENT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrepaymentType {
        #[serde(rename = "RECEIVE-PREPAYMENT")]
        ReceivePrepayment,
        #[serde(rename = "SPEND-PREPAYMENT")]
        SpendPrepayment,
        #[serde(rename = "ARPREPAYMENT")]
        Arprepayment,
        #[serde(rename = "APPREPAYMENT")]
        Apprepayment,
    }

    impl From<&PrepaymentType> for PrepaymentType {
        fn from(value: &PrepaymentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PrepaymentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ReceivePrepayment => write!(f, "RECEIVE-PREPAYMENT"),
                Self::SpendPrepayment => write!(f, "SPEND-PREPAYMENT"),
                Self::Arprepayment => write!(f, "ARPREPAYMENT"),
                Self::Apprepayment => write!(f, "APPREPAYMENT"),
            }
        }
    }

    impl std::str::FromStr for PrepaymentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "RECEIVE-PREPAYMENT" => Ok(Self::ReceivePrepayment),
                "SPEND-PREPAYMENT" => Ok(Self::SpendPrepayment),
                "ARPREPAYMENT" => Ok(Self::Arprepayment),
                "APPREPAYMENT" => Ok(Self::Apprepayment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PrepaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PrepaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PrepaymentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Prepayments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Prepayments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Prepayment"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "prepayments"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Prepayments {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        #[serde(rename = "Prepayments", default, skip_serializing_if = "Vec::is_empty")]
        pub prepayments: Vec<Prepayment>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Prepayments> for Prepayments {
        fn from(value: &Prepayments) -> Self {
            value.clone()
        }
    }

    ///Purchase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "AccountCode": {
    ///      "description": "Default account code to be used for purchased/sale.
    /// Not applicable to the purchase details of tracked items",
    ///      "type": "string"
    ///    },
    ///    "COGSAccountCode": {
    ///      "description": "Cost of goods sold account. Only applicable to the
    /// purchase details of tracked items.",
    ///      "type": "string"
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type from TaxRates",
    ///      "type": "string"
    ///    },
    ///    "UnitPrice": {
    ///      "description": "Unit Price of the item. By default UnitPrice is
    /// rounded to two decimal places. You can use 4 decimal places by adding
    /// the unitdp=4 querystring parameter to your request.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Purchase {
        ///Default account code to be used for purchased/sale. Not applicable
        /// to the purchase details of tracked items
        #[serde(
            rename = "AccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub account_code: Option<String>,
        ///Cost of goods sold account. Only applicable to the purchase details
        /// of tracked items.
        #[serde(
            rename = "COGSAccountCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cogs_account_code: Option<String>,
        ///The tax type from TaxRates
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
        #[serde(rename = "UnitPrice", default, skip_serializing_if = "Option::is_none")]
        pub unit_price: Option<f64>,
    }

    impl From<&Purchase> for Purchase {
        fn from(value: &Purchase) -> Self {
            value.clone()
        }
    }

    ///PurchaseOrder
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "AttentionTo": {
    ///      "description": "The person that the delivery is going to",
    ///      "type": "string"
    ///    },
    ///    "BrandingThemeID": {
    ///      "description": "See BrandingThemes",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency purchase
    /// order. If no rate is specified, the XE.com day rate is used.",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Date": {
    ///      "description": "Date purchase order was issued – YYYY-MM-DD. If the
    /// Date element is not specified then it will default to the current date
    /// based on the timezone setting of the organisation",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DeliveryAddress": {
    ///      "description": "The address the goods are to be delivered to",
    ///      "type": "string"
    ///    },
    ///    "DeliveryDate": {
    ///      "description": "Date the goods are to be delivered – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DeliveryInstructions": {
    ///      "description": "A free text feild for instructions (500 characters
    /// max)",
    ///      "type": "string"
    ///    },
    ///    "ExpectedArrivalDate": {
    ///      "description": "The date the goods are expected to arrive.",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if a purchase order has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See LineItems",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "PurchaseOrderID": {
    ///      "description": "Xero generated unique identifier for purchase
    /// order",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "PurchaseOrderNumber": {
    ///      "description": "Unique alpha numeric code identifying purchase
    /// order (when missing will auto-generate from your Organisation Invoice
    /// Settings)",
    ///      "type": "string"
    ///    },
    ///    "Reference": {
    ///      "description": "Additional reference number",
    ///      "type": "string"
    ///    },
    ///    "SentToContact": {
    ///      "description": "Boolean to set whether the purchase order should be
    /// marked as “sent”. This can be set only on purchase orders that have been
    /// approved or billed",
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "See Purchase Order Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "SUBMITTED",
    ///        "AUTHORISED",
    ///        "BILLED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of purchase order excluding taxes",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Telephone": {
    ///      "description": "The phone number for the person accepting the
    /// delivery",
    ///      "type": "string"
    ///    },
    ///    "Total": {
    ///      "description": "Total of Purchase Order tax inclusive (i.e.
    /// SubTotal + TotalTax)",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalDiscount": {
    ///      "description": "Total of discounts applied on the purchase order
    /// line items",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on purchase order",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PurchaseOrder {
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        ///The person that the delivery is going to
        #[serde(
            rename = "AttentionTo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub attention_to: Option<String>,
        ///See BrandingThemes
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///Date purchase order was issued – YYYY-MM-DD. If the Date element is
        /// not specified then it will default to the current date based on the
        /// timezone setting of the organisation
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///The address the goods are to be delivered to
        #[serde(
            rename = "DeliveryAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub delivery_address: Option<String>,
        ///Date the goods are to be delivered – YYYY-MM-DD
        #[serde(
            rename = "DeliveryDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub delivery_date: Option<String>,
        ///A free text feild for instructions (500 characters max)
        #[serde(
            rename = "DeliveryInstructions",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub delivery_instructions: Option<String>,
        ///The date the goods are expected to arrive.
        #[serde(
            rename = "ExpectedArrivalDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expected_arrival_date: Option<String>,
        ///boolean to indicate if a purchase order has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See LineItems
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///Xero generated unique identifier for purchase order
        #[serde(
            rename = "PurchaseOrderID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchase_order_id: Option<uuid::Uuid>,
        ///Unique alpha numeric code identifying purchase order (when missing
        /// will auto-generate from your Organisation Invoice Settings)
        #[serde(
            rename = "PurchaseOrderNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub purchase_order_number: Option<String>,
        ///Additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///Boolean to set whether the purchase order should be marked as
        /// “sent”. This can be set only on purchase orders that have been
        /// approved or billed
        #[serde(
            rename = "SentToContact",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sent_to_contact: Option<bool>,
        ///See Purchase Order Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<PurchaseOrderStatus>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        ///The phone number for the person accepting the delivery
        #[serde(rename = "Telephone", default, skip_serializing_if = "Option::is_none")]
        pub telephone: Option<String>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(
            rename = "TotalDiscount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_discount: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&PurchaseOrder> for PurchaseOrder {
        fn from(value: &PurchaseOrder) -> Self {
            value.clone()
        }
    }

    ///See Purchase Order Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Purchase Order Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SUBMITTED",
    ///    "AUTHORISED",
    ///    "BILLED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PurchaseOrderStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "BILLED")]
        Billed,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&PurchaseOrderStatus> for PurchaseOrderStatus {
        fn from(value: &PurchaseOrderStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PurchaseOrderStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Billed => write!(f, "BILLED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for PurchaseOrderStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SUBMITTED" => Ok(Self::Submitted),
                "AUTHORISED" => Ok(Self::Authorised),
                "BILLED" => Ok(Self::Billed),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PurchaseOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PurchaseOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PurchaseOrderStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///PurchaseOrders
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "PurchaseOrders": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PurchaseOrder"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/Pagination"
    ///    }
    ///  },
    ///  "x-objectArrayKey": "purchase_orders"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PurchaseOrders {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pagination: Option<Pagination>,
        #[serde(
            rename = "PurchaseOrders",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub purchase_orders: Vec<PurchaseOrder>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&PurchaseOrders> for PurchaseOrders {
        fn from(value: &PurchaseOrders) -> Self {
            value.clone()
        }
    }

    ///Quote
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "BrandingThemeID": {
    ///      "description": "See BrandingThemes",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "CurrencyRate": {
    ///      "description": "The currency rate for a multicurrency quote",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "Date": {
    ///      "description": "Date quote was issued – YYYY-MM-DD. If the Date
    /// element is not specified it will default to the current date based on
    /// the timezone setting of the organisation",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "DateString": {
    ///      "description": "Date the quote was issued (YYYY-MM-DD)",
    ///      "type": "string"
    ///    },
    ///    "ExpiryDate": {
    ///      "description": "Date the quote expires – YYYY-MM-DD.",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "ExpiryDateString": {
    ///      "description": "Date the quote expires – YYYY-MM-DD.",
    ///      "type": "string"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/QuoteLineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See LineItems",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "QuoteID": {
    ///      "description": "QuoteID GUID is automatically generated and is
    /// returned after create or GET.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "QuoteNumber": {
    ///      "description": "Unique alpha numeric code identifying a quote (Max
    /// Length = 255)",
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "Reference": {
    ///      "description": "Additional reference number",
    ///      "type": "string",
    ///      "maxLength": 4000
    ///    },
    ///    "Status": {
    ///      "$ref": "#/components/schemas/QuoteStatusCodes"
    ///    },
    ///    "StatusAttributeString": {
    ///      "description": "A string to indicate if a invoice status",
    ///      "type": "string"
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of quote excluding taxes.",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Summary": {
    ///      "description": "Summary text for the quote",
    ///      "type": "string",
    ///      "maxLength": 3000
    ///    },
    ///    "Terms": {
    ///      "description": "Terms of the quote",
    ///      "type": "string",
    ///      "maxLength": 4000
    ///    },
    ///    "Title": {
    ///      "description": "Title text for the quote",
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "Total": {
    ///      "description": "Total of Quote tax inclusive (i.e. SubTotal +
    /// TotalTax). This will be ignored if it doesn’t equal the sum of the
    /// LineAmounts",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalDiscount": {
    ///      "description": "Total of discounts applied on the quote line
    /// items",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on quote",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Quote {
        ///See BrandingThemes
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        #[serde(
            rename = "CurrencyRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_rate: Option<f64>,
        ///Date quote was issued – YYYY-MM-DD. If the Date element is not
        /// specified it will default to the current date based on the timezone
        /// setting of the organisation
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///Date the quote was issued (YYYY-MM-DD)
        #[serde(
            rename = "DateString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub date_string: Option<String>,
        ///Date the quote expires – YYYY-MM-DD.
        #[serde(
            rename = "ExpiryDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expiry_date: Option<String>,
        ///Date the quote expires – YYYY-MM-DD.
        #[serde(
            rename = "ExpiryDateString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expiry_date_string: Option<String>,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<QuoteLineAmountTypes>,
        ///See LineItems
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///QuoteID GUID is automatically generated and is returned after create
        /// or GET.
        #[serde(rename = "QuoteID", default, skip_serializing_if = "Option::is_none")]
        pub quote_id: Option<uuid::Uuid>,
        ///Unique alpha numeric code identifying a quote (Max Length = 255)
        #[serde(
            rename = "QuoteNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub quote_number: Option<QuoteQuoteNumber>,
        ///Additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<QuoteReference>,
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<QuoteStatusCodes>,
        ///A string to indicate if a invoice status
        #[serde(
            rename = "StatusAttributeString",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub status_attribute_string: Option<String>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        ///Summary text for the quote
        #[serde(rename = "Summary", default, skip_serializing_if = "Option::is_none")]
        pub summary: Option<QuoteSummary>,
        ///Terms of the quote
        #[serde(rename = "Terms", default, skip_serializing_if = "Option::is_none")]
        pub terms: Option<QuoteTerms>,
        ///Title text for the quote
        #[serde(rename = "Title", default, skip_serializing_if = "Option::is_none")]
        pub title: Option<QuoteTitle>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(
            rename = "TotalDiscount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub total_discount: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
    }

    impl From<&Quote> for Quote {
        fn from(value: &Quote) -> Self {
            value.clone()
        }
    }

    ///Line amounts are exclusive of tax by default if you don’t specify this
    /// element. See Line Amount Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Line amounts are exclusive of tax by default if you
    /// don’t specify this element. See Line Amount Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "EXCLUSIVE",
    ///    "INCLUSIVE",
    ///    "NOTAX"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum QuoteLineAmountTypes {
        #[serde(rename = "EXCLUSIVE")]
        Exclusive,
        #[serde(rename = "INCLUSIVE")]
        Inclusive,
        #[serde(rename = "NOTAX")]
        Notax,
    }

    impl From<&QuoteLineAmountTypes> for QuoteLineAmountTypes {
        fn from(value: &QuoteLineAmountTypes) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for QuoteLineAmountTypes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Exclusive => write!(f, "EXCLUSIVE"),
                Self::Inclusive => write!(f, "INCLUSIVE"),
                Self::Notax => write!(f, "NOTAX"),
            }
        }
    }

    impl std::str::FromStr for QuoteLineAmountTypes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EXCLUSIVE" => Ok(Self::Exclusive),
                "INCLUSIVE" => Ok(Self::Inclusive),
                "NOTAX" => Ok(Self::Notax),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for QuoteLineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for QuoteLineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for QuoteLineAmountTypes {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Unique alpha numeric code identifying a quote (Max Length = 255)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique alpha numeric code identifying a quote (Max
    /// Length = 255)",
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct QuoteQuoteNumber(String);
    impl ::std::ops::Deref for QuoteQuoteNumber {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<QuoteQuoteNumber> for String {
        fn from(value: QuoteQuoteNumber) -> Self {
            value.0
        }
    }

    impl From<&QuoteQuoteNumber> for QuoteQuoteNumber {
        fn from(value: &QuoteQuoteNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for QuoteQuoteNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for QuoteQuoteNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for QuoteQuoteNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for QuoteQuoteNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for QuoteQuoteNumber {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Additional reference number
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional reference number",
    ///  "type": "string",
    ///  "maxLength": 4000
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct QuoteReference(String);
    impl ::std::ops::Deref for QuoteReference {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<QuoteReference> for String {
        fn from(value: QuoteReference) -> Self {
            value.0
        }
    }

    impl From<&QuoteReference> for QuoteReference {
        fn from(value: &QuoteReference) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for QuoteReference {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 4000usize {
                return Err("longer than 4000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for QuoteReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for QuoteReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for QuoteReference {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for QuoteReference {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The status of the quote.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of the quote.",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SENT",
    ///    "DECLINED",
    ///    "ACCEPTED",
    ///    "INVOICED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum QuoteStatusCodes {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SENT")]
        Sent,
        #[serde(rename = "DECLINED")]
        Declined,
        #[serde(rename = "ACCEPTED")]
        Accepted,
        #[serde(rename = "INVOICED")]
        Invoiced,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&QuoteStatusCodes> for QuoteStatusCodes {
        fn from(value: &QuoteStatusCodes) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for QuoteStatusCodes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Sent => write!(f, "SENT"),
                Self::Declined => write!(f, "DECLINED"),
                Self::Accepted => write!(f, "ACCEPTED"),
                Self::Invoiced => write!(f, "INVOICED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for QuoteStatusCodes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SENT" => Ok(Self::Sent),
                "DECLINED" => Ok(Self::Declined),
                "ACCEPTED" => Ok(Self::Accepted),
                "INVOICED" => Ok(Self::Invoiced),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for QuoteStatusCodes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for QuoteStatusCodes {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for QuoteStatusCodes {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Summary text for the quote
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summary text for the quote",
    ///  "type": "string",
    ///  "maxLength": 3000
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct QuoteSummary(String);
    impl ::std::ops::Deref for QuoteSummary {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<QuoteSummary> for String {
        fn from(value: QuoteSummary) -> Self {
            value.0
        }
    }

    impl From<&QuoteSummary> for QuoteSummary {
        fn from(value: &QuoteSummary) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for QuoteSummary {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 3000usize {
                return Err("longer than 3000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for QuoteSummary {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for QuoteSummary {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for QuoteSummary {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for QuoteSummary {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Terms of the quote
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Terms of the quote",
    ///  "type": "string",
    ///  "maxLength": 4000
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct QuoteTerms(String);
    impl ::std::ops::Deref for QuoteTerms {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<QuoteTerms> for String {
        fn from(value: QuoteTerms) -> Self {
            value.0
        }
    }

    impl From<&QuoteTerms> for QuoteTerms {
        fn from(value: &QuoteTerms) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for QuoteTerms {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 4000usize {
                return Err("longer than 4000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for QuoteTerms {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for QuoteTerms {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for QuoteTerms {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for QuoteTerms {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Title text for the quote
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Title text for the quote",
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct QuoteTitle(String);
    impl ::std::ops::Deref for QuoteTitle {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<QuoteTitle> for String {
        fn from(value: QuoteTitle) -> Self {
            value.0
        }
    }

    impl From<&QuoteTitle> for QuoteTitle {
        fn from(value: &QuoteTitle) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for QuoteTitle {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for QuoteTitle {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for QuoteTitle {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for QuoteTitle {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for QuoteTitle {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Quotes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Quotes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Quote"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "quotes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Quotes {
        #[serde(rename = "Quotes", default, skip_serializing_if = "Vec::is_empty")]
        pub quotes: Vec<Quote>,
    }

    impl From<&Quotes> for Quotes {
        fn from(value: &Quotes) -> Self {
            value.clone()
        }
    }

    ///Receipt
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "Date": {
    ///      "description": "Date of receipt – YYYY-MM-DD",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "HasAttachments": {
    ///      "description": "boolean to indicate if a receipt has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "ReceiptID": {
    ///      "description": "Xero generated unique identifier for receipt",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ReceiptNumber": {
    ///      "description": "Xero generated sequence number for receipt in
    /// current claim for a given user",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "Reference": {
    ///      "description": "Additional reference number",
    ///      "type": "string"
    ///    },
    ///    "Status": {
    ///      "description": "Current status of receipt – see status types",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "SUBMITTED",
    ///        "AUTHORISED",
    ///        "DECLINED",
    ///        "VOIDED"
    ///      ]
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of receipt excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "Total of receipt tax inclusive (i.e. SubTotal +
    /// TotalTax)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on receipt",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Last modified date UTC format",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "Url": {
    ///      "description": "URL link to a source document – shown as “Go to
    /// [appName]” in the Xero app",
    ///      "readOnly": true,
    ///      "type": "string"
    ///    },
    ///    "User": {
    ///      "$ref": "#/components/schemas/User"
    ///    },
    ///    "ValidationErrors": {
    ///      "description": "Displays array of validation error messages from
    /// the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    },
    ///    "Warnings": {
    ///      "description": "Displays array of warning messages from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Receipt {
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        ///Date of receipt – YYYY-MM-DD
        #[serde(rename = "Date", default, skip_serializing_if = "Option::is_none")]
        pub date: Option<String>,
        ///boolean to indicate if a receipt has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///Xero generated unique identifier for receipt
        #[serde(rename = "ReceiptID", default, skip_serializing_if = "Option::is_none")]
        pub receipt_id: Option<uuid::Uuid>,
        ///Xero generated sequence number for receipt in current claim for a
        /// given user
        #[serde(
            rename = "ReceiptNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub receipt_number: Option<String>,
        ///Additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///Current status of receipt – see status types
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<ReceiptStatus>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///Last modified date UTC format
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///URL link to a source document – shown as “Go to [appName]” in the
        /// Xero app
        #[serde(rename = "Url", default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[serde(rename = "User", default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
        ///Displays array of validation error messages from the API
        #[serde(
            rename = "ValidationErrors",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub validation_errors: Vec<ValidationError>,
        ///Displays array of warning messages from the API
        #[serde(rename = "Warnings", default, skip_serializing_if = "Vec::is_empty")]
        pub warnings: Vec<ValidationError>,
    }

    impl From<&Receipt> for Receipt {
        fn from(value: &Receipt) -> Self {
            value.clone()
        }
    }

    ///Current status of receipt – see status types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Current status of receipt – see status types",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "SUBMITTED",
    ///    "AUTHORISED",
    ///    "DECLINED",
    ///    "VOIDED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReceiptStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "SUBMITTED")]
        Submitted,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "DECLINED")]
        Declined,
        #[serde(rename = "VOIDED")]
        Voided,
    }

    impl From<&ReceiptStatus> for ReceiptStatus {
        fn from(value: &ReceiptStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ReceiptStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Submitted => write!(f, "SUBMITTED"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Declined => write!(f, "DECLINED"),
                Self::Voided => write!(f, "VOIDED"),
            }
        }
    }

    impl std::str::FromStr for ReceiptStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "SUBMITTED" => Ok(Self::Submitted),
                "AUTHORISED" => Ok(Self::Authorised),
                "DECLINED" => Ok(Self::Declined),
                "VOIDED" => Ok(Self::Voided),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReceiptStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReceiptStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReceiptStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Receipts
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Receipts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Receipt"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "receipts"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Receipts {
        #[serde(rename = "Receipts", default, skip_serializing_if = "Vec::is_empty")]
        pub receipts: Vec<Receipt>,
    }

    impl From<&Receipts> for Receipts {
        fn from(value: &Receipts) -> Self {
            value.clone()
        }
    }

    ///RepeatingInvoice
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ApprovedForSending": {
    ///      "description": "Boolean to indicate whether the invoice has been
    /// approved for sending",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Attachments": {
    ///      "description": "Displays array of attachments from the API",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Attachment"
    ///      }
    ///    },
    ///    "BrandingThemeID": {
    ///      "description": "See BrandingThemes",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Contact": {
    ///      "$ref": "#/components/schemas/Contact"
    ///    },
    ///    "CurrencyCode": {
    ///      "$ref": "#/components/schemas/CurrencyCode"
    ///    },
    ///    "HasAttachments": {
    ///      "description": "Boolean to indicate if an invoice has an
    /// attachment",
    ///      "default": false,
    ///      "readOnly": true,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "ID": {
    ///      "description": "Xero generated unique identifier for repeating
    /// invoice template",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "IncludePDF": {
    ///      "description": "Boolean to indicate whether to include PDF
    /// attachment",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "LineAmountTypes": {
    ///      "$ref": "#/components/schemas/LineAmountTypes"
    ///    },
    ///    "LineItems": {
    ///      "description": "See LineItems",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LineItem"
    ///      }
    ///    },
    ///    "MarkAsSent": {
    ///      "description": "Boolean to indicate whether the invoice in the Xero
    /// app displays as \"sent\"",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Reference": {
    ///      "description": "ACCREC only – additional reference number",
    ///      "type": "string"
    ///    },
    ///    "RepeatingInvoiceID": {
    ///      "description": "Xero generated unique identifier for repeating
    /// invoice template",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Schedule": {
    ///      "$ref": "#/components/schemas/Schedule"
    ///    },
    ///    "SendCopy": {
    ///      "description": "Boolean to indicate whether a copy is sent to
    /// sender's email",
    ///      "default": false,
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "Status": {
    ///      "description": "One of the following - DRAFT or AUTHORISED – See
    /// Invoice Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "DRAFT",
    ///        "AUTHORISED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "SubTotal": {
    ///      "description": "Total of invoice excluding taxes",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Total": {
    ///      "description": "Total of Invoice tax inclusive (i.e. SubTotal +
    /// TotalTax)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "TotalTax": {
    ///      "description": "Total tax on invoice",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Type": {
    ///      "description": "See Invoice Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACCPAY",
    ///        "ACCREC"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepeatingInvoice {
        ///Boolean to indicate whether the invoice has been approved for
        /// sending
        #[serde(rename = "ApprovedForSending", default)]
        pub approved_for_sending: bool,
        ///Displays array of attachments from the API
        #[serde(rename = "Attachments", default, skip_serializing_if = "Vec::is_empty")]
        pub attachments: Vec<Attachment>,
        ///See BrandingThemes
        #[serde(
            rename = "BrandingThemeID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub branding_theme_id: Option<uuid::Uuid>,
        #[serde(rename = "Contact", default, skip_serializing_if = "Option::is_none")]
        pub contact: Option<Contact>,
        #[serde(
            rename = "CurrencyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub currency_code: Option<CurrencyCode>,
        ///Boolean to indicate if an invoice has an attachment
        #[serde(rename = "HasAttachments", default)]
        pub has_attachments: bool,
        ///Xero generated unique identifier for repeating invoice template
        #[serde(rename = "ID", default, skip_serializing_if = "Option::is_none")]
        pub id: Option<uuid::Uuid>,
        ///Boolean to indicate whether to include PDF attachment
        #[serde(rename = "IncludePDF", default)]
        pub include_pdf: bool,
        #[serde(
            rename = "LineAmountTypes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub line_amount_types: Option<LineAmountTypes>,
        ///See LineItems
        #[serde(rename = "LineItems", default, skip_serializing_if = "Vec::is_empty")]
        pub line_items: Vec<LineItem>,
        ///Boolean to indicate whether the invoice in the Xero app displays as
        /// "sent"
        #[serde(rename = "MarkAsSent", default)]
        pub mark_as_sent: bool,
        ///ACCREC only – additional reference number
        #[serde(rename = "Reference", default, skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
        ///Xero generated unique identifier for repeating invoice template
        #[serde(
            rename = "RepeatingInvoiceID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub repeating_invoice_id: Option<uuid::Uuid>,
        #[serde(rename = "Schedule", default, skip_serializing_if = "Option::is_none")]
        pub schedule: Option<Schedule>,
        ///Boolean to indicate whether a copy is sent to sender's email
        #[serde(rename = "SendCopy", default)]
        pub send_copy: bool,
        ///One of the following - DRAFT or AUTHORISED – See Invoice Status
        /// Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<RepeatingInvoiceStatus>,
        #[serde(rename = "SubTotal", default, skip_serializing_if = "Option::is_none")]
        pub sub_total: Option<f64>,
        #[serde(rename = "Total", default, skip_serializing_if = "Option::is_none")]
        pub total: Option<f64>,
        #[serde(rename = "TotalTax", default, skip_serializing_if = "Option::is_none")]
        pub total_tax: Option<f64>,
        ///See Invoice Types
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<RepeatingInvoiceType>,
    }

    impl From<&RepeatingInvoice> for RepeatingInvoice {
        fn from(value: &RepeatingInvoice) -> Self {
            value.clone()
        }
    }

    ///One of the following - DRAFT or AUTHORISED – See Invoice Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "One of the following - DRAFT or AUTHORISED – See
    /// Invoice Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "DRAFT",
    ///    "AUTHORISED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RepeatingInvoiceStatus {
        #[serde(rename = "DRAFT")]
        Draft,
        #[serde(rename = "AUTHORISED")]
        Authorised,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&RepeatingInvoiceStatus> for RepeatingInvoiceStatus {
        fn from(value: &RepeatingInvoiceStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RepeatingInvoiceStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Draft => write!(f, "DRAFT"),
                Self::Authorised => write!(f, "AUTHORISED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for RepeatingInvoiceStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DRAFT" => Ok(Self::Draft),
                "AUTHORISED" => Ok(Self::Authorised),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RepeatingInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RepeatingInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RepeatingInvoiceStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Invoice Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Invoice Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCPAY",
    ///    "ACCREC"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RepeatingInvoiceType {
        #[serde(rename = "ACCPAY")]
        Accpay,
        #[serde(rename = "ACCREC")]
        Accrec,
    }

    impl From<&RepeatingInvoiceType> for RepeatingInvoiceType {
        fn from(value: &RepeatingInvoiceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RepeatingInvoiceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accpay => write!(f, "ACCPAY"),
                Self::Accrec => write!(f, "ACCREC"),
            }
        }
    }

    impl std::str::FromStr for RepeatingInvoiceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCPAY" => Ok(Self::Accpay),
                "ACCREC" => Ok(Self::Accrec),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RepeatingInvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RepeatingInvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RepeatingInvoiceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///RepeatingInvoices
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "RepeatingInvoices": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RepeatingInvoice"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "repeating_invoices"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepeatingInvoices {
        #[serde(
            rename = "RepeatingInvoices",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub repeating_invoices: Vec<RepeatingInvoice>,
    }

    impl From<&RepeatingInvoices> for RepeatingInvoices {
        fn from(value: &RepeatingInvoices) -> Self {
            value.clone()
        }
    }

    ///Report
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Contacts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TenNinetyNineContact"
    ///      }
    ///    },
    ///    "ReportDate": {
    ///      "description": "Date of report",
    ///      "type": "string"
    ///    },
    ///    "ReportName": {
    ///      "description": "See Prepayment Types",
    ///      "type": "string"
    ///    },
    ///    "ReportTitle": {
    ///      "description": "See Prepayment Types",
    ///      "type": "string"
    ///    },
    ///    "ReportType": {
    ///      "description": "See Prepayment Types",
    ///      "type": "string",
    ///      "enum": [
    ///        "AgedPayablesByContact"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Updated Date",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Report {
        #[serde(rename = "Contacts", default, skip_serializing_if = "Vec::is_empty")]
        pub contacts: Vec<TenNinetyNineContact>,
        ///Date of report
        #[serde(
            rename = "ReportDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_date: Option<String>,
        ///See Prepayment Types
        #[serde(
            rename = "ReportName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_name: Option<String>,
        ///See Prepayment Types
        #[serde(
            rename = "ReportTitle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_title: Option<String>,
        ///See Prepayment Types
        #[serde(
            rename = "ReportType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_type: Option<ReportReportType>,
        ///Updated Date
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
    }

    impl From<&Report> for Report {
        fn from(value: &Report) -> Self {
            value.clone()
        }
    }

    ///ReportAttribute
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Id": {
    ///      "type": "string"
    ///    },
    ///    "Value": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportAttribute {
        #[serde(rename = "Id", default, skip_serializing_if = "Option::is_none")]
        pub id: Option<String>,
        #[serde(rename = "Value", default, skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
    }

    impl From<&ReportAttribute> for ReportAttribute {
        fn from(value: &ReportAttribute) -> Self {
            value.clone()
        }
    }

    ///ReportCell
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Attributes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportAttribute"
    ///      }
    ///    },
    ///    "Value": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportCell {
        #[serde(rename = "Attributes", default, skip_serializing_if = "Vec::is_empty")]
        pub attributes: Vec<ReportAttribute>,
        #[serde(rename = "Value", default, skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
    }

    impl From<&ReportCell> for ReportCell {
        fn from(value: &ReportCell) -> Self {
            value.clone()
        }
    }

    ///ReportFields
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Description": {
    ///      "type": "string"
    ///    },
    ///    "FieldID": {
    ///      "type": "string"
    ///    },
    ///    "Value": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportFields {
        #[serde(
            rename = "Description",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub description: Option<String>,
        #[serde(rename = "FieldID", default, skip_serializing_if = "Option::is_none")]
        pub field_id: Option<String>,
        #[serde(rename = "Value", default, skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
    }

    impl From<&ReportFields> for ReportFields {
        fn from(value: &ReportFields) -> Self {
            value.clone()
        }
    }

    ///See Prepayment Types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Prepayment Types",
    ///  "type": "string",
    ///  "enum": [
    ///    "AgedPayablesByContact"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportReportType {
        AgedPayablesByContact,
    }

    impl From<&ReportReportType> for ReportReportType {
        fn from(value: &ReportReportType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ReportReportType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AgedPayablesByContact => write!(f, "AgedPayablesByContact"),
            }
        }
    }

    impl std::str::FromStr for ReportReportType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AgedPayablesByContact" => Ok(Self::AgedPayablesByContact),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportReportType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportReportType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportReportType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///ReportRow
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Cells": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportCell"
    ///      }
    ///    },
    ///    "RowType": {
    ///      "$ref": "#/components/schemas/RowType"
    ///    },
    ///    "Title": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportRow {
        #[serde(rename = "Cells", default, skip_serializing_if = "Vec::is_empty")]
        pub cells: Vec<ReportCell>,
        #[serde(rename = "RowType", default, skip_serializing_if = "Option::is_none")]
        pub row_type: Option<RowType>,
        #[serde(rename = "Title", default, skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
    }

    impl From<&ReportRow> for ReportRow {
        fn from(value: &ReportRow) -> Self {
            value.clone()
        }
    }

    ///ReportRows
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Cells": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportCell"
    ///      }
    ///    },
    ///    "RowType": {
    ///      "$ref": "#/components/schemas/RowType"
    ///    },
    ///    "Rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportRow"
    ///      }
    ///    },
    ///    "Title": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportRows {
        #[serde(rename = "Cells", default, skip_serializing_if = "Vec::is_empty")]
        pub cells: Vec<ReportCell>,
        #[serde(rename = "RowType", default, skip_serializing_if = "Option::is_none")]
        pub row_type: Option<RowType>,
        #[serde(rename = "Rows", default, skip_serializing_if = "Vec::is_empty")]
        pub rows: Vec<ReportRow>,
        #[serde(rename = "Title", default, skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
    }

    impl From<&ReportRows> for ReportRows {
        fn from(value: &ReportRows) -> Self {
            value.clone()
        }
    }

    ///ReportWithRow
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Fields": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportFields"
    ///      }
    ///    },
    ///    "ReportDate": {
    ///      "description": "Date of report",
    ///      "type": "string"
    ///    },
    ///    "ReportID": {
    ///      "description": "ID of the Report",
    ///      "type": "string"
    ///    },
    ///    "ReportName": {
    ///      "description": "Name of the report",
    ///      "type": "string"
    ///    },
    ///    "ReportTitle": {
    ///      "description": "Title of the report",
    ///      "type": "string"
    ///    },
    ///    "ReportTitles": {
    ///      "description": "Report titles array (3 to 4 strings with the report
    /// name, orgnisation name and time frame of report)",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "ReportType": {
    ///      "description": "The type of report (BalanceSheet,ProfitLoss, etc)",
    ///      "type": "string"
    ///    },
    ///    "Rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportRows"
    ///      }
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Updated Date",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportWithRow {
        #[serde(rename = "Fields", default, skip_serializing_if = "Vec::is_empty")]
        pub fields: Vec<ReportFields>,
        ///Date of report
        #[serde(
            rename = "ReportDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_date: Option<String>,
        ///ID of the Report
        #[serde(rename = "ReportID", default, skip_serializing_if = "Option::is_none")]
        pub report_id: Option<String>,
        ///Name of the report
        #[serde(
            rename = "ReportName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_name: Option<String>,
        ///Title of the report
        #[serde(
            rename = "ReportTitle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_title: Option<String>,
        ///Report titles array (3 to 4 strings with the report name,
        /// orgnisation name and time frame of report)
        #[serde(
            rename = "ReportTitles",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub report_titles: Vec<String>,
        ///The type of report (BalanceSheet,ProfitLoss, etc)
        #[serde(
            rename = "ReportType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_type: Option<String>,
        #[serde(rename = "Rows", default, skip_serializing_if = "Vec::is_empty")]
        pub rows: Vec<ReportRows>,
        ///Updated Date
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
    }

    impl From<&ReportWithRow> for ReportWithRow {
        fn from(value: &ReportWithRow) -> Self {
            value.clone()
        }
    }

    ///ReportWithRows
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Reports": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportWithRow"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportWithRows {
        #[serde(rename = "Reports", default, skip_serializing_if = "Vec::is_empty")]
        pub reports: Vec<ReportWithRow>,
    }

    impl From<&ReportWithRows> for ReportWithRows {
        fn from(value: &ReportWithRows) -> Self {
            value.clone()
        }
    }

    ///Reports
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Reports": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Report"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "reports"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Reports {
        #[serde(rename = "Reports", default, skip_serializing_if = "Vec::is_empty")]
        pub reports: Vec<Report>,
    }

    impl From<&Reports> for Reports {
        fn from(value: &Reports) -> Self {
            value.clone()
        }
    }

    ///RequestEmpty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Status": {
    ///      "description": "Need at least one field to create an empty JSON
    /// payload",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RequestEmpty {
        ///Need at least one field to create an empty JSON payload
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<String>,
    }

    impl From<&RequestEmpty> for RequestEmpty {
        fn from(value: &RequestEmpty) -> Self {
            value.clone()
        }
    }

    ///RowType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Header",
    ///    "Section",
    ///    "Row",
    ///    "SummaryRow"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RowType {
        Header,
        Section,
        Row,
        SummaryRow,
    }

    impl From<&RowType> for RowType {
        fn from(value: &RowType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RowType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Header => write!(f, "Header"),
                Self::Section => write!(f, "Section"),
                Self::Row => write!(f, "Row"),
                Self::SummaryRow => write!(f, "SummaryRow"),
            }
        }
    }

    impl std::str::FromStr for RowType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Header" => Ok(Self::Header),
                "Section" => Ok(Self::Section),
                "Row" => Ok(Self::Row),
                "SummaryRow" => Ok(Self::SummaryRow),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///SalesTrackingCategory
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "TrackingCategoryName": {
    ///      "description": "The default sales tracking category name for
    /// contacts",
    ///      "type": "string"
    ///    },
    ///    "TrackingOptionName": {
    ///      "description": "The default purchase tracking category name for
    /// contacts",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SalesTrackingCategory {
        ///The default sales tracking category name for contacts
        #[serde(
            rename = "TrackingCategoryName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_name: Option<String>,
        ///The default purchase tracking category name for contacts
        #[serde(
            rename = "TrackingOptionName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_option_name: Option<String>,
    }

    impl From<&SalesTrackingCategory> for SalesTrackingCategory {
        fn from(value: &SalesTrackingCategory) -> Self {
            value.clone()
        }
    }

    ///Schedule
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "DueDate": {
    ///      "description": "Integer used with due date type e.g 20 (of
    /// following month), 31 (of current month)",
    ///      "type": "integer"
    ///    },
    ///    "DueDateType": {
    ///      "description": "the payment terms",
    ///      "type": "string",
    ///      "enum": [
    ///        "DAYSAFTERBILLDATE",
    ///        "DAYSAFTERBILLMONTH",
    ///        "DAYSAFTERINVOICEDATE",
    ///        "DAYSAFTERINVOICEMONTH",
    ///        "OFCURRENTMONTH",
    ///        "OFFOLLOWINGMONTH"
    ///      ]
    ///    },
    ///    "EndDate": {
    ///      "description": "Invoice end date – only returned if the template
    /// has an end date set",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "NextScheduledDate": {
    ///      "description": "The calendar date of the next invoice in the
    /// schedule to be generated",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Period": {
    ///      "description": "Integer used with the unit e.g. 1 (every 1 week), 2
    /// (every 2 months)",
    ///      "type": "integer"
    ///    },
    ///    "StartDate": {
    ///      "description": "Date the first invoice of the current version of
    /// the repeating schedule was generated (changes when repeating invoice is
    /// edited)",
    ///      "type": "string",
    ///      "x-is-msdate": true
    ///    },
    ///    "Unit": {
    ///      "description": "One of the following - WEEKLY or MONTHLY",
    ///      "type": "string",
    ///      "enum": [
    ///        "WEEKLY",
    ///        "MONTHLY"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Schedule {
        ///Integer used with due date type e.g 20 (of following month), 31 (of
        /// current month)
        #[serde(rename = "DueDate", default, skip_serializing_if = "Option::is_none")]
        pub due_date: Option<i64>,
        ///the payment terms
        #[serde(
            rename = "DueDateType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub due_date_type: Option<ScheduleDueDateType>,
        ///Invoice end date – only returned if the template has an end date set
        #[serde(rename = "EndDate", default, skip_serializing_if = "Option::is_none")]
        pub end_date: Option<String>,
        ///The calendar date of the next invoice in the schedule to be
        /// generated
        #[serde(
            rename = "NextScheduledDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub next_scheduled_date: Option<String>,
        ///Integer used with the unit e.g. 1 (every 1 week), 2 (every 2 months)
        #[serde(rename = "Period", default, skip_serializing_if = "Option::is_none")]
        pub period: Option<i64>,
        ///Date the first invoice of the current version of the repeating
        /// schedule was generated (changes when repeating invoice is edited)
        #[serde(rename = "StartDate", default, skip_serializing_if = "Option::is_none")]
        pub start_date: Option<String>,
        ///One of the following - WEEKLY or MONTHLY
        #[serde(rename = "Unit", default, skip_serializing_if = "Option::is_none")]
        pub unit: Option<ScheduleUnit>,
    }

    impl From<&Schedule> for Schedule {
        fn from(value: &Schedule) -> Self {
            value.clone()
        }
    }

    ///the payment terms
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "the payment terms",
    ///  "type": "string",
    ///  "enum": [
    ///    "DAYSAFTERBILLDATE",
    ///    "DAYSAFTERBILLMONTH",
    ///    "DAYSAFTERINVOICEDATE",
    ///    "DAYSAFTERINVOICEMONTH",
    ///    "OFCURRENTMONTH",
    ///    "OFFOLLOWINGMONTH"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ScheduleDueDateType {
        #[serde(rename = "DAYSAFTERBILLDATE")]
        Daysafterbilldate,
        #[serde(rename = "DAYSAFTERBILLMONTH")]
        Daysafterbillmonth,
        #[serde(rename = "DAYSAFTERINVOICEDATE")]
        Daysafterinvoicedate,
        #[serde(rename = "DAYSAFTERINVOICEMONTH")]
        Daysafterinvoicemonth,
        #[serde(rename = "OFCURRENTMONTH")]
        Ofcurrentmonth,
        #[serde(rename = "OFFOLLOWINGMONTH")]
        Offollowingmonth,
    }

    impl From<&ScheduleDueDateType> for ScheduleDueDateType {
        fn from(value: &ScheduleDueDateType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ScheduleDueDateType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Daysafterbilldate => write!(f, "DAYSAFTERBILLDATE"),
                Self::Daysafterbillmonth => write!(f, "DAYSAFTERBILLMONTH"),
                Self::Daysafterinvoicedate => write!(f, "DAYSAFTERINVOICEDATE"),
                Self::Daysafterinvoicemonth => write!(f, "DAYSAFTERINVOICEMONTH"),
                Self::Ofcurrentmonth => write!(f, "OFCURRENTMONTH"),
                Self::Offollowingmonth => write!(f, "OFFOLLOWINGMONTH"),
            }
        }
    }

    impl std::str::FromStr for ScheduleDueDateType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DAYSAFTERBILLDATE" => Ok(Self::Daysafterbilldate),
                "DAYSAFTERBILLMONTH" => Ok(Self::Daysafterbillmonth),
                "DAYSAFTERINVOICEDATE" => Ok(Self::Daysafterinvoicedate),
                "DAYSAFTERINVOICEMONTH" => Ok(Self::Daysafterinvoicemonth),
                "OFCURRENTMONTH" => Ok(Self::Ofcurrentmonth),
                "OFFOLLOWINGMONTH" => Ok(Self::Offollowingmonth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ScheduleDueDateType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ScheduleDueDateType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ScheduleDueDateType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///One of the following - WEEKLY or MONTHLY
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "One of the following - WEEKLY or MONTHLY",
    ///  "type": "string",
    ///  "enum": [
    ///    "WEEKLY",
    ///    "MONTHLY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ScheduleUnit {
        #[serde(rename = "WEEKLY")]
        Weekly,
        #[serde(rename = "MONTHLY")]
        Monthly,
    }

    impl From<&ScheduleUnit> for ScheduleUnit {
        fn from(value: &ScheduleUnit) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ScheduleUnit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Weekly => write!(f, "WEEKLY"),
                Self::Monthly => write!(f, "MONTHLY"),
            }
        }
    }

    impl std::str::FromStr for ScheduleUnit {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "WEEKLY" => Ok(Self::Weekly),
                "MONTHLY" => Ok(Self::Monthly),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ScheduleUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ScheduleUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ScheduleUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Setup
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Account"
    ///      }
    ///    },
    ///    "ConversionBalances": {
    ///      "description": "Balance supplied for each account that has a value
    /// as at the conversion date.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ConversionBalances"
    ///      }
    ///    },
    ///    "ConversionDate": {
    ///      "$ref": "#/components/schemas/ConversionDate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Setup {
        #[serde(rename = "Accounts", default, skip_serializing_if = "Vec::is_empty")]
        pub accounts: Vec<Account>,
        ///Balance supplied for each account that has a value as at the
        /// conversion date.
        #[serde(
            rename = "ConversionBalances",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub conversion_balances: Vec<ConversionBalances>,
        #[serde(
            rename = "ConversionDate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub conversion_date: Option<ConversionDate>,
    }

    impl From<&Setup> for Setup {
        fn from(value: &Setup) -> Self {
            value.clone()
        }
    }

    ///TaxBreakdownComponent
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ExemptAmount": {
    ///      "description": "The amount that is exempt",
    ///      "type": "number"
    ///    },
    ///    "JurisdictionRegion": {
    ///      "description": "Name identifying the region within the country",
    ///      "type": "string"
    ///    },
    ///    "Name": {
    ///      "description": "The name of the jurisdiction",
    ///      "type": "string"
    ///    },
    ///    "NonTaxableAmount": {
    ///      "description": "The amount that is not taxable",
    ///      "type": "number"
    ///    },
    ///    "StateAssignedNo": {
    ///      "description": "The state assigned number of the jurisdiction",
    ///      "type": "string"
    ///    },
    ///    "TaxAmount": {
    ///      "description": "The amount of the tax",
    ///      "type": "number"
    ///    },
    ///    "TaxComponentId": {
    ///      "description": "The unique ID number of this component",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "TaxPercentage": {
    ///      "description": "The percentage of the tax",
    ///      "type": "number"
    ///    },
    ///    "TaxableAmount": {
    ///      "description": "The amount that is taxable",
    ///      "type": "number"
    ///    },
    ///    "Type": {
    ///      "description": "The type of the jurisdiction",
    ///      "type": "string",
    ///      "enum": [
    ///        "SYSGST/USCOUNTRY",
    ///        "SYSGST/USSTATE",
    ///        "SYSGST/USCOUNTY",
    ///        "SYSGST/USCITY",
    ///        "SYSGST/USSPECIAL"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaxBreakdownComponent {
        #[serde(
            rename = "ExemptAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub exempt_amount: Option<f64>,
        ///Name identifying the region within the country
        #[serde(
            rename = "JurisdictionRegion",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub jurisdiction_region: Option<String>,
        ///The name of the jurisdiction
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        #[serde(
            rename = "NonTaxableAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub non_taxable_amount: Option<f64>,
        ///The state assigned number of the jurisdiction
        #[serde(
            rename = "StateAssignedNo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub state_assigned_no: Option<String>,
        #[serde(rename = "TaxAmount", default, skip_serializing_if = "Option::is_none")]
        pub tax_amount: Option<f64>,
        ///The unique ID number of this component
        #[serde(
            rename = "TaxComponentId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tax_component_id: Option<uuid::Uuid>,
        #[serde(
            rename = "TaxPercentage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tax_percentage: Option<f64>,
        #[serde(
            rename = "TaxableAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub taxable_amount: Option<f64>,
        ///The type of the jurisdiction
        #[serde(rename = "Type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<TaxBreakdownComponentType>,
    }

    impl From<&TaxBreakdownComponent> for TaxBreakdownComponent {
        fn from(value: &TaxBreakdownComponent) -> Self {
            value.clone()
        }
    }

    ///The type of the jurisdiction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of the jurisdiction",
    ///  "type": "string",
    ///  "enum": [
    ///    "SYSGST/USCOUNTRY",
    ///    "SYSGST/USSTATE",
    ///    "SYSGST/USCOUNTY",
    ///    "SYSGST/USCITY",
    ///    "SYSGST/USSPECIAL"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TaxBreakdownComponentType {
        #[serde(rename = "SYSGST/USCOUNTRY")]
        SysgstUscountry,
        #[serde(rename = "SYSGST/USSTATE")]
        SysgstUsstate,
        #[serde(rename = "SYSGST/USCOUNTY")]
        SysgstUscounty,
        #[serde(rename = "SYSGST/USCITY")]
        SysgstUscity,
        #[serde(rename = "SYSGST/USSPECIAL")]
        SysgstUsspecial,
    }

    impl From<&TaxBreakdownComponentType> for TaxBreakdownComponentType {
        fn from(value: &TaxBreakdownComponentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TaxBreakdownComponentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SysgstUscountry => write!(f, "SYSGST/USCOUNTRY"),
                Self::SysgstUsstate => write!(f, "SYSGST/USSTATE"),
                Self::SysgstUscounty => write!(f, "SYSGST/USCOUNTY"),
                Self::SysgstUscity => write!(f, "SYSGST/USCITY"),
                Self::SysgstUsspecial => write!(f, "SYSGST/USSPECIAL"),
            }
        }
    }

    impl std::str::FromStr for TaxBreakdownComponentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SYSGST/USCOUNTRY" => Ok(Self::SysgstUscountry),
                "SYSGST/USSTATE" => Ok(Self::SysgstUsstate),
                "SYSGST/USCOUNTY" => Ok(Self::SysgstUscounty),
                "SYSGST/USCITY" => Ok(Self::SysgstUscity),
                "SYSGST/USSPECIAL" => Ok(Self::SysgstUsspecial),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TaxBreakdownComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TaxBreakdownComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TaxBreakdownComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TaxComponent
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "IsCompound": {
    ///      "description": "Boolean to describe if Tax rate is compounded.",
    ///      "type": "boolean"
    ///    },
    ///    "IsNonRecoverable": {
    ///      "description": "Boolean to describe if tax rate is non-recoverable. Non-recoverable rates are only applicable to Canadian organisations",
    ///      "type": "boolean"
    ///    },
    ///    "Name": {
    ///      "description": "Name of Tax Component",
    ///      "type": "string"
    ///    },
    ///    "Rate": {
    ///      "description": "Tax Rate (up to 4dp)",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaxComponent {
        ///Boolean to describe if Tax rate is compounded.
        #[serde(
            rename = "IsCompound",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_compound: Option<bool>,
        ///Boolean to describe if tax rate is non-recoverable. Non-recoverable
        /// rates are only applicable to Canadian organisations
        #[serde(
            rename = "IsNonRecoverable",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_non_recoverable: Option<bool>,
        ///Name of Tax Component
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        #[serde(rename = "Rate", default, skip_serializing_if = "Option::is_none")]
        pub rate: Option<f64>,
    }

    impl From<&TaxComponent> for TaxComponent {
        fn from(value: &TaxComponent) -> Self {
            value.clone()
        }
    }

    ///TaxRate
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "CanApplyToAssets": {
    ///      "description": "Boolean to describe if tax rate can be used for
    /// asset accounts i.e.  true,false",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "CanApplyToEquity": {
    ///      "description": "Boolean to describe if tax rate can be used for
    /// equity accounts i.e true,false",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "CanApplyToExpenses": {
    ///      "description": "Boolean to describe if tax rate can be used for
    /// expense accounts  i.e. true,false",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "CanApplyToLiabilities": {
    ///      "description": "Boolean to describe if tax rate can be used for
    /// liability accounts  i.e. true,false",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "CanApplyToRevenue": {
    ///      "description": "Boolean to describe if tax rate can be used for
    /// revenue accounts i.e. true,false",
    ///      "readOnly": true,
    ///      "type": "boolean"
    ///    },
    ///    "DisplayTaxRate": {
    ///      "description": "Tax Rate (decimal to 4dp) e.g 12.5000",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "EffectiveRate": {
    ///      "description": "Effective Tax Rate (decimal to 4dp) e.g 12.5000",
    ///      "readOnly": true,
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Name": {
    ///      "description": "Name of tax rate",
    ///      "type": "string"
    ///    },
    ///    "ReportTaxType": {
    ///      "description": "See ReportTaxTypes",
    ///      "type": "string",
    ///      "enum": [
    ///        "AVALARA",
    ///        "BASEXCLUDED",
    ///        "CAPITALSALESOUTPUT",
    ///        "CAPITALEXPENSESINPUT",
    ///        "ECOUTPUT",
    ///        "ECOUTPUTSERVICES",
    ///        "ECINPUT",
    ///        "ECACQUISITIONS",
    ///        "EXEMPTEXPENSES",
    ///        "EXEMPTINPUT",
    ///        "EXEMPTOUTPUT",
    ///        "GSTONIMPORTS",
    ///        "INPUT",
    ///        "INPUTTAXED",
    ///        "MOSSSALES",
    ///        "NONE",
    ///        "NONEOUTPUT",
    ///        "OUTPUT",
    ///        "PURCHASESINPUT",
    ///        "SALESOUTPUT",
    ///        "EXEMPTCAPITAL",
    ///        "EXEMPTEXPORT",
    ///        "CAPITALEXINPUT",
    ///        "GSTONCAPIMPORTS",
    ///        "GSTONCAPITALIMPORTS",
    ///        "REVERSECHARGES",
    ///        "PAYMENTS",
    ///        "INVOICE",
    ///        "CASH",
    ///        "ACCRUAL",
    ///        "FLATRATECASH",
    ///        "FLATRATEACCRUAL",
    ///        "ACCRUALS",
    ///        "TXCA",
    ///        "SRCAS",
    ///        "DSOUTPUT",
    ///        "BLINPUT2",
    ///        "EPINPUT",
    ///        "IMINPUT2",
    ///        "MEINPUT",
    ///        "IGDSINPUT2",
    ///        "ESN33OUTPUT",
    ///        "OPINPUT",
    ///        "OSOUTPUT",
    ///        "TXN33INPUT",
    ///        "TXESSINPUT",
    ///        "TXREINPUT",
    ///        "TXPETINPUT",
    ///        "NRINPUT",
    ///        "ES33OUTPUT",
    ///        "ZERORATEDINPUT",
    ///        "ZERORATEDOUTPUT",
    ///        "DRCHARGESUPPLY",
    ///        "DRCHARGE",
    ///        "CAPINPUT",
    ///        "CAPIMPORTS",
    ///        "IMINPUT",
    ///        "INPUT2",
    ///        "CIUINPUT",
    ///        "SRINPUT",
    ///        "OUTPUT2",
    ///        "SROUTPUT",
    ///        "CAPOUTPUT",
    ///        "SROUTPUT2",
    ///        "CIUOUTPUT",
    ///        "ZROUTPUT",
    ///        "ZREXPORT",
    ///        "ACC28PLUS",
    ///        "ACCUPTO28",
    ///        "OTHEROUTPUT",
    ///        "SHOUTPUT",
    ///        "ZRINPUT",
    ///        "BADDEBT",
    ///        "OTHERINPUT",
    ///        "BADDEBTRELIEF",
    ///        "IGDSINPUT3",
    ///        "SROVR",
    ///        "TOURISTREFUND",
    ///        "TXRCN33",
    ///        "TXRCRE",
    ///        "TXRCESS",
    ///        "TXRCTS",
    ///        "CAPEXINPUT",
    ///        "UNDEFINED",
    ///        "CAPEXOUTPUT",
    ///        "ZEROEXPOUTPUT",
    ///        "GOODSIMPORT",
    ///        "NONEINPUT",
    ///        "NOTREPORTED",
    ///        "SROVRRS",
    ///        "SROVRLVG",
    ///        "SRLVG",
    ///        "IM",
    ///        "IMESS",
    ///        "IMN33",
    ///        "IMRE",
    ///        "BADDEBTRECOVERY",
    ///        "USSALESTAX",
    ///        "BLINPUT3"
    ///      ]
    ///    },
    ///    "Status": {
    ///      "description": "See Status Codes",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "DELETED",
    ///        "ARCHIVED",
    ///        "PENDING"
    ///      ]
    ///    },
    ///    "TaxComponents": {
    ///      "description": "See TaxComponents",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaxComponent"
    ///      }
    ///    },
    ///    "TaxType": {
    ///      "description": "The tax type",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaxRate {
        ///Boolean to describe if tax rate can be used for asset accounts i.e.
        /// true,false
        #[serde(
            rename = "CanApplyToAssets",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub can_apply_to_assets: Option<bool>,
        ///Boolean to describe if tax rate can be used for equity accounts i.e
        /// true,false
        #[serde(
            rename = "CanApplyToEquity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub can_apply_to_equity: Option<bool>,
        ///Boolean to describe if tax rate can be used for expense accounts
        /// i.e. true,false
        #[serde(
            rename = "CanApplyToExpenses",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub can_apply_to_expenses: Option<bool>,
        ///Boolean to describe if tax rate can be used for liability accounts
        /// i.e. true,false
        #[serde(
            rename = "CanApplyToLiabilities",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub can_apply_to_liabilities: Option<bool>,
        ///Boolean to describe if tax rate can be used for revenue accounts
        /// i.e. true,false
        #[serde(
            rename = "CanApplyToRevenue",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub can_apply_to_revenue: Option<bool>,
        #[serde(
            rename = "DisplayTaxRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub display_tax_rate: Option<f64>,
        #[serde(
            rename = "EffectiveRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub effective_rate: Option<f64>,
        ///Name of tax rate
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///See ReportTaxTypes
        #[serde(
            rename = "ReportTaxType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_tax_type: Option<TaxRateReportTaxType>,
        ///See Status Codes
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<TaxRateStatus>,
        ///See TaxComponents
        #[serde(
            rename = "TaxComponents",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tax_components: Vec<TaxComponent>,
        ///The tax type
        #[serde(rename = "TaxType", default, skip_serializing_if = "Option::is_none")]
        pub tax_type: Option<String>,
    }

    impl From<&TaxRate> for TaxRate {
        fn from(value: &TaxRate) -> Self {
            value.clone()
        }
    }

    ///See ReportTaxTypes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See ReportTaxTypes",
    ///  "type": "string",
    ///  "enum": [
    ///    "AVALARA",
    ///    "BASEXCLUDED",
    ///    "CAPITALSALESOUTPUT",
    ///    "CAPITALEXPENSESINPUT",
    ///    "ECOUTPUT",
    ///    "ECOUTPUTSERVICES",
    ///    "ECINPUT",
    ///    "ECACQUISITIONS",
    ///    "EXEMPTEXPENSES",
    ///    "EXEMPTINPUT",
    ///    "EXEMPTOUTPUT",
    ///    "GSTONIMPORTS",
    ///    "INPUT",
    ///    "INPUTTAXED",
    ///    "MOSSSALES",
    ///    "NONE",
    ///    "NONEOUTPUT",
    ///    "OUTPUT",
    ///    "PURCHASESINPUT",
    ///    "SALESOUTPUT",
    ///    "EXEMPTCAPITAL",
    ///    "EXEMPTEXPORT",
    ///    "CAPITALEXINPUT",
    ///    "GSTONCAPIMPORTS",
    ///    "GSTONCAPITALIMPORTS",
    ///    "REVERSECHARGES",
    ///    "PAYMENTS",
    ///    "INVOICE",
    ///    "CASH",
    ///    "ACCRUAL",
    ///    "FLATRATECASH",
    ///    "FLATRATEACCRUAL",
    ///    "ACCRUALS",
    ///    "TXCA",
    ///    "SRCAS",
    ///    "DSOUTPUT",
    ///    "BLINPUT2",
    ///    "EPINPUT",
    ///    "IMINPUT2",
    ///    "MEINPUT",
    ///    "IGDSINPUT2",
    ///    "ESN33OUTPUT",
    ///    "OPINPUT",
    ///    "OSOUTPUT",
    ///    "TXN33INPUT",
    ///    "TXESSINPUT",
    ///    "TXREINPUT",
    ///    "TXPETINPUT",
    ///    "NRINPUT",
    ///    "ES33OUTPUT",
    ///    "ZERORATEDINPUT",
    ///    "ZERORATEDOUTPUT",
    ///    "DRCHARGESUPPLY",
    ///    "DRCHARGE",
    ///    "CAPINPUT",
    ///    "CAPIMPORTS",
    ///    "IMINPUT",
    ///    "INPUT2",
    ///    "CIUINPUT",
    ///    "SRINPUT",
    ///    "OUTPUT2",
    ///    "SROUTPUT",
    ///    "CAPOUTPUT",
    ///    "SROUTPUT2",
    ///    "CIUOUTPUT",
    ///    "ZROUTPUT",
    ///    "ZREXPORT",
    ///    "ACC28PLUS",
    ///    "ACCUPTO28",
    ///    "OTHEROUTPUT",
    ///    "SHOUTPUT",
    ///    "ZRINPUT",
    ///    "BADDEBT",
    ///    "OTHERINPUT",
    ///    "BADDEBTRELIEF",
    ///    "IGDSINPUT3",
    ///    "SROVR",
    ///    "TOURISTREFUND",
    ///    "TXRCN33",
    ///    "TXRCRE",
    ///    "TXRCESS",
    ///    "TXRCTS",
    ///    "CAPEXINPUT",
    ///    "UNDEFINED",
    ///    "CAPEXOUTPUT",
    ///    "ZEROEXPOUTPUT",
    ///    "GOODSIMPORT",
    ///    "NONEINPUT",
    ///    "NOTREPORTED",
    ///    "SROVRRS",
    ///    "SROVRLVG",
    ///    "SRLVG",
    ///    "IM",
    ///    "IMESS",
    ///    "IMN33",
    ///    "IMRE",
    ///    "BADDEBTRECOVERY",
    ///    "USSALESTAX",
    ///    "BLINPUT3"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TaxRateReportTaxType {
        #[serde(rename = "AVALARA")]
        Avalara,
        #[serde(rename = "BASEXCLUDED")]
        Basexcluded,
        #[serde(rename = "CAPITALSALESOUTPUT")]
        Capitalsalesoutput,
        #[serde(rename = "CAPITALEXPENSESINPUT")]
        Capitalexpensesinput,
        #[serde(rename = "ECOUTPUT")]
        Ecoutput,
        #[serde(rename = "ECOUTPUTSERVICES")]
        Ecoutputservices,
        #[serde(rename = "ECINPUT")]
        Ecinput,
        #[serde(rename = "ECACQUISITIONS")]
        Ecacquisitions,
        #[serde(rename = "EXEMPTEXPENSES")]
        Exemptexpenses,
        #[serde(rename = "EXEMPTINPUT")]
        Exemptinput,
        #[serde(rename = "EXEMPTOUTPUT")]
        Exemptoutput,
        #[serde(rename = "GSTONIMPORTS")]
        Gstonimports,
        #[serde(rename = "INPUT")]
        Input,
        #[serde(rename = "INPUTTAXED")]
        Inputtaxed,
        #[serde(rename = "MOSSSALES")]
        Mosssales,
        #[serde(rename = "NONE")]
        None,
        #[serde(rename = "NONEOUTPUT")]
        Noneoutput,
        #[serde(rename = "OUTPUT")]
        Output,
        #[serde(rename = "PURCHASESINPUT")]
        Purchasesinput,
        #[serde(rename = "SALESOUTPUT")]
        Salesoutput,
        #[serde(rename = "EXEMPTCAPITAL")]
        Exemptcapital,
        #[serde(rename = "EXEMPTEXPORT")]
        Exemptexport,
        #[serde(rename = "CAPITALEXINPUT")]
        Capitalexinput,
        #[serde(rename = "GSTONCAPIMPORTS")]
        Gstoncapimports,
        #[serde(rename = "GSTONCAPITALIMPORTS")]
        Gstoncapitalimports,
        #[serde(rename = "REVERSECHARGES")]
        Reversecharges,
        #[serde(rename = "PAYMENTS")]
        Payments,
        #[serde(rename = "INVOICE")]
        Invoice,
        #[serde(rename = "CASH")]
        Cash,
        #[serde(rename = "ACCRUAL")]
        Accrual,
        #[serde(rename = "FLATRATECASH")]
        Flatratecash,
        #[serde(rename = "FLATRATEACCRUAL")]
        Flatrateaccrual,
        #[serde(rename = "ACCRUALS")]
        Accruals,
        #[serde(rename = "TXCA")]
        Txca,
        #[serde(rename = "SRCAS")]
        Srcas,
        #[serde(rename = "DSOUTPUT")]
        Dsoutput,
        #[serde(rename = "BLINPUT2")]
        Blinput2,
        #[serde(rename = "EPINPUT")]
        Epinput,
        #[serde(rename = "IMINPUT2")]
        Iminput2,
        #[serde(rename = "MEINPUT")]
        Meinput,
        #[serde(rename = "IGDSINPUT2")]
        Igdsinput2,
        #[serde(rename = "ESN33OUTPUT")]
        Esn33output,
        #[serde(rename = "OPINPUT")]
        Opinput,
        #[serde(rename = "OSOUTPUT")]
        Osoutput,
        #[serde(rename = "TXN33INPUT")]
        Txn33input,
        #[serde(rename = "TXESSINPUT")]
        Txessinput,
        #[serde(rename = "TXREINPUT")]
        Txreinput,
        #[serde(rename = "TXPETINPUT")]
        Txpetinput,
        #[serde(rename = "NRINPUT")]
        Nrinput,
        #[serde(rename = "ES33OUTPUT")]
        Es33output,
        #[serde(rename = "ZERORATEDINPUT")]
        Zeroratedinput,
        #[serde(rename = "ZERORATEDOUTPUT")]
        Zeroratedoutput,
        #[serde(rename = "DRCHARGESUPPLY")]
        Drchargesupply,
        #[serde(rename = "DRCHARGE")]
        Drcharge,
        #[serde(rename = "CAPINPUT")]
        Capinput,
        #[serde(rename = "CAPIMPORTS")]
        Capimports,
        #[serde(rename = "IMINPUT")]
        Iminput,
        #[serde(rename = "INPUT2")]
        Input2,
        #[serde(rename = "CIUINPUT")]
        Ciuinput,
        #[serde(rename = "SRINPUT")]
        Srinput,
        #[serde(rename = "OUTPUT2")]
        Output2,
        #[serde(rename = "SROUTPUT")]
        Sroutput,
        #[serde(rename = "CAPOUTPUT")]
        Capoutput,
        #[serde(rename = "SROUTPUT2")]
        Sroutput2,
        #[serde(rename = "CIUOUTPUT")]
        Ciuoutput,
        #[serde(rename = "ZROUTPUT")]
        Zroutput,
        #[serde(rename = "ZREXPORT")]
        Zrexport,
        #[serde(rename = "ACC28PLUS")]
        Acc28plus,
        #[serde(rename = "ACCUPTO28")]
        Accupto28,
        #[serde(rename = "OTHEROUTPUT")]
        Otheroutput,
        #[serde(rename = "SHOUTPUT")]
        Shoutput,
        #[serde(rename = "ZRINPUT")]
        Zrinput,
        #[serde(rename = "BADDEBT")]
        Baddebt,
        #[serde(rename = "OTHERINPUT")]
        Otherinput,
        #[serde(rename = "BADDEBTRELIEF")]
        Baddebtrelief,
        #[serde(rename = "IGDSINPUT3")]
        Igdsinput3,
        #[serde(rename = "SROVR")]
        Srovr,
        #[serde(rename = "TOURISTREFUND")]
        Touristrefund,
        #[serde(rename = "TXRCN33")]
        Txrcn33,
        #[serde(rename = "TXRCRE")]
        Txrcre,
        #[serde(rename = "TXRCESS")]
        Txrcess,
        #[serde(rename = "TXRCTS")]
        Txrcts,
        #[serde(rename = "CAPEXINPUT")]
        Capexinput,
        #[serde(rename = "UNDEFINED")]
        Undefined,
        #[serde(rename = "CAPEXOUTPUT")]
        Capexoutput,
        #[serde(rename = "ZEROEXPOUTPUT")]
        Zeroexpoutput,
        #[serde(rename = "GOODSIMPORT")]
        Goodsimport,
        #[serde(rename = "NONEINPUT")]
        Noneinput,
        #[serde(rename = "NOTREPORTED")]
        Notreported,
        #[serde(rename = "SROVRRS")]
        Srovrrs,
        #[serde(rename = "SROVRLVG")]
        Srovrlvg,
        #[serde(rename = "SRLVG")]
        Srlvg,
        #[serde(rename = "IM")]
        Im,
        #[serde(rename = "IMESS")]
        Imess,
        #[serde(rename = "IMN33")]
        Imn33,
        #[serde(rename = "IMRE")]
        Imre,
        #[serde(rename = "BADDEBTRECOVERY")]
        Baddebtrecovery,
        #[serde(rename = "USSALESTAX")]
        Ussalestax,
        #[serde(rename = "BLINPUT3")]
        Blinput3,
    }

    impl From<&TaxRateReportTaxType> for TaxRateReportTaxType {
        fn from(value: &TaxRateReportTaxType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TaxRateReportTaxType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Avalara => write!(f, "AVALARA"),
                Self::Basexcluded => write!(f, "BASEXCLUDED"),
                Self::Capitalsalesoutput => write!(f, "CAPITALSALESOUTPUT"),
                Self::Capitalexpensesinput => write!(f, "CAPITALEXPENSESINPUT"),
                Self::Ecoutput => write!(f, "ECOUTPUT"),
                Self::Ecoutputservices => write!(f, "ECOUTPUTSERVICES"),
                Self::Ecinput => write!(f, "ECINPUT"),
                Self::Ecacquisitions => write!(f, "ECACQUISITIONS"),
                Self::Exemptexpenses => write!(f, "EXEMPTEXPENSES"),
                Self::Exemptinput => write!(f, "EXEMPTINPUT"),
                Self::Exemptoutput => write!(f, "EXEMPTOUTPUT"),
                Self::Gstonimports => write!(f, "GSTONIMPORTS"),
                Self::Input => write!(f, "INPUT"),
                Self::Inputtaxed => write!(f, "INPUTTAXED"),
                Self::Mosssales => write!(f, "MOSSSALES"),
                Self::None => write!(f, "NONE"),
                Self::Noneoutput => write!(f, "NONEOUTPUT"),
                Self::Output => write!(f, "OUTPUT"),
                Self::Purchasesinput => write!(f, "PURCHASESINPUT"),
                Self::Salesoutput => write!(f, "SALESOUTPUT"),
                Self::Exemptcapital => write!(f, "EXEMPTCAPITAL"),
                Self::Exemptexport => write!(f, "EXEMPTEXPORT"),
                Self::Capitalexinput => write!(f, "CAPITALEXINPUT"),
                Self::Gstoncapimports => write!(f, "GSTONCAPIMPORTS"),
                Self::Gstoncapitalimports => write!(f, "GSTONCAPITALIMPORTS"),
                Self::Reversecharges => write!(f, "REVERSECHARGES"),
                Self::Payments => write!(f, "PAYMENTS"),
                Self::Invoice => write!(f, "INVOICE"),
                Self::Cash => write!(f, "CASH"),
                Self::Accrual => write!(f, "ACCRUAL"),
                Self::Flatratecash => write!(f, "FLATRATECASH"),
                Self::Flatrateaccrual => write!(f, "FLATRATEACCRUAL"),
                Self::Accruals => write!(f, "ACCRUALS"),
                Self::Txca => write!(f, "TXCA"),
                Self::Srcas => write!(f, "SRCAS"),
                Self::Dsoutput => write!(f, "DSOUTPUT"),
                Self::Blinput2 => write!(f, "BLINPUT2"),
                Self::Epinput => write!(f, "EPINPUT"),
                Self::Iminput2 => write!(f, "IMINPUT2"),
                Self::Meinput => write!(f, "MEINPUT"),
                Self::Igdsinput2 => write!(f, "IGDSINPUT2"),
                Self::Esn33output => write!(f, "ESN33OUTPUT"),
                Self::Opinput => write!(f, "OPINPUT"),
                Self::Osoutput => write!(f, "OSOUTPUT"),
                Self::Txn33input => write!(f, "TXN33INPUT"),
                Self::Txessinput => write!(f, "TXESSINPUT"),
                Self::Txreinput => write!(f, "TXREINPUT"),
                Self::Txpetinput => write!(f, "TXPETINPUT"),
                Self::Nrinput => write!(f, "NRINPUT"),
                Self::Es33output => write!(f, "ES33OUTPUT"),
                Self::Zeroratedinput => write!(f, "ZERORATEDINPUT"),
                Self::Zeroratedoutput => write!(f, "ZERORATEDOUTPUT"),
                Self::Drchargesupply => write!(f, "DRCHARGESUPPLY"),
                Self::Drcharge => write!(f, "DRCHARGE"),
                Self::Capinput => write!(f, "CAPINPUT"),
                Self::Capimports => write!(f, "CAPIMPORTS"),
                Self::Iminput => write!(f, "IMINPUT"),
                Self::Input2 => write!(f, "INPUT2"),
                Self::Ciuinput => write!(f, "CIUINPUT"),
                Self::Srinput => write!(f, "SRINPUT"),
                Self::Output2 => write!(f, "OUTPUT2"),
                Self::Sroutput => write!(f, "SROUTPUT"),
                Self::Capoutput => write!(f, "CAPOUTPUT"),
                Self::Sroutput2 => write!(f, "SROUTPUT2"),
                Self::Ciuoutput => write!(f, "CIUOUTPUT"),
                Self::Zroutput => write!(f, "ZROUTPUT"),
                Self::Zrexport => write!(f, "ZREXPORT"),
                Self::Acc28plus => write!(f, "ACC28PLUS"),
                Self::Accupto28 => write!(f, "ACCUPTO28"),
                Self::Otheroutput => write!(f, "OTHEROUTPUT"),
                Self::Shoutput => write!(f, "SHOUTPUT"),
                Self::Zrinput => write!(f, "ZRINPUT"),
                Self::Baddebt => write!(f, "BADDEBT"),
                Self::Otherinput => write!(f, "OTHERINPUT"),
                Self::Baddebtrelief => write!(f, "BADDEBTRELIEF"),
                Self::Igdsinput3 => write!(f, "IGDSINPUT3"),
                Self::Srovr => write!(f, "SROVR"),
                Self::Touristrefund => write!(f, "TOURISTREFUND"),
                Self::Txrcn33 => write!(f, "TXRCN33"),
                Self::Txrcre => write!(f, "TXRCRE"),
                Self::Txrcess => write!(f, "TXRCESS"),
                Self::Txrcts => write!(f, "TXRCTS"),
                Self::Capexinput => write!(f, "CAPEXINPUT"),
                Self::Undefined => write!(f, "UNDEFINED"),
                Self::Capexoutput => write!(f, "CAPEXOUTPUT"),
                Self::Zeroexpoutput => write!(f, "ZEROEXPOUTPUT"),
                Self::Goodsimport => write!(f, "GOODSIMPORT"),
                Self::Noneinput => write!(f, "NONEINPUT"),
                Self::Notreported => write!(f, "NOTREPORTED"),
                Self::Srovrrs => write!(f, "SROVRRS"),
                Self::Srovrlvg => write!(f, "SROVRLVG"),
                Self::Srlvg => write!(f, "SRLVG"),
                Self::Im => write!(f, "IM"),
                Self::Imess => write!(f, "IMESS"),
                Self::Imn33 => write!(f, "IMN33"),
                Self::Imre => write!(f, "IMRE"),
                Self::Baddebtrecovery => write!(f, "BADDEBTRECOVERY"),
                Self::Ussalestax => write!(f, "USSALESTAX"),
                Self::Blinput3 => write!(f, "BLINPUT3"),
            }
        }
    }

    impl std::str::FromStr for TaxRateReportTaxType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AVALARA" => Ok(Self::Avalara),
                "BASEXCLUDED" => Ok(Self::Basexcluded),
                "CAPITALSALESOUTPUT" => Ok(Self::Capitalsalesoutput),
                "CAPITALEXPENSESINPUT" => Ok(Self::Capitalexpensesinput),
                "ECOUTPUT" => Ok(Self::Ecoutput),
                "ECOUTPUTSERVICES" => Ok(Self::Ecoutputservices),
                "ECINPUT" => Ok(Self::Ecinput),
                "ECACQUISITIONS" => Ok(Self::Ecacquisitions),
                "EXEMPTEXPENSES" => Ok(Self::Exemptexpenses),
                "EXEMPTINPUT" => Ok(Self::Exemptinput),
                "EXEMPTOUTPUT" => Ok(Self::Exemptoutput),
                "GSTONIMPORTS" => Ok(Self::Gstonimports),
                "INPUT" => Ok(Self::Input),
                "INPUTTAXED" => Ok(Self::Inputtaxed),
                "MOSSSALES" => Ok(Self::Mosssales),
                "NONE" => Ok(Self::None),
                "NONEOUTPUT" => Ok(Self::Noneoutput),
                "OUTPUT" => Ok(Self::Output),
                "PURCHASESINPUT" => Ok(Self::Purchasesinput),
                "SALESOUTPUT" => Ok(Self::Salesoutput),
                "EXEMPTCAPITAL" => Ok(Self::Exemptcapital),
                "EXEMPTEXPORT" => Ok(Self::Exemptexport),
                "CAPITALEXINPUT" => Ok(Self::Capitalexinput),
                "GSTONCAPIMPORTS" => Ok(Self::Gstoncapimports),
                "GSTONCAPITALIMPORTS" => Ok(Self::Gstoncapitalimports),
                "REVERSECHARGES" => Ok(Self::Reversecharges),
                "PAYMENTS" => Ok(Self::Payments),
                "INVOICE" => Ok(Self::Invoice),
                "CASH" => Ok(Self::Cash),
                "ACCRUAL" => Ok(Self::Accrual),
                "FLATRATECASH" => Ok(Self::Flatratecash),
                "FLATRATEACCRUAL" => Ok(Self::Flatrateaccrual),
                "ACCRUALS" => Ok(Self::Accruals),
                "TXCA" => Ok(Self::Txca),
                "SRCAS" => Ok(Self::Srcas),
                "DSOUTPUT" => Ok(Self::Dsoutput),
                "BLINPUT2" => Ok(Self::Blinput2),
                "EPINPUT" => Ok(Self::Epinput),
                "IMINPUT2" => Ok(Self::Iminput2),
                "MEINPUT" => Ok(Self::Meinput),
                "IGDSINPUT2" => Ok(Self::Igdsinput2),
                "ESN33OUTPUT" => Ok(Self::Esn33output),
                "OPINPUT" => Ok(Self::Opinput),
                "OSOUTPUT" => Ok(Self::Osoutput),
                "TXN33INPUT" => Ok(Self::Txn33input),
                "TXESSINPUT" => Ok(Self::Txessinput),
                "TXREINPUT" => Ok(Self::Txreinput),
                "TXPETINPUT" => Ok(Self::Txpetinput),
                "NRINPUT" => Ok(Self::Nrinput),
                "ES33OUTPUT" => Ok(Self::Es33output),
                "ZERORATEDINPUT" => Ok(Self::Zeroratedinput),
                "ZERORATEDOUTPUT" => Ok(Self::Zeroratedoutput),
                "DRCHARGESUPPLY" => Ok(Self::Drchargesupply),
                "DRCHARGE" => Ok(Self::Drcharge),
                "CAPINPUT" => Ok(Self::Capinput),
                "CAPIMPORTS" => Ok(Self::Capimports),
                "IMINPUT" => Ok(Self::Iminput),
                "INPUT2" => Ok(Self::Input2),
                "CIUINPUT" => Ok(Self::Ciuinput),
                "SRINPUT" => Ok(Self::Srinput),
                "OUTPUT2" => Ok(Self::Output2),
                "SROUTPUT" => Ok(Self::Sroutput),
                "CAPOUTPUT" => Ok(Self::Capoutput),
                "SROUTPUT2" => Ok(Self::Sroutput2),
                "CIUOUTPUT" => Ok(Self::Ciuoutput),
                "ZROUTPUT" => Ok(Self::Zroutput),
                "ZREXPORT" => Ok(Self::Zrexport),
                "ACC28PLUS" => Ok(Self::Acc28plus),
                "ACCUPTO28" => Ok(Self::Accupto28),
                "OTHEROUTPUT" => Ok(Self::Otheroutput),
                "SHOUTPUT" => Ok(Self::Shoutput),
                "ZRINPUT" => Ok(Self::Zrinput),
                "BADDEBT" => Ok(Self::Baddebt),
                "OTHERINPUT" => Ok(Self::Otherinput),
                "BADDEBTRELIEF" => Ok(Self::Baddebtrelief),
                "IGDSINPUT3" => Ok(Self::Igdsinput3),
                "SROVR" => Ok(Self::Srovr),
                "TOURISTREFUND" => Ok(Self::Touristrefund),
                "TXRCN33" => Ok(Self::Txrcn33),
                "TXRCRE" => Ok(Self::Txrcre),
                "TXRCESS" => Ok(Self::Txrcess),
                "TXRCTS" => Ok(Self::Txrcts),
                "CAPEXINPUT" => Ok(Self::Capexinput),
                "UNDEFINED" => Ok(Self::Undefined),
                "CAPEXOUTPUT" => Ok(Self::Capexoutput),
                "ZEROEXPOUTPUT" => Ok(Self::Zeroexpoutput),
                "GOODSIMPORT" => Ok(Self::Goodsimport),
                "NONEINPUT" => Ok(Self::Noneinput),
                "NOTREPORTED" => Ok(Self::Notreported),
                "SROVRRS" => Ok(Self::Srovrrs),
                "SROVRLVG" => Ok(Self::Srovrlvg),
                "SRLVG" => Ok(Self::Srlvg),
                "IM" => Ok(Self::Im),
                "IMESS" => Ok(Self::Imess),
                "IMN33" => Ok(Self::Imn33),
                "IMRE" => Ok(Self::Imre),
                "BADDEBTRECOVERY" => Ok(Self::Baddebtrecovery),
                "USSALESTAX" => Ok(Self::Ussalestax),
                "BLINPUT3" => Ok(Self::Blinput3),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TaxRateReportTaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TaxRateReportTaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TaxRateReportTaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///See Status Codes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Status Codes",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "DELETED",
    ///    "ARCHIVED",
    ///    "PENDING"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TaxRateStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "DELETED")]
        Deleted,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "PENDING")]
        Pending,
    }

    impl From<&TaxRateStatus> for TaxRateStatus {
        fn from(value: &TaxRateStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TaxRateStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Deleted => write!(f, "DELETED"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Pending => write!(f, "PENDING"),
            }
        }
    }

    impl std::str::FromStr for TaxRateStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "DELETED" => Ok(Self::Deleted),
                "ARCHIVED" => Ok(Self::Archived),
                "PENDING" => Ok(Self::Pending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TaxRateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TaxRateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TaxRateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TaxRates
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "TaxRates": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaxRate"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "tax_rates"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaxRates {
        #[serde(rename = "TaxRates", default, skip_serializing_if = "Vec::is_empty")]
        pub tax_rates: Vec<TaxRate>,
    }

    impl From<&TaxRates> for TaxRates {
        fn from(value: &TaxRates) -> Self {
            value.clone()
        }
    }

    ///See Tax Types – can only be used on update calls
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "See Tax Types – can only be used on update calls",
    ///  "type": "string",
    ///  "enum": [
    ///    "OUTPUT",
    ///    "INPUT",
    ///    "CAPEXINPUT",
    ///    "EXEMPTEXPORT",
    ///    "EXEMPTEXPENSES",
    ///    "EXEMPTCAPITAL",
    ///    "EXEMPTOUTPUT",
    ///    "INPUTTAXED",
    ///    "BASEXCLUDED",
    ///    "GSTONCAPIMPORTS",
    ///    "GSTONIMPORTS",
    ///    "NONE",
    ///    "INPUT2",
    ///    "ZERORATED",
    ///    "OUTPUT2",
    ///    "CAPEXINPUT2",
    ///    "CAPEXOUTPUT",
    ///    "CAPEXOUTPUT2",
    ///    "CAPEXSRINPUT",
    ///    "CAPEXSROUTPUT",
    ///    "ECACQUISITIONS",
    ///    "ECZRINPUT",
    ///    "ECZROUTPUT",
    ///    "ECZROUTPUTSERVICES",
    ///    "EXEMPTINPUT",
    ///    "REVERSECHARGES",
    ///    "RRINPUT",
    ///    "RROUTPUT",
    ///    "SRINPUT",
    ///    "SROUTPUT",
    ///    "ZERORATEDINPUT",
    ///    "ZERORATEDOUTPUT",
    ///    "BLINPUT",
    ///    "DSOUTPUT",
    ///    "EPINPUT",
    ///    "ES33OUTPUT",
    ///    "ESN33OUTPUT",
    ///    "IGDSINPUT2",
    ///    "IMINPUT2",
    ///    "MEINPUT",
    ///    "NRINPUT",
    ///    "OPINPUT",
    ///    "OSOUTPUT",
    ///    "TXESSINPUT",
    ///    "TXN33INPUT",
    ///    "TXPETINPUT",
    ///    "TXREINPUT",
    ///    "INPUT3",
    ///    "INPUT4",
    ///    "OUTPUT3",
    ///    "OUTPUT4",
    ///    "SROUTPUT2",
    ///    "TXCA",
    ///    "SRCAS",
    ///    "BLINPUT2",
    ///    "DRCHARGESUPPLY20",
    ///    "DRCHARGE20",
    ///    "DRCHARGESUPPLY5",
    ///    "DRCHARGE5",
    ///    "BADDEBTRELIEF",
    ///    "IGDSINPUT3",
    ///    "SROVR",
    ///    "TOURISTREFUND",
    ///    "TXRCN33",
    ///    "TXRCRE",
    ///    "TXRCESS",
    ///    "TXRCTS",
    ///    "OUTPUTY23",
    ///    "DSOUTPUTY23",
    ///    "INPUTY23",
    ///    "IMINPUT2Y23",
    ///    "IGDSINPUT2Y23",
    ///    "TXPETINPUTY23",
    ///    "TXESSINPUTY23",
    ///    "TXN33INPUTY23",
    ///    "TXREINPUTY23",
    ///    "TXCAY23",
    ///    "BADDEBTRELIEFY23",
    ///    "IGDSINPUT3Y23",
    ///    "SROVRRSY23",
    ///    "SROVRLVGY23",
    ///    "SRLVGY23",
    ///    "TXRCN33Y23",
    ///    "TXRCREY23",
    ///    "TXRCESSY23",
    ///    "TXRCTSY23",
    ///    "IM",
    ///    "IMY23",
    ///    "IMESS",
    ///    "IMESSY23",
    ///    "IMN33",
    ///    "IMN33Y23",
    ///    "IMRE",
    ///    "IMREY23",
    ///    "BADDEBTRECOVERY",
    ///    "BADDEBTRECOVERYY23",
    ///    "OUTPUTY24",
    ///    "DSOUTPUTY24",
    ///    "INPUTY24",
    ///    "IGDSINPUT2Y24",
    ///    "TXPETINPUTY24",
    ///    "TXESSINPUTY24",
    ///    "TXN33INPUTY24",
    ///    "TXREINPUTY24",
    ///    "TXCAY24",
    ///    "BADDEBTRELIEFY24",
    ///    "IGDSINPUT3Y24",
    ///    "SROVRRSY24",
    ///    "SROVRLVGY24",
    ///    "SRLVGY24",
    ///    "TXRCTSY24",
    ///    "TXRCESSY24",
    ///    "TXRCN33Y24",
    ///    "TXRCREY24",
    ///    "IMY24",
    ///    "IMESSY24",
    ///    "IMN33Y24",
    ///    "IMREY24",
    ///    "BADDEBTRECOVERYY24",
    ///    "OSOUTPUT2",
    ///    "BLINPUT3",
    ///    "BLINPUT3Y23",
    ///    "BLINPUT3Y24"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TaxType {
        #[serde(rename = "OUTPUT")]
        Output,
        #[serde(rename = "INPUT")]
        Input,
        #[serde(rename = "CAPEXINPUT")]
        Capexinput,
        #[serde(rename = "EXEMPTEXPORT")]
        Exemptexport,
        #[serde(rename = "EXEMPTEXPENSES")]
        Exemptexpenses,
        #[serde(rename = "EXEMPTCAPITAL")]
        Exemptcapital,
        #[serde(rename = "EXEMPTOUTPUT")]
        Exemptoutput,
        #[serde(rename = "INPUTTAXED")]
        Inputtaxed,
        #[serde(rename = "BASEXCLUDED")]
        Basexcluded,
        #[serde(rename = "GSTONCAPIMPORTS")]
        Gstoncapimports,
        #[serde(rename = "GSTONIMPORTS")]
        Gstonimports,
        #[serde(rename = "NONE")]
        None,
        #[serde(rename = "INPUT2")]
        Input2,
        #[serde(rename = "ZERORATED")]
        Zerorated,
        #[serde(rename = "OUTPUT2")]
        Output2,
        #[serde(rename = "CAPEXINPUT2")]
        Capexinput2,
        #[serde(rename = "CAPEXOUTPUT")]
        Capexoutput,
        #[serde(rename = "CAPEXOUTPUT2")]
        Capexoutput2,
        #[serde(rename = "CAPEXSRINPUT")]
        Capexsrinput,
        #[serde(rename = "CAPEXSROUTPUT")]
        Capexsroutput,
        #[serde(rename = "ECACQUISITIONS")]
        Ecacquisitions,
        #[serde(rename = "ECZRINPUT")]
        Eczrinput,
        #[serde(rename = "ECZROUTPUT")]
        Eczroutput,
        #[serde(rename = "ECZROUTPUTSERVICES")]
        Eczroutputservices,
        #[serde(rename = "EXEMPTINPUT")]
        Exemptinput,
        #[serde(rename = "REVERSECHARGES")]
        Reversecharges,
        #[serde(rename = "RRINPUT")]
        Rrinput,
        #[serde(rename = "RROUTPUT")]
        Rroutput,
        #[serde(rename = "SRINPUT")]
        Srinput,
        #[serde(rename = "SROUTPUT")]
        Sroutput,
        #[serde(rename = "ZERORATEDINPUT")]
        Zeroratedinput,
        #[serde(rename = "ZERORATEDOUTPUT")]
        Zeroratedoutput,
        #[serde(rename = "BLINPUT")]
        Blinput,
        #[serde(rename = "DSOUTPUT")]
        Dsoutput,
        #[serde(rename = "EPINPUT")]
        Epinput,
        #[serde(rename = "ES33OUTPUT")]
        Es33output,
        #[serde(rename = "ESN33OUTPUT")]
        Esn33output,
        #[serde(rename = "IGDSINPUT2")]
        Igdsinput2,
        #[serde(rename = "IMINPUT2")]
        Iminput2,
        #[serde(rename = "MEINPUT")]
        Meinput,
        #[serde(rename = "NRINPUT")]
        Nrinput,
        #[serde(rename = "OPINPUT")]
        Opinput,
        #[serde(rename = "OSOUTPUT")]
        Osoutput,
        #[serde(rename = "TXESSINPUT")]
        Txessinput,
        #[serde(rename = "TXN33INPUT")]
        Txn33input,
        #[serde(rename = "TXPETINPUT")]
        Txpetinput,
        #[serde(rename = "TXREINPUT")]
        Txreinput,
        #[serde(rename = "INPUT3")]
        Input3,
        #[serde(rename = "INPUT4")]
        Input4,
        #[serde(rename = "OUTPUT3")]
        Output3,
        #[serde(rename = "OUTPUT4")]
        Output4,
        #[serde(rename = "SROUTPUT2")]
        Sroutput2,
        #[serde(rename = "TXCA")]
        Txca,
        #[serde(rename = "SRCAS")]
        Srcas,
        #[serde(rename = "BLINPUT2")]
        Blinput2,
        #[serde(rename = "DRCHARGESUPPLY20")]
        Drchargesupply20,
        #[serde(rename = "DRCHARGE20")]
        Drcharge20,
        #[serde(rename = "DRCHARGESUPPLY5")]
        Drchargesupply5,
        #[serde(rename = "DRCHARGE5")]
        Drcharge5,
        #[serde(rename = "BADDEBTRELIEF")]
        Baddebtrelief,
        #[serde(rename = "IGDSINPUT3")]
        Igdsinput3,
        #[serde(rename = "SROVR")]
        Srovr,
        #[serde(rename = "TOURISTREFUND")]
        Touristrefund,
        #[serde(rename = "TXRCN33")]
        Txrcn33,
        #[serde(rename = "TXRCRE")]
        Txrcre,
        #[serde(rename = "TXRCESS")]
        Txrcess,
        #[serde(rename = "TXRCTS")]
        Txrcts,
        #[serde(rename = "OUTPUTY23")]
        Outputy23,
        #[serde(rename = "DSOUTPUTY23")]
        Dsoutputy23,
        #[serde(rename = "INPUTY23")]
        Inputy23,
        #[serde(rename = "IMINPUT2Y23")]
        Iminput2y23,
        #[serde(rename = "IGDSINPUT2Y23")]
        Igdsinput2y23,
        #[serde(rename = "TXPETINPUTY23")]
        Txpetinputy23,
        #[serde(rename = "TXESSINPUTY23")]
        Txessinputy23,
        #[serde(rename = "TXN33INPUTY23")]
        Txn33inputy23,
        #[serde(rename = "TXREINPUTY23")]
        Txreinputy23,
        #[serde(rename = "TXCAY23")]
        Txcay23,
        #[serde(rename = "BADDEBTRELIEFY23")]
        Baddebtreliefy23,
        #[serde(rename = "IGDSINPUT3Y23")]
        Igdsinput3y23,
        #[serde(rename = "SROVRRSY23")]
        Srovrrsy23,
        #[serde(rename = "SROVRLVGY23")]
        Srovrlvgy23,
        #[serde(rename = "SRLVGY23")]
        Srlvgy23,
        #[serde(rename = "TXRCN33Y23")]
        Txrcn33y23,
        #[serde(rename = "TXRCREY23")]
        Txrcrey23,
        #[serde(rename = "TXRCESSY23")]
        Txrcessy23,
        #[serde(rename = "TXRCTSY23")]
        Txrctsy23,
        #[serde(rename = "IM")]
        Im,
        #[serde(rename = "IMY23")]
        Imy23,
        #[serde(rename = "IMESS")]
        Imess,
        #[serde(rename = "IMESSY23")]
        Imessy23,
        #[serde(rename = "IMN33")]
        Imn33,
        #[serde(rename = "IMN33Y23")]
        Imn33y23,
        #[serde(rename = "IMRE")]
        Imre,
        #[serde(rename = "IMREY23")]
        Imrey23,
        #[serde(rename = "BADDEBTRECOVERY")]
        Baddebtrecovery,
        #[serde(rename = "BADDEBTRECOVERYY23")]
        Baddebtrecoveryy23,
        #[serde(rename = "OUTPUTY24")]
        Outputy24,
        #[serde(rename = "DSOUTPUTY24")]
        Dsoutputy24,
        #[serde(rename = "INPUTY24")]
        Inputy24,
        #[serde(rename = "IGDSINPUT2Y24")]
        Igdsinput2y24,
        #[serde(rename = "TXPETINPUTY24")]
        Txpetinputy24,
        #[serde(rename = "TXESSINPUTY24")]
        Txessinputy24,
        #[serde(rename = "TXN33INPUTY24")]
        Txn33inputy24,
        #[serde(rename = "TXREINPUTY24")]
        Txreinputy24,
        #[serde(rename = "TXCAY24")]
        Txcay24,
        #[serde(rename = "BADDEBTRELIEFY24")]
        Baddebtreliefy24,
        #[serde(rename = "IGDSINPUT3Y24")]
        Igdsinput3y24,
        #[serde(rename = "SROVRRSY24")]
        Srovrrsy24,
        #[serde(rename = "SROVRLVGY24")]
        Srovrlvgy24,
        #[serde(rename = "SRLVGY24")]
        Srlvgy24,
        #[serde(rename = "TXRCTSY24")]
        Txrctsy24,
        #[serde(rename = "TXRCESSY24")]
        Txrcessy24,
        #[serde(rename = "TXRCN33Y24")]
        Txrcn33y24,
        #[serde(rename = "TXRCREY24")]
        Txrcrey24,
        #[serde(rename = "IMY24")]
        Imy24,
        #[serde(rename = "IMESSY24")]
        Imessy24,
        #[serde(rename = "IMN33Y24")]
        Imn33y24,
        #[serde(rename = "IMREY24")]
        Imrey24,
        #[serde(rename = "BADDEBTRECOVERYY24")]
        Baddebtrecoveryy24,
        #[serde(rename = "OSOUTPUT2")]
        Osoutput2,
        #[serde(rename = "BLINPUT3")]
        Blinput3,
        #[serde(rename = "BLINPUT3Y23")]
        Blinput3y23,
        #[serde(rename = "BLINPUT3Y24")]
        Blinput3y24,
    }

    impl From<&TaxType> for TaxType {
        fn from(value: &TaxType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TaxType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Output => write!(f, "OUTPUT"),
                Self::Input => write!(f, "INPUT"),
                Self::Capexinput => write!(f, "CAPEXINPUT"),
                Self::Exemptexport => write!(f, "EXEMPTEXPORT"),
                Self::Exemptexpenses => write!(f, "EXEMPTEXPENSES"),
                Self::Exemptcapital => write!(f, "EXEMPTCAPITAL"),
                Self::Exemptoutput => write!(f, "EXEMPTOUTPUT"),
                Self::Inputtaxed => write!(f, "INPUTTAXED"),
                Self::Basexcluded => write!(f, "BASEXCLUDED"),
                Self::Gstoncapimports => write!(f, "GSTONCAPIMPORTS"),
                Self::Gstonimports => write!(f, "GSTONIMPORTS"),
                Self::None => write!(f, "NONE"),
                Self::Input2 => write!(f, "INPUT2"),
                Self::Zerorated => write!(f, "ZERORATED"),
                Self::Output2 => write!(f, "OUTPUT2"),
                Self::Capexinput2 => write!(f, "CAPEXINPUT2"),
                Self::Capexoutput => write!(f, "CAPEXOUTPUT"),
                Self::Capexoutput2 => write!(f, "CAPEXOUTPUT2"),
                Self::Capexsrinput => write!(f, "CAPEXSRINPUT"),
                Self::Capexsroutput => write!(f, "CAPEXSROUTPUT"),
                Self::Ecacquisitions => write!(f, "ECACQUISITIONS"),
                Self::Eczrinput => write!(f, "ECZRINPUT"),
                Self::Eczroutput => write!(f, "ECZROUTPUT"),
                Self::Eczroutputservices => write!(f, "ECZROUTPUTSERVICES"),
                Self::Exemptinput => write!(f, "EXEMPTINPUT"),
                Self::Reversecharges => write!(f, "REVERSECHARGES"),
                Self::Rrinput => write!(f, "RRINPUT"),
                Self::Rroutput => write!(f, "RROUTPUT"),
                Self::Srinput => write!(f, "SRINPUT"),
                Self::Sroutput => write!(f, "SROUTPUT"),
                Self::Zeroratedinput => write!(f, "ZERORATEDINPUT"),
                Self::Zeroratedoutput => write!(f, "ZERORATEDOUTPUT"),
                Self::Blinput => write!(f, "BLINPUT"),
                Self::Dsoutput => write!(f, "DSOUTPUT"),
                Self::Epinput => write!(f, "EPINPUT"),
                Self::Es33output => write!(f, "ES33OUTPUT"),
                Self::Esn33output => write!(f, "ESN33OUTPUT"),
                Self::Igdsinput2 => write!(f, "IGDSINPUT2"),
                Self::Iminput2 => write!(f, "IMINPUT2"),
                Self::Meinput => write!(f, "MEINPUT"),
                Self::Nrinput => write!(f, "NRINPUT"),
                Self::Opinput => write!(f, "OPINPUT"),
                Self::Osoutput => write!(f, "OSOUTPUT"),
                Self::Txessinput => write!(f, "TXESSINPUT"),
                Self::Txn33input => write!(f, "TXN33INPUT"),
                Self::Txpetinput => write!(f, "TXPETINPUT"),
                Self::Txreinput => write!(f, "TXREINPUT"),
                Self::Input3 => write!(f, "INPUT3"),
                Self::Input4 => write!(f, "INPUT4"),
                Self::Output3 => write!(f, "OUTPUT3"),
                Self::Output4 => write!(f, "OUTPUT4"),
                Self::Sroutput2 => write!(f, "SROUTPUT2"),
                Self::Txca => write!(f, "TXCA"),
                Self::Srcas => write!(f, "SRCAS"),
                Self::Blinput2 => write!(f, "BLINPUT2"),
                Self::Drchargesupply20 => write!(f, "DRCHARGESUPPLY20"),
                Self::Drcharge20 => write!(f, "DRCHARGE20"),
                Self::Drchargesupply5 => write!(f, "DRCHARGESUPPLY5"),
                Self::Drcharge5 => write!(f, "DRCHARGE5"),
                Self::Baddebtrelief => write!(f, "BADDEBTRELIEF"),
                Self::Igdsinput3 => write!(f, "IGDSINPUT3"),
                Self::Srovr => write!(f, "SROVR"),
                Self::Touristrefund => write!(f, "TOURISTREFUND"),
                Self::Txrcn33 => write!(f, "TXRCN33"),
                Self::Txrcre => write!(f, "TXRCRE"),
                Self::Txrcess => write!(f, "TXRCESS"),
                Self::Txrcts => write!(f, "TXRCTS"),
                Self::Outputy23 => write!(f, "OUTPUTY23"),
                Self::Dsoutputy23 => write!(f, "DSOUTPUTY23"),
                Self::Inputy23 => write!(f, "INPUTY23"),
                Self::Iminput2y23 => write!(f, "IMINPUT2Y23"),
                Self::Igdsinput2y23 => write!(f, "IGDSINPUT2Y23"),
                Self::Txpetinputy23 => write!(f, "TXPETINPUTY23"),
                Self::Txessinputy23 => write!(f, "TXESSINPUTY23"),
                Self::Txn33inputy23 => write!(f, "TXN33INPUTY23"),
                Self::Txreinputy23 => write!(f, "TXREINPUTY23"),
                Self::Txcay23 => write!(f, "TXCAY23"),
                Self::Baddebtreliefy23 => write!(f, "BADDEBTRELIEFY23"),
                Self::Igdsinput3y23 => write!(f, "IGDSINPUT3Y23"),
                Self::Srovrrsy23 => write!(f, "SROVRRSY23"),
                Self::Srovrlvgy23 => write!(f, "SROVRLVGY23"),
                Self::Srlvgy23 => write!(f, "SRLVGY23"),
                Self::Txrcn33y23 => write!(f, "TXRCN33Y23"),
                Self::Txrcrey23 => write!(f, "TXRCREY23"),
                Self::Txrcessy23 => write!(f, "TXRCESSY23"),
                Self::Txrctsy23 => write!(f, "TXRCTSY23"),
                Self::Im => write!(f, "IM"),
                Self::Imy23 => write!(f, "IMY23"),
                Self::Imess => write!(f, "IMESS"),
                Self::Imessy23 => write!(f, "IMESSY23"),
                Self::Imn33 => write!(f, "IMN33"),
                Self::Imn33y23 => write!(f, "IMN33Y23"),
                Self::Imre => write!(f, "IMRE"),
                Self::Imrey23 => write!(f, "IMREY23"),
                Self::Baddebtrecovery => write!(f, "BADDEBTRECOVERY"),
                Self::Baddebtrecoveryy23 => write!(f, "BADDEBTRECOVERYY23"),
                Self::Outputy24 => write!(f, "OUTPUTY24"),
                Self::Dsoutputy24 => write!(f, "DSOUTPUTY24"),
                Self::Inputy24 => write!(f, "INPUTY24"),
                Self::Igdsinput2y24 => write!(f, "IGDSINPUT2Y24"),
                Self::Txpetinputy24 => write!(f, "TXPETINPUTY24"),
                Self::Txessinputy24 => write!(f, "TXESSINPUTY24"),
                Self::Txn33inputy24 => write!(f, "TXN33INPUTY24"),
                Self::Txreinputy24 => write!(f, "TXREINPUTY24"),
                Self::Txcay24 => write!(f, "TXCAY24"),
                Self::Baddebtreliefy24 => write!(f, "BADDEBTRELIEFY24"),
                Self::Igdsinput3y24 => write!(f, "IGDSINPUT3Y24"),
                Self::Srovrrsy24 => write!(f, "SROVRRSY24"),
                Self::Srovrlvgy24 => write!(f, "SROVRLVGY24"),
                Self::Srlvgy24 => write!(f, "SRLVGY24"),
                Self::Txrctsy24 => write!(f, "TXRCTSY24"),
                Self::Txrcessy24 => write!(f, "TXRCESSY24"),
                Self::Txrcn33y24 => write!(f, "TXRCN33Y24"),
                Self::Txrcrey24 => write!(f, "TXRCREY24"),
                Self::Imy24 => write!(f, "IMY24"),
                Self::Imessy24 => write!(f, "IMESSY24"),
                Self::Imn33y24 => write!(f, "IMN33Y24"),
                Self::Imrey24 => write!(f, "IMREY24"),
                Self::Baddebtrecoveryy24 => write!(f, "BADDEBTRECOVERYY24"),
                Self::Osoutput2 => write!(f, "OSOUTPUT2"),
                Self::Blinput3 => write!(f, "BLINPUT3"),
                Self::Blinput3y23 => write!(f, "BLINPUT3Y23"),
                Self::Blinput3y24 => write!(f, "BLINPUT3Y24"),
            }
        }
    }

    impl std::str::FromStr for TaxType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "OUTPUT" => Ok(Self::Output),
                "INPUT" => Ok(Self::Input),
                "CAPEXINPUT" => Ok(Self::Capexinput),
                "EXEMPTEXPORT" => Ok(Self::Exemptexport),
                "EXEMPTEXPENSES" => Ok(Self::Exemptexpenses),
                "EXEMPTCAPITAL" => Ok(Self::Exemptcapital),
                "EXEMPTOUTPUT" => Ok(Self::Exemptoutput),
                "INPUTTAXED" => Ok(Self::Inputtaxed),
                "BASEXCLUDED" => Ok(Self::Basexcluded),
                "GSTONCAPIMPORTS" => Ok(Self::Gstoncapimports),
                "GSTONIMPORTS" => Ok(Self::Gstonimports),
                "NONE" => Ok(Self::None),
                "INPUT2" => Ok(Self::Input2),
                "ZERORATED" => Ok(Self::Zerorated),
                "OUTPUT2" => Ok(Self::Output2),
                "CAPEXINPUT2" => Ok(Self::Capexinput2),
                "CAPEXOUTPUT" => Ok(Self::Capexoutput),
                "CAPEXOUTPUT2" => Ok(Self::Capexoutput2),
                "CAPEXSRINPUT" => Ok(Self::Capexsrinput),
                "CAPEXSROUTPUT" => Ok(Self::Capexsroutput),
                "ECACQUISITIONS" => Ok(Self::Ecacquisitions),
                "ECZRINPUT" => Ok(Self::Eczrinput),
                "ECZROUTPUT" => Ok(Self::Eczroutput),
                "ECZROUTPUTSERVICES" => Ok(Self::Eczroutputservices),
                "EXEMPTINPUT" => Ok(Self::Exemptinput),
                "REVERSECHARGES" => Ok(Self::Reversecharges),
                "RRINPUT" => Ok(Self::Rrinput),
                "RROUTPUT" => Ok(Self::Rroutput),
                "SRINPUT" => Ok(Self::Srinput),
                "SROUTPUT" => Ok(Self::Sroutput),
                "ZERORATEDINPUT" => Ok(Self::Zeroratedinput),
                "ZERORATEDOUTPUT" => Ok(Self::Zeroratedoutput),
                "BLINPUT" => Ok(Self::Blinput),
                "DSOUTPUT" => Ok(Self::Dsoutput),
                "EPINPUT" => Ok(Self::Epinput),
                "ES33OUTPUT" => Ok(Self::Es33output),
                "ESN33OUTPUT" => Ok(Self::Esn33output),
                "IGDSINPUT2" => Ok(Self::Igdsinput2),
                "IMINPUT2" => Ok(Self::Iminput2),
                "MEINPUT" => Ok(Self::Meinput),
                "NRINPUT" => Ok(Self::Nrinput),
                "OPINPUT" => Ok(Self::Opinput),
                "OSOUTPUT" => Ok(Self::Osoutput),
                "TXESSINPUT" => Ok(Self::Txessinput),
                "TXN33INPUT" => Ok(Self::Txn33input),
                "TXPETINPUT" => Ok(Self::Txpetinput),
                "TXREINPUT" => Ok(Self::Txreinput),
                "INPUT3" => Ok(Self::Input3),
                "INPUT4" => Ok(Self::Input4),
                "OUTPUT3" => Ok(Self::Output3),
                "OUTPUT4" => Ok(Self::Output4),
                "SROUTPUT2" => Ok(Self::Sroutput2),
                "TXCA" => Ok(Self::Txca),
                "SRCAS" => Ok(Self::Srcas),
                "BLINPUT2" => Ok(Self::Blinput2),
                "DRCHARGESUPPLY20" => Ok(Self::Drchargesupply20),
                "DRCHARGE20" => Ok(Self::Drcharge20),
                "DRCHARGESUPPLY5" => Ok(Self::Drchargesupply5),
                "DRCHARGE5" => Ok(Self::Drcharge5),
                "BADDEBTRELIEF" => Ok(Self::Baddebtrelief),
                "IGDSINPUT3" => Ok(Self::Igdsinput3),
                "SROVR" => Ok(Self::Srovr),
                "TOURISTREFUND" => Ok(Self::Touristrefund),
                "TXRCN33" => Ok(Self::Txrcn33),
                "TXRCRE" => Ok(Self::Txrcre),
                "TXRCESS" => Ok(Self::Txrcess),
                "TXRCTS" => Ok(Self::Txrcts),
                "OUTPUTY23" => Ok(Self::Outputy23),
                "DSOUTPUTY23" => Ok(Self::Dsoutputy23),
                "INPUTY23" => Ok(Self::Inputy23),
                "IMINPUT2Y23" => Ok(Self::Iminput2y23),
                "IGDSINPUT2Y23" => Ok(Self::Igdsinput2y23),
                "TXPETINPUTY23" => Ok(Self::Txpetinputy23),
                "TXESSINPUTY23" => Ok(Self::Txessinputy23),
                "TXN33INPUTY23" => Ok(Self::Txn33inputy23),
                "TXREINPUTY23" => Ok(Self::Txreinputy23),
                "TXCAY23" => Ok(Self::Txcay23),
                "BADDEBTRELIEFY23" => Ok(Self::Baddebtreliefy23),
                "IGDSINPUT3Y23" => Ok(Self::Igdsinput3y23),
                "SROVRRSY23" => Ok(Self::Srovrrsy23),
                "SROVRLVGY23" => Ok(Self::Srovrlvgy23),
                "SRLVGY23" => Ok(Self::Srlvgy23),
                "TXRCN33Y23" => Ok(Self::Txrcn33y23),
                "TXRCREY23" => Ok(Self::Txrcrey23),
                "TXRCESSY23" => Ok(Self::Txrcessy23),
                "TXRCTSY23" => Ok(Self::Txrctsy23),
                "IM" => Ok(Self::Im),
                "IMY23" => Ok(Self::Imy23),
                "IMESS" => Ok(Self::Imess),
                "IMESSY23" => Ok(Self::Imessy23),
                "IMN33" => Ok(Self::Imn33),
                "IMN33Y23" => Ok(Self::Imn33y23),
                "IMRE" => Ok(Self::Imre),
                "IMREY23" => Ok(Self::Imrey23),
                "BADDEBTRECOVERY" => Ok(Self::Baddebtrecovery),
                "BADDEBTRECOVERYY23" => Ok(Self::Baddebtrecoveryy23),
                "OUTPUTY24" => Ok(Self::Outputy24),
                "DSOUTPUTY24" => Ok(Self::Dsoutputy24),
                "INPUTY24" => Ok(Self::Inputy24),
                "IGDSINPUT2Y24" => Ok(Self::Igdsinput2y24),
                "TXPETINPUTY24" => Ok(Self::Txpetinputy24),
                "TXESSINPUTY24" => Ok(Self::Txessinputy24),
                "TXN33INPUTY24" => Ok(Self::Txn33inputy24),
                "TXREINPUTY24" => Ok(Self::Txreinputy24),
                "TXCAY24" => Ok(Self::Txcay24),
                "BADDEBTRELIEFY24" => Ok(Self::Baddebtreliefy24),
                "IGDSINPUT3Y24" => Ok(Self::Igdsinput3y24),
                "SROVRRSY24" => Ok(Self::Srovrrsy24),
                "SROVRLVGY24" => Ok(Self::Srovrlvgy24),
                "SRLVGY24" => Ok(Self::Srlvgy24),
                "TXRCTSY24" => Ok(Self::Txrctsy24),
                "TXRCESSY24" => Ok(Self::Txrcessy24),
                "TXRCN33Y24" => Ok(Self::Txrcn33y24),
                "TXRCREY24" => Ok(Self::Txrcrey24),
                "IMY24" => Ok(Self::Imy24),
                "IMESSY24" => Ok(Self::Imessy24),
                "IMN33Y24" => Ok(Self::Imn33y24),
                "IMREY24" => Ok(Self::Imrey24),
                "BADDEBTRECOVERYY24" => Ok(Self::Baddebtrecoveryy24),
                "OSOUTPUT2" => Ok(Self::Osoutput2),
                "BLINPUT3" => Ok(Self::Blinput3),
                "BLINPUT3Y23" => Ok(Self::Blinput3y23),
                "BLINPUT3Y24" => Ok(Self::Blinput3y24),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TaxType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TenNinetyNineContact
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "Box1": {
    ///      "description": "Box 1 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box10": {
    ///      "description": "Box 10 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box11": {
    ///      "description": "Box 11 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box13": {
    ///      "description": "Box 13 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box14": {
    ///      "description": "Box 14 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box2": {
    ///      "description": "Box 2 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box3": {
    ///      "description": "Box 3 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box4": {
    ///      "description": "Box 4 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box5": {
    ///      "description": "Box 5 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box6": {
    ///      "description": "Box 6 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box7": {
    ///      "description": "Box 7 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box8": {
    ///      "description": "Box 8 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "Box9": {
    ///      "description": "Box 9 on 1099 Form",
    ///      "type": "number",
    ///      "format": "double",
    ///      "x-is-money": true
    ///    },
    ///    "BusinessName": {
    ///      "description": "Contact business name",
    ///      "type": "string"
    ///    },
    ///    "City": {
    ///      "description": "Contact city on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "ContactId": {
    ///      "description": "Contact contact id",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "Email": {
    ///      "description": "Contact email on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "FederalTaxClassification": {
    ///      "description": "Contact federal tax classification",
    ///      "type": "string",
    ///      "enum": [
    ///        "SOLE_PROPRIETOR",
    ///        "PARTNERSHIP",
    ///        "TRUST_OR_ESTATE",
    ///        "NONPROFIT",
    ///        "C_CORP",
    ///        "S_CORP",
    ///        "OTHER"
    ///      ]
    ///    },
    ///    "FederalTaxIDType": {
    ///      "description": "Contact Fed Tax ID type",
    ///      "type": "string"
    ///    },
    ///    "LegalName": {
    ///      "description": "Contact legal name",
    ///      "type": "string"
    ///    },
    ///    "Name": {
    ///      "description": "Contact name on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "State": {
    ///      "description": "Contact State on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "StreetAddress": {
    ///      "description": "Contact address on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "TaxID": {
    ///      "description": "Contact tax id on 1099 Form",
    ///      "type": "string"
    ///    },
    ///    "Zip": {
    ///      "description": "Contact zip on 1099 Form",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TenNinetyNineContact {
        #[serde(rename = "Box1", default, skip_serializing_if = "Option::is_none")]
        pub box1: Option<f64>,
        #[serde(rename = "Box10", default, skip_serializing_if = "Option::is_none")]
        pub box10: Option<f64>,
        #[serde(rename = "Box11", default, skip_serializing_if = "Option::is_none")]
        pub box11: Option<f64>,
        #[serde(rename = "Box13", default, skip_serializing_if = "Option::is_none")]
        pub box13: Option<f64>,
        #[serde(rename = "Box14", default, skip_serializing_if = "Option::is_none")]
        pub box14: Option<f64>,
        #[serde(rename = "Box2", default, skip_serializing_if = "Option::is_none")]
        pub box2: Option<f64>,
        #[serde(rename = "Box3", default, skip_serializing_if = "Option::is_none")]
        pub box3: Option<f64>,
        #[serde(rename = "Box4", default, skip_serializing_if = "Option::is_none")]
        pub box4: Option<f64>,
        #[serde(rename = "Box5", default, skip_serializing_if = "Option::is_none")]
        pub box5: Option<f64>,
        #[serde(rename = "Box6", default, skip_serializing_if = "Option::is_none")]
        pub box6: Option<f64>,
        #[serde(rename = "Box7", default, skip_serializing_if = "Option::is_none")]
        pub box7: Option<f64>,
        #[serde(rename = "Box8", default, skip_serializing_if = "Option::is_none")]
        pub box8: Option<f64>,
        #[serde(rename = "Box9", default, skip_serializing_if = "Option::is_none")]
        pub box9: Option<f64>,
        ///Contact business name
        #[serde(
            rename = "BusinessName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub business_name: Option<String>,
        ///Contact city on 1099 Form
        #[serde(rename = "City", default, skip_serializing_if = "Option::is_none")]
        pub city: Option<String>,
        ///Contact contact id
        #[serde(rename = "ContactId", default, skip_serializing_if = "Option::is_none")]
        pub contact_id: Option<uuid::Uuid>,
        ///Contact email on 1099 Form
        #[serde(rename = "Email", default, skip_serializing_if = "Option::is_none")]
        pub email: Option<String>,
        ///Contact federal tax classification
        #[serde(
            rename = "FederalTaxClassification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub federal_tax_classification: Option<TenNinetyNineContactFederalTaxClassification>,
        ///Contact Fed Tax ID type
        #[serde(
            rename = "FederalTaxIDType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub federal_tax_id_type: Option<String>,
        ///Contact legal name
        #[serde(rename = "LegalName", default, skip_serializing_if = "Option::is_none")]
        pub legal_name: Option<String>,
        ///Contact name on 1099 Form
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        ///Contact State on 1099 Form
        #[serde(rename = "State", default, skip_serializing_if = "Option::is_none")]
        pub state: Option<String>,
        ///Contact address on 1099 Form
        #[serde(
            rename = "StreetAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub street_address: Option<String>,
        ///Contact tax id on 1099 Form
        #[serde(rename = "TaxID", default, skip_serializing_if = "Option::is_none")]
        pub tax_id: Option<String>,
        ///Contact zip on 1099 Form
        #[serde(rename = "Zip", default, skip_serializing_if = "Option::is_none")]
        pub zip: Option<String>,
    }

    impl From<&TenNinetyNineContact> for TenNinetyNineContact {
        fn from(value: &TenNinetyNineContact) -> Self {
            value.clone()
        }
    }

    ///Contact federal tax classification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contact federal tax classification",
    ///  "type": "string",
    ///  "enum": [
    ///    "SOLE_PROPRIETOR",
    ///    "PARTNERSHIP",
    ///    "TRUST_OR_ESTATE",
    ///    "NONPROFIT",
    ///    "C_CORP",
    ///    "S_CORP",
    ///    "OTHER"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TenNinetyNineContactFederalTaxClassification {
        #[serde(rename = "SOLE_PROPRIETOR")]
        SoleProprietor,
        #[serde(rename = "PARTNERSHIP")]
        Partnership,
        #[serde(rename = "TRUST_OR_ESTATE")]
        TrustOrEstate,
        #[serde(rename = "NONPROFIT")]
        Nonprofit,
        #[serde(rename = "C_CORP")]
        CCorp,
        #[serde(rename = "S_CORP")]
        SCorp,
        #[serde(rename = "OTHER")]
        Other,
    }

    impl From<&TenNinetyNineContactFederalTaxClassification>
        for TenNinetyNineContactFederalTaxClassification
    {
        fn from(value: &TenNinetyNineContactFederalTaxClassification) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TenNinetyNineContactFederalTaxClassification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SoleProprietor => write!(f, "SOLE_PROPRIETOR"),
                Self::Partnership => write!(f, "PARTNERSHIP"),
                Self::TrustOrEstate => write!(f, "TRUST_OR_ESTATE"),
                Self::Nonprofit => write!(f, "NONPROFIT"),
                Self::CCorp => write!(f, "C_CORP"),
                Self::SCorp => write!(f, "S_CORP"),
                Self::Other => write!(f, "OTHER"),
            }
        }
    }

    impl std::str::FromStr for TenNinetyNineContactFederalTaxClassification {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SOLE_PROPRIETOR" => Ok(Self::SoleProprietor),
                "PARTNERSHIP" => Ok(Self::Partnership),
                "TRUST_OR_ESTATE" => Ok(Self::TrustOrEstate),
                "NONPROFIT" => Ok(Self::Nonprofit),
                "C_CORP" => Ok(Self::CCorp),
                "S_CORP" => Ok(Self::SCorp),
                "OTHER" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TenNinetyNineContactFederalTaxClassification {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TenNinetyNineContactFederalTaxClassification {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TenNinetyNineContactFederalTaxClassification {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Timezone specifications
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Timezone specifications",
    ///  "type": "string",
    ///  "enum": [
    ///    "AFGHANISTANSTANDARDTIME",
    ///    "ALASKANSTANDARDTIME",
    ///    "ALEUTIANSTANDARDTIME",
    ///    "ALTAISTANDARDTIME",
    ///    "ARABIANSTANDARDTIME",
    ///    "ARABICSTANDARDTIME",
    ///    "ARABSTANDARDTIME",
    ///    "ARGENTINASTANDARDTIME",
    ///    "ASTRAKHANSTANDARDTIME",
    ///    "ATLANTICSTANDARDTIME",
    ///    "AUSCENTRALSTANDARDTIME",
    ///    "AUSCENTRALWSTANDARDTIME",
    ///    "AUSEASTERNSTANDARDTIME",
    ///    "AZERBAIJANSTANDARDTIME",
    ///    "AZORESSTANDARDTIME",
    ///    "BAHIASTANDARDTIME",
    ///    "BANGLADESHSTANDARDTIME",
    ///    "BELARUSSTANDARDTIME",
    ///    "BOUGAINVILLESTANDARDTIME",
    ///    "CANADACENTRALSTANDARDTIME",
    ///    "CAPEVERDESTANDARDTIME",
    ///    "CAUCASUSSTANDARDTIME",
    ///    "CENAUSTRALIASTANDARDTIME",
    ///    "CENTRALAMERICASTANDARDTIME",
    ///    "CENTRALASIASTANDARDTIME",
    ///    "CENTRALBRAZILIANSTANDARDTIME",
    ///    "CENTRALEUROPEANSTANDARDTIME",
    ///    "CENTRALEUROPESTANDARDTIME",
    ///    "CENTRALPACIFICSTANDARDTIME",
    ///    "CENTRALSTANDARDTIME",
    ///    "CENTRALSTANDARDTIME(MEXICO)",
    ///    "CHATHAMISLANDSSTANDARDTIME",
    ///    "CHINASTANDARDTIME",
    ///    "CUBASTANDARDTIME",
    ///    "DATELINESTANDARDTIME",
    ///    "EAFRICASTANDARDTIME",
    ///    "EASTERISLANDSTANDARDTIME",
    ///    "EASTERNSTANDARDTIME",
    ///    "EASTERNSTANDARDTIME(MEXICO)",
    ///    "EAUSTRALIASTANDARDTIME",
    ///    "EEUROPESTANDARDTIME",
    ///    "EGYPTSTANDARDTIME",
    ///    "EKATERINBURGSTANDARDTIME",
    ///    "ESOUTHAMERICASTANDARDTIME",
    ///    "FIJISTANDARDTIME",
    ///    "FLESTANDARDTIME",
    ///    "GEORGIANSTANDARDTIME",
    ///    "GMTSTANDARDTIME",
    ///    "GREENLANDSTANDARDTIME",
    ///    "GREENWICHSTANDARDTIME",
    ///    "GTBSTANDARDTIME",
    ///    "HAITISTANDARDTIME",
    ///    "HAWAIIANSTANDARDTIME",
    ///    "INDIASTANDARDTIME",
    ///    "IRANSTANDARDTIME",
    ///    "ISRAELSTANDARDTIME",
    ///    "JORDANSTANDARDTIME",
    ///    "KALININGRADSTANDARDTIME",
    ///    "KAMCHATKASTANDARDTIME",
    ///    "KOREASTANDARDTIME",
    ///    "LIBYASTANDARDTIME",
    ///    "LINEISLANDSSTANDARDTIME",
    ///    "LORDHOWESTANDARDTIME",
    ///    "MAGADANSTANDARDTIME",
    ///    "MAGALLANESSTANDARDTIME",
    ///    "MARQUESASSTANDARDTIME",
    ///    "MAURITIUSSTANDARDTIME",
    ///    "MIDATLANTICSTANDARDTIME",
    ///    "MIDDLEEASTSTANDARDTIME",
    ///    "MONTEVIDEOSTANDARDTIME",
    ///    "MOROCCOSTANDARDTIME",
    ///    "MOUNTAINSTANDARDTIME",
    ///    "MOUNTAINSTANDARDTIME(MEXICO)",
    ///    "MYANMARSTANDARDTIME",
    ///    "NAMIBIASTANDARDTIME",
    ///    "NCENTRALASIASTANDARDTIME",
    ///    "NEPALSTANDARDTIME",
    ///    "NEWFOUNDLANDSTANDARDTIME",
    ///    "NEWZEALANDSTANDARDTIME",
    ///    "NORFOLKSTANDARDTIME",
    ///    "NORTHASIAEASTSTANDARDTIME",
    ///    "NORTHASIASTANDARDTIME",
    ///    "NORTHKOREASTANDARDTIME",
    ///    "OMSKSTANDARDTIME",
    ///    "PACIFICSASTANDARDTIME",
    ///    "PACIFICSTANDARDTIME",
    ///    "PACIFICSTANDARDTIME(MEXICO)",
    ///    "PAKISTANSTANDARDTIME",
    ///    "PARAGUAYSTANDARDTIME",
    ///    "QYZYLORDASTANDARDTIME",
    ///    "ROMANCESTANDARDTIME",
    ///    "RUSSIANSTANDARDTIME",
    ///    "RUSSIATIMEZONE10",
    ///    "RUSSIATIMEZONE11",
    ///    "RUSSIATIMEZONE3",
    ///    "SAEASTERNSTANDARDTIME",
    ///    "SAINTPIERRESTANDARDTIME",
    ///    "SAKHALINSTANDARDTIME",
    ///    "SAMOASTANDARDTIME",
    ///    "SAOTOMESTANDARDTIME",
    ///    "SAPACIFICSTANDARDTIME",
    ///    "SARATOVSTANDARDTIME",
    ///    "SAWESTERNSTANDARDTIME",
    ///    "SEASIASTANDARDTIME",
    ///    "SINGAPORESTANDARDTIME",
    ///    "SOUTHAFRICASTANDARDTIME",
    ///    "SOUTHSUDANSTANDARDTIME",
    ///    "SRILANKASTANDARDTIME",
    ///    "SUDANSTANDARDTIME",
    ///    "SYRIASTANDARDTIME",
    ///    "TAIPEISTANDARDTIME",
    ///    "TASMANIASTANDARDTIME",
    ///    "TOCANTINSSTANDARDTIME",
    ///    "TOKYOSTANDARDTIME",
    ///    "TOMSKSTANDARDTIME",
    ///    "TONGASTANDARDTIME",
    ///    "TRANSBAIKALSTANDARDTIME",
    ///    "TURKEYSTANDARDTIME",
    ///    "TURKSANDCAICOSSTANDARDTIME",
    ///    "ULAANBAATARSTANDARDTIME",
    ///    "USEASTERNSTANDARDTIME",
    ///    "USMOUNTAINSTANDARDTIME",
    ///    "UTC",
    ///    "UTC+12",
    ///    "UTC+13",
    ///    "UTC02",
    ///    "UTC08",
    ///    "UTC09",
    ///    "UTC11",
    ///    "VENEZUELASTANDARDTIME",
    ///    "VLADIVOSTOKSTANDARDTIME",
    ///    "VOLGOGRADSTANDARDTIME",
    ///    "WAUSTRALIASTANDARDTIME",
    ///    "WCENTRALAFRICASTANDARDTIME",
    ///    "WESTASIASTANDARDTIME",
    ///    "WESTBANKSTANDARDTIME",
    ///    "WESTPACIFICSTANDARDTIME",
    ///    "WEUROPESTANDARDTIME",
    ///    "WMONGOLIASTANDARDTIME",
    ///    "YAKUTSKSTANDARDTIME",
    ///    "YUKONSTANDARDTIME"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TimeZone {
        #[serde(rename = "AFGHANISTANSTANDARDTIME")]
        Afghanistanstandardtime,
        #[serde(rename = "ALASKANSTANDARDTIME")]
        Alaskanstandardtime,
        #[serde(rename = "ALEUTIANSTANDARDTIME")]
        Aleutianstandardtime,
        #[serde(rename = "ALTAISTANDARDTIME")]
        Altaistandardtime,
        #[serde(rename = "ARABIANSTANDARDTIME")]
        Arabianstandardtime,
        #[serde(rename = "ARABICSTANDARDTIME")]
        Arabicstandardtime,
        #[serde(rename = "ARABSTANDARDTIME")]
        Arabstandardtime,
        #[serde(rename = "ARGENTINASTANDARDTIME")]
        Argentinastandardtime,
        #[serde(rename = "ASTRAKHANSTANDARDTIME")]
        Astrakhanstandardtime,
        #[serde(rename = "ATLANTICSTANDARDTIME")]
        Atlanticstandardtime,
        #[serde(rename = "AUSCENTRALSTANDARDTIME")]
        Auscentralstandardtime,
        #[serde(rename = "AUSCENTRALWSTANDARDTIME")]
        Auscentralwstandardtime,
        #[serde(rename = "AUSEASTERNSTANDARDTIME")]
        Auseasternstandardtime,
        #[serde(rename = "AZERBAIJANSTANDARDTIME")]
        Azerbaijanstandardtime,
        #[serde(rename = "AZORESSTANDARDTIME")]
        Azoresstandardtime,
        #[serde(rename = "BAHIASTANDARDTIME")]
        Bahiastandardtime,
        #[serde(rename = "BANGLADESHSTANDARDTIME")]
        Bangladeshstandardtime,
        #[serde(rename = "BELARUSSTANDARDTIME")]
        Belarusstandardtime,
        #[serde(rename = "BOUGAINVILLESTANDARDTIME")]
        Bougainvillestandardtime,
        #[serde(rename = "CANADACENTRALSTANDARDTIME")]
        Canadacentralstandardtime,
        #[serde(rename = "CAPEVERDESTANDARDTIME")]
        Capeverdestandardtime,
        #[serde(rename = "CAUCASUSSTANDARDTIME")]
        Caucasusstandardtime,
        #[serde(rename = "CENAUSTRALIASTANDARDTIME")]
        Cenaustraliastandardtime,
        #[serde(rename = "CENTRALAMERICASTANDARDTIME")]
        Centralamericastandardtime,
        #[serde(rename = "CENTRALASIASTANDARDTIME")]
        Centralasiastandardtime,
        #[serde(rename = "CENTRALBRAZILIANSTANDARDTIME")]
        Centralbrazilianstandardtime,
        #[serde(rename = "CENTRALEUROPEANSTANDARDTIME")]
        Centraleuropeanstandardtime,
        #[serde(rename = "CENTRALEUROPESTANDARDTIME")]
        Centraleuropestandardtime,
        #[serde(rename = "CENTRALPACIFICSTANDARDTIME")]
        Centralpacificstandardtime,
        #[serde(rename = "CENTRALSTANDARDTIME")]
        Centralstandardtime,
        #[serde(rename = "CENTRALSTANDARDTIME(MEXICO)")]
        CentralstandardtimeMexico,
        #[serde(rename = "CHATHAMISLANDSSTANDARDTIME")]
        Chathamislandsstandardtime,
        #[serde(rename = "CHINASTANDARDTIME")]
        Chinastandardtime,
        #[serde(rename = "CUBASTANDARDTIME")]
        Cubastandardtime,
        #[serde(rename = "DATELINESTANDARDTIME")]
        Datelinestandardtime,
        #[serde(rename = "EAFRICASTANDARDTIME")]
        Eafricastandardtime,
        #[serde(rename = "EASTERISLANDSTANDARDTIME")]
        Easterislandstandardtime,
        #[serde(rename = "EASTERNSTANDARDTIME")]
        Easternstandardtime,
        #[serde(rename = "EASTERNSTANDARDTIME(MEXICO)")]
        EasternstandardtimeMexico,
        #[serde(rename = "EAUSTRALIASTANDARDTIME")]
        Eaustraliastandardtime,
        #[serde(rename = "EEUROPESTANDARDTIME")]
        Eeuropestandardtime,
        #[serde(rename = "EGYPTSTANDARDTIME")]
        Egyptstandardtime,
        #[serde(rename = "EKATERINBURGSTANDARDTIME")]
        Ekaterinburgstandardtime,
        #[serde(rename = "ESOUTHAMERICASTANDARDTIME")]
        Esouthamericastandardtime,
        #[serde(rename = "FIJISTANDARDTIME")]
        Fijistandardtime,
        #[serde(rename = "FLESTANDARDTIME")]
        Flestandardtime,
        #[serde(rename = "GEORGIANSTANDARDTIME")]
        Georgianstandardtime,
        #[serde(rename = "GMTSTANDARDTIME")]
        Gmtstandardtime,
        #[serde(rename = "GREENLANDSTANDARDTIME")]
        Greenlandstandardtime,
        #[serde(rename = "GREENWICHSTANDARDTIME")]
        Greenwichstandardtime,
        #[serde(rename = "GTBSTANDARDTIME")]
        Gtbstandardtime,
        #[serde(rename = "HAITISTANDARDTIME")]
        Haitistandardtime,
        #[serde(rename = "HAWAIIANSTANDARDTIME")]
        Hawaiianstandardtime,
        #[serde(rename = "INDIASTANDARDTIME")]
        Indiastandardtime,
        #[serde(rename = "IRANSTANDARDTIME")]
        Iranstandardtime,
        #[serde(rename = "ISRAELSTANDARDTIME")]
        Israelstandardtime,
        #[serde(rename = "JORDANSTANDARDTIME")]
        Jordanstandardtime,
        #[serde(rename = "KALININGRADSTANDARDTIME")]
        Kaliningradstandardtime,
        #[serde(rename = "KAMCHATKASTANDARDTIME")]
        Kamchatkastandardtime,
        #[serde(rename = "KOREASTANDARDTIME")]
        Koreastandardtime,
        #[serde(rename = "LIBYASTANDARDTIME")]
        Libyastandardtime,
        #[serde(rename = "LINEISLANDSSTANDARDTIME")]
        Lineislandsstandardtime,
        #[serde(rename = "LORDHOWESTANDARDTIME")]
        Lordhowestandardtime,
        #[serde(rename = "MAGADANSTANDARDTIME")]
        Magadanstandardtime,
        #[serde(rename = "MAGALLANESSTANDARDTIME")]
        Magallanesstandardtime,
        #[serde(rename = "MARQUESASSTANDARDTIME")]
        Marquesasstandardtime,
        #[serde(rename = "MAURITIUSSTANDARDTIME")]
        Mauritiusstandardtime,
        #[serde(rename = "MIDATLANTICSTANDARDTIME")]
        Midatlanticstandardtime,
        #[serde(rename = "MIDDLEEASTSTANDARDTIME")]
        Middleeaststandardtime,
        #[serde(rename = "MONTEVIDEOSTANDARDTIME")]
        Montevideostandardtime,
        #[serde(rename = "MOROCCOSTANDARDTIME")]
        Moroccostandardtime,
        #[serde(rename = "MOUNTAINSTANDARDTIME")]
        Mountainstandardtime,
        #[serde(rename = "MOUNTAINSTANDARDTIME(MEXICO)")]
        MountainstandardtimeMexico,
        #[serde(rename = "MYANMARSTANDARDTIME")]
        Myanmarstandardtime,
        #[serde(rename = "NAMIBIASTANDARDTIME")]
        Namibiastandardtime,
        #[serde(rename = "NCENTRALASIASTANDARDTIME")]
        Ncentralasiastandardtime,
        #[serde(rename = "NEPALSTANDARDTIME")]
        Nepalstandardtime,
        #[serde(rename = "NEWFOUNDLANDSTANDARDTIME")]
        Newfoundlandstandardtime,
        #[serde(rename = "NEWZEALANDSTANDARDTIME")]
        Newzealandstandardtime,
        #[serde(rename = "NORFOLKSTANDARDTIME")]
        Norfolkstandardtime,
        #[serde(rename = "NORTHASIAEASTSTANDARDTIME")]
        Northasiaeaststandardtime,
        #[serde(rename = "NORTHASIASTANDARDTIME")]
        Northasiastandardtime,
        #[serde(rename = "NORTHKOREASTANDARDTIME")]
        Northkoreastandardtime,
        #[serde(rename = "OMSKSTANDARDTIME")]
        Omskstandardtime,
        #[serde(rename = "PACIFICSASTANDARDTIME")]
        Pacificsastandardtime,
        #[serde(rename = "PACIFICSTANDARDTIME")]
        Pacificstandardtime,
        #[serde(rename = "PACIFICSTANDARDTIME(MEXICO)")]
        PacificstandardtimeMexico,
        #[serde(rename = "PAKISTANSTANDARDTIME")]
        Pakistanstandardtime,
        #[serde(rename = "PARAGUAYSTANDARDTIME")]
        Paraguaystandardtime,
        #[serde(rename = "QYZYLORDASTANDARDTIME")]
        Qyzylordastandardtime,
        #[serde(rename = "ROMANCESTANDARDTIME")]
        Romancestandardtime,
        #[serde(rename = "RUSSIANSTANDARDTIME")]
        Russianstandardtime,
        #[serde(rename = "RUSSIATIMEZONE10")]
        Russiatimezone10,
        #[serde(rename = "RUSSIATIMEZONE11")]
        Russiatimezone11,
        #[serde(rename = "RUSSIATIMEZONE3")]
        Russiatimezone3,
        #[serde(rename = "SAEASTERNSTANDARDTIME")]
        Saeasternstandardtime,
        #[serde(rename = "SAINTPIERRESTANDARDTIME")]
        Saintpierrestandardtime,
        #[serde(rename = "SAKHALINSTANDARDTIME")]
        Sakhalinstandardtime,
        #[serde(rename = "SAMOASTANDARDTIME")]
        Samoastandardtime,
        #[serde(rename = "SAOTOMESTANDARDTIME")]
        Saotomestandardtime,
        #[serde(rename = "SAPACIFICSTANDARDTIME")]
        Sapacificstandardtime,
        #[serde(rename = "SARATOVSTANDARDTIME")]
        Saratovstandardtime,
        #[serde(rename = "SAWESTERNSTANDARDTIME")]
        Sawesternstandardtime,
        #[serde(rename = "SEASIASTANDARDTIME")]
        Seasiastandardtime,
        #[serde(rename = "SINGAPORESTANDARDTIME")]
        Singaporestandardtime,
        #[serde(rename = "SOUTHAFRICASTANDARDTIME")]
        Southafricastandardtime,
        #[serde(rename = "SOUTHSUDANSTANDARDTIME")]
        Southsudanstandardtime,
        #[serde(rename = "SRILANKASTANDARDTIME")]
        Srilankastandardtime,
        #[serde(rename = "SUDANSTANDARDTIME")]
        Sudanstandardtime,
        #[serde(rename = "SYRIASTANDARDTIME")]
        Syriastandardtime,
        #[serde(rename = "TAIPEISTANDARDTIME")]
        Taipeistandardtime,
        #[serde(rename = "TASMANIASTANDARDTIME")]
        Tasmaniastandardtime,
        #[serde(rename = "TOCANTINSSTANDARDTIME")]
        Tocantinsstandardtime,
        #[serde(rename = "TOKYOSTANDARDTIME")]
        Tokyostandardtime,
        #[serde(rename = "TOMSKSTANDARDTIME")]
        Tomskstandardtime,
        #[serde(rename = "TONGASTANDARDTIME")]
        Tongastandardtime,
        #[serde(rename = "TRANSBAIKALSTANDARDTIME")]
        Transbaikalstandardtime,
        #[serde(rename = "TURKEYSTANDARDTIME")]
        Turkeystandardtime,
        #[serde(rename = "TURKSANDCAICOSSTANDARDTIME")]
        Turksandcaicosstandardtime,
        #[serde(rename = "ULAANBAATARSTANDARDTIME")]
        Ulaanbaatarstandardtime,
        #[serde(rename = "USEASTERNSTANDARDTIME")]
        Useasternstandardtime,
        #[serde(rename = "USMOUNTAINSTANDARDTIME")]
        Usmountainstandardtime,
        #[serde(rename = "UTC")]
        Utc,
        #[serde(rename = "UTC+12")]
        Utc12,
        #[serde(rename = "UTC+13")]
        Utc13,
        #[serde(rename = "UTC02")]
        Utc02,
        #[serde(rename = "UTC08")]
        Utc08,
        #[serde(rename = "UTC09")]
        Utc09,
        #[serde(rename = "UTC11")]
        Utc11,
        #[serde(rename = "VENEZUELASTANDARDTIME")]
        Venezuelastandardtime,
        #[serde(rename = "VLADIVOSTOKSTANDARDTIME")]
        Vladivostokstandardtime,
        #[serde(rename = "VOLGOGRADSTANDARDTIME")]
        Volgogradstandardtime,
        #[serde(rename = "WAUSTRALIASTANDARDTIME")]
        Waustraliastandardtime,
        #[serde(rename = "WCENTRALAFRICASTANDARDTIME")]
        Wcentralafricastandardtime,
        #[serde(rename = "WESTASIASTANDARDTIME")]
        Westasiastandardtime,
        #[serde(rename = "WESTBANKSTANDARDTIME")]
        Westbankstandardtime,
        #[serde(rename = "WESTPACIFICSTANDARDTIME")]
        Westpacificstandardtime,
        #[serde(rename = "WEUROPESTANDARDTIME")]
        Weuropestandardtime,
        #[serde(rename = "WMONGOLIASTANDARDTIME")]
        Wmongoliastandardtime,
        #[serde(rename = "YAKUTSKSTANDARDTIME")]
        Yakutskstandardtime,
        #[serde(rename = "YUKONSTANDARDTIME")]
        Yukonstandardtime,
    }

    impl From<&TimeZone> for TimeZone {
        fn from(value: &TimeZone) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TimeZone {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Afghanistanstandardtime => write!(f, "AFGHANISTANSTANDARDTIME"),
                Self::Alaskanstandardtime => write!(f, "ALASKANSTANDARDTIME"),
                Self::Aleutianstandardtime => write!(f, "ALEUTIANSTANDARDTIME"),
                Self::Altaistandardtime => write!(f, "ALTAISTANDARDTIME"),
                Self::Arabianstandardtime => write!(f, "ARABIANSTANDARDTIME"),
                Self::Arabicstandardtime => write!(f, "ARABICSTANDARDTIME"),
                Self::Arabstandardtime => write!(f, "ARABSTANDARDTIME"),
                Self::Argentinastandardtime => write!(f, "ARGENTINASTANDARDTIME"),
                Self::Astrakhanstandardtime => write!(f, "ASTRAKHANSTANDARDTIME"),
                Self::Atlanticstandardtime => write!(f, "ATLANTICSTANDARDTIME"),
                Self::Auscentralstandardtime => write!(f, "AUSCENTRALSTANDARDTIME"),
                Self::Auscentralwstandardtime => write!(f, "AUSCENTRALWSTANDARDTIME"),
                Self::Auseasternstandardtime => write!(f, "AUSEASTERNSTANDARDTIME"),
                Self::Azerbaijanstandardtime => write!(f, "AZERBAIJANSTANDARDTIME"),
                Self::Azoresstandardtime => write!(f, "AZORESSTANDARDTIME"),
                Self::Bahiastandardtime => write!(f, "BAHIASTANDARDTIME"),
                Self::Bangladeshstandardtime => write!(f, "BANGLADESHSTANDARDTIME"),
                Self::Belarusstandardtime => write!(f, "BELARUSSTANDARDTIME"),
                Self::Bougainvillestandardtime => write!(f, "BOUGAINVILLESTANDARDTIME"),
                Self::Canadacentralstandardtime => write!(f, "CANADACENTRALSTANDARDTIME"),
                Self::Capeverdestandardtime => write!(f, "CAPEVERDESTANDARDTIME"),
                Self::Caucasusstandardtime => write!(f, "CAUCASUSSTANDARDTIME"),
                Self::Cenaustraliastandardtime => write!(f, "CENAUSTRALIASTANDARDTIME"),
                Self::Centralamericastandardtime => write!(f, "CENTRALAMERICASTANDARDTIME"),
                Self::Centralasiastandardtime => write!(f, "CENTRALASIASTANDARDTIME"),
                Self::Centralbrazilianstandardtime => write!(f, "CENTRALBRAZILIANSTANDARDTIME"),
                Self::Centraleuropeanstandardtime => write!(f, "CENTRALEUROPEANSTANDARDTIME"),
                Self::Centraleuropestandardtime => write!(f, "CENTRALEUROPESTANDARDTIME"),
                Self::Centralpacificstandardtime => write!(f, "CENTRALPACIFICSTANDARDTIME"),
                Self::Centralstandardtime => write!(f, "CENTRALSTANDARDTIME"),
                Self::CentralstandardtimeMexico => write!(f, "CENTRALSTANDARDTIME(MEXICO)"),
                Self::Chathamislandsstandardtime => write!(f, "CHATHAMISLANDSSTANDARDTIME"),
                Self::Chinastandardtime => write!(f, "CHINASTANDARDTIME"),
                Self::Cubastandardtime => write!(f, "CUBASTANDARDTIME"),
                Self::Datelinestandardtime => write!(f, "DATELINESTANDARDTIME"),
                Self::Eafricastandardtime => write!(f, "EAFRICASTANDARDTIME"),
                Self::Easterislandstandardtime => write!(f, "EASTERISLANDSTANDARDTIME"),
                Self::Easternstandardtime => write!(f, "EASTERNSTANDARDTIME"),
                Self::EasternstandardtimeMexico => write!(f, "EASTERNSTANDARDTIME(MEXICO)"),
                Self::Eaustraliastandardtime => write!(f, "EAUSTRALIASTANDARDTIME"),
                Self::Eeuropestandardtime => write!(f, "EEUROPESTANDARDTIME"),
                Self::Egyptstandardtime => write!(f, "EGYPTSTANDARDTIME"),
                Self::Ekaterinburgstandardtime => write!(f, "EKATERINBURGSTANDARDTIME"),
                Self::Esouthamericastandardtime => write!(f, "ESOUTHAMERICASTANDARDTIME"),
                Self::Fijistandardtime => write!(f, "FIJISTANDARDTIME"),
                Self::Flestandardtime => write!(f, "FLESTANDARDTIME"),
                Self::Georgianstandardtime => write!(f, "GEORGIANSTANDARDTIME"),
                Self::Gmtstandardtime => write!(f, "GMTSTANDARDTIME"),
                Self::Greenlandstandardtime => write!(f, "GREENLANDSTANDARDTIME"),
                Self::Greenwichstandardtime => write!(f, "GREENWICHSTANDARDTIME"),
                Self::Gtbstandardtime => write!(f, "GTBSTANDARDTIME"),
                Self::Haitistandardtime => write!(f, "HAITISTANDARDTIME"),
                Self::Hawaiianstandardtime => write!(f, "HAWAIIANSTANDARDTIME"),
                Self::Indiastandardtime => write!(f, "INDIASTANDARDTIME"),
                Self::Iranstandardtime => write!(f, "IRANSTANDARDTIME"),
                Self::Israelstandardtime => write!(f, "ISRAELSTANDARDTIME"),
                Self::Jordanstandardtime => write!(f, "JORDANSTANDARDTIME"),
                Self::Kaliningradstandardtime => write!(f, "KALININGRADSTANDARDTIME"),
                Self::Kamchatkastandardtime => write!(f, "KAMCHATKASTANDARDTIME"),
                Self::Koreastandardtime => write!(f, "KOREASTANDARDTIME"),
                Self::Libyastandardtime => write!(f, "LIBYASTANDARDTIME"),
                Self::Lineislandsstandardtime => write!(f, "LINEISLANDSSTANDARDTIME"),
                Self::Lordhowestandardtime => write!(f, "LORDHOWESTANDARDTIME"),
                Self::Magadanstandardtime => write!(f, "MAGADANSTANDARDTIME"),
                Self::Magallanesstandardtime => write!(f, "MAGALLANESSTANDARDTIME"),
                Self::Marquesasstandardtime => write!(f, "MARQUESASSTANDARDTIME"),
                Self::Mauritiusstandardtime => write!(f, "MAURITIUSSTANDARDTIME"),
                Self::Midatlanticstandardtime => write!(f, "MIDATLANTICSTANDARDTIME"),
                Self::Middleeaststandardtime => write!(f, "MIDDLEEASTSTANDARDTIME"),
                Self::Montevideostandardtime => write!(f, "MONTEVIDEOSTANDARDTIME"),
                Self::Moroccostandardtime => write!(f, "MOROCCOSTANDARDTIME"),
                Self::Mountainstandardtime => write!(f, "MOUNTAINSTANDARDTIME"),
                Self::MountainstandardtimeMexico => write!(f, "MOUNTAINSTANDARDTIME(MEXICO)"),
                Self::Myanmarstandardtime => write!(f, "MYANMARSTANDARDTIME"),
                Self::Namibiastandardtime => write!(f, "NAMIBIASTANDARDTIME"),
                Self::Ncentralasiastandardtime => write!(f, "NCENTRALASIASTANDARDTIME"),
                Self::Nepalstandardtime => write!(f, "NEPALSTANDARDTIME"),
                Self::Newfoundlandstandardtime => write!(f, "NEWFOUNDLANDSTANDARDTIME"),
                Self::Newzealandstandardtime => write!(f, "NEWZEALANDSTANDARDTIME"),
                Self::Norfolkstandardtime => write!(f, "NORFOLKSTANDARDTIME"),
                Self::Northasiaeaststandardtime => write!(f, "NORTHASIAEASTSTANDARDTIME"),
                Self::Northasiastandardtime => write!(f, "NORTHASIASTANDARDTIME"),
                Self::Northkoreastandardtime => write!(f, "NORTHKOREASTANDARDTIME"),
                Self::Omskstandardtime => write!(f, "OMSKSTANDARDTIME"),
                Self::Pacificsastandardtime => write!(f, "PACIFICSASTANDARDTIME"),
                Self::Pacificstandardtime => write!(f, "PACIFICSTANDARDTIME"),
                Self::PacificstandardtimeMexico => write!(f, "PACIFICSTANDARDTIME(MEXICO)"),
                Self::Pakistanstandardtime => write!(f, "PAKISTANSTANDARDTIME"),
                Self::Paraguaystandardtime => write!(f, "PARAGUAYSTANDARDTIME"),
                Self::Qyzylordastandardtime => write!(f, "QYZYLORDASTANDARDTIME"),
                Self::Romancestandardtime => write!(f, "ROMANCESTANDARDTIME"),
                Self::Russianstandardtime => write!(f, "RUSSIANSTANDARDTIME"),
                Self::Russiatimezone10 => write!(f, "RUSSIATIMEZONE10"),
                Self::Russiatimezone11 => write!(f, "RUSSIATIMEZONE11"),
                Self::Russiatimezone3 => write!(f, "RUSSIATIMEZONE3"),
                Self::Saeasternstandardtime => write!(f, "SAEASTERNSTANDARDTIME"),
                Self::Saintpierrestandardtime => write!(f, "SAINTPIERRESTANDARDTIME"),
                Self::Sakhalinstandardtime => write!(f, "SAKHALINSTANDARDTIME"),
                Self::Samoastandardtime => write!(f, "SAMOASTANDARDTIME"),
                Self::Saotomestandardtime => write!(f, "SAOTOMESTANDARDTIME"),
                Self::Sapacificstandardtime => write!(f, "SAPACIFICSTANDARDTIME"),
                Self::Saratovstandardtime => write!(f, "SARATOVSTANDARDTIME"),
                Self::Sawesternstandardtime => write!(f, "SAWESTERNSTANDARDTIME"),
                Self::Seasiastandardtime => write!(f, "SEASIASTANDARDTIME"),
                Self::Singaporestandardtime => write!(f, "SINGAPORESTANDARDTIME"),
                Self::Southafricastandardtime => write!(f, "SOUTHAFRICASTANDARDTIME"),
                Self::Southsudanstandardtime => write!(f, "SOUTHSUDANSTANDARDTIME"),
                Self::Srilankastandardtime => write!(f, "SRILANKASTANDARDTIME"),
                Self::Sudanstandardtime => write!(f, "SUDANSTANDARDTIME"),
                Self::Syriastandardtime => write!(f, "SYRIASTANDARDTIME"),
                Self::Taipeistandardtime => write!(f, "TAIPEISTANDARDTIME"),
                Self::Tasmaniastandardtime => write!(f, "TASMANIASTANDARDTIME"),
                Self::Tocantinsstandardtime => write!(f, "TOCANTINSSTANDARDTIME"),
                Self::Tokyostandardtime => write!(f, "TOKYOSTANDARDTIME"),
                Self::Tomskstandardtime => write!(f, "TOMSKSTANDARDTIME"),
                Self::Tongastandardtime => write!(f, "TONGASTANDARDTIME"),
                Self::Transbaikalstandardtime => write!(f, "TRANSBAIKALSTANDARDTIME"),
                Self::Turkeystandardtime => write!(f, "TURKEYSTANDARDTIME"),
                Self::Turksandcaicosstandardtime => write!(f, "TURKSANDCAICOSSTANDARDTIME"),
                Self::Ulaanbaatarstandardtime => write!(f, "ULAANBAATARSTANDARDTIME"),
                Self::Useasternstandardtime => write!(f, "USEASTERNSTANDARDTIME"),
                Self::Usmountainstandardtime => write!(f, "USMOUNTAINSTANDARDTIME"),
                Self::Utc => write!(f, "UTC"),
                Self::Utc12 => write!(f, "UTC+12"),
                Self::Utc13 => write!(f, "UTC+13"),
                Self::Utc02 => write!(f, "UTC02"),
                Self::Utc08 => write!(f, "UTC08"),
                Self::Utc09 => write!(f, "UTC09"),
                Self::Utc11 => write!(f, "UTC11"),
                Self::Venezuelastandardtime => write!(f, "VENEZUELASTANDARDTIME"),
                Self::Vladivostokstandardtime => write!(f, "VLADIVOSTOKSTANDARDTIME"),
                Self::Volgogradstandardtime => write!(f, "VOLGOGRADSTANDARDTIME"),
                Self::Waustraliastandardtime => write!(f, "WAUSTRALIASTANDARDTIME"),
                Self::Wcentralafricastandardtime => write!(f, "WCENTRALAFRICASTANDARDTIME"),
                Self::Westasiastandardtime => write!(f, "WESTASIASTANDARDTIME"),
                Self::Westbankstandardtime => write!(f, "WESTBANKSTANDARDTIME"),
                Self::Westpacificstandardtime => write!(f, "WESTPACIFICSTANDARDTIME"),
                Self::Weuropestandardtime => write!(f, "WEUROPESTANDARDTIME"),
                Self::Wmongoliastandardtime => write!(f, "WMONGOLIASTANDARDTIME"),
                Self::Yakutskstandardtime => write!(f, "YAKUTSKSTANDARDTIME"),
                Self::Yukonstandardtime => write!(f, "YUKONSTANDARDTIME"),
            }
        }
    }

    impl std::str::FromStr for TimeZone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AFGHANISTANSTANDARDTIME" => Ok(Self::Afghanistanstandardtime),
                "ALASKANSTANDARDTIME" => Ok(Self::Alaskanstandardtime),
                "ALEUTIANSTANDARDTIME" => Ok(Self::Aleutianstandardtime),
                "ALTAISTANDARDTIME" => Ok(Self::Altaistandardtime),
                "ARABIANSTANDARDTIME" => Ok(Self::Arabianstandardtime),
                "ARABICSTANDARDTIME" => Ok(Self::Arabicstandardtime),
                "ARABSTANDARDTIME" => Ok(Self::Arabstandardtime),
                "ARGENTINASTANDARDTIME" => Ok(Self::Argentinastandardtime),
                "ASTRAKHANSTANDARDTIME" => Ok(Self::Astrakhanstandardtime),
                "ATLANTICSTANDARDTIME" => Ok(Self::Atlanticstandardtime),
                "AUSCENTRALSTANDARDTIME" => Ok(Self::Auscentralstandardtime),
                "AUSCENTRALWSTANDARDTIME" => Ok(Self::Auscentralwstandardtime),
                "AUSEASTERNSTANDARDTIME" => Ok(Self::Auseasternstandardtime),
                "AZERBAIJANSTANDARDTIME" => Ok(Self::Azerbaijanstandardtime),
                "AZORESSTANDARDTIME" => Ok(Self::Azoresstandardtime),
                "BAHIASTANDARDTIME" => Ok(Self::Bahiastandardtime),
                "BANGLADESHSTANDARDTIME" => Ok(Self::Bangladeshstandardtime),
                "BELARUSSTANDARDTIME" => Ok(Self::Belarusstandardtime),
                "BOUGAINVILLESTANDARDTIME" => Ok(Self::Bougainvillestandardtime),
                "CANADACENTRALSTANDARDTIME" => Ok(Self::Canadacentralstandardtime),
                "CAPEVERDESTANDARDTIME" => Ok(Self::Capeverdestandardtime),
                "CAUCASUSSTANDARDTIME" => Ok(Self::Caucasusstandardtime),
                "CENAUSTRALIASTANDARDTIME" => Ok(Self::Cenaustraliastandardtime),
                "CENTRALAMERICASTANDARDTIME" => Ok(Self::Centralamericastandardtime),
                "CENTRALASIASTANDARDTIME" => Ok(Self::Centralasiastandardtime),
                "CENTRALBRAZILIANSTANDARDTIME" => Ok(Self::Centralbrazilianstandardtime),
                "CENTRALEUROPEANSTANDARDTIME" => Ok(Self::Centraleuropeanstandardtime),
                "CENTRALEUROPESTANDARDTIME" => Ok(Self::Centraleuropestandardtime),
                "CENTRALPACIFICSTANDARDTIME" => Ok(Self::Centralpacificstandardtime),
                "CENTRALSTANDARDTIME" => Ok(Self::Centralstandardtime),
                "CENTRALSTANDARDTIME(MEXICO)" => Ok(Self::CentralstandardtimeMexico),
                "CHATHAMISLANDSSTANDARDTIME" => Ok(Self::Chathamislandsstandardtime),
                "CHINASTANDARDTIME" => Ok(Self::Chinastandardtime),
                "CUBASTANDARDTIME" => Ok(Self::Cubastandardtime),
                "DATELINESTANDARDTIME" => Ok(Self::Datelinestandardtime),
                "EAFRICASTANDARDTIME" => Ok(Self::Eafricastandardtime),
                "EASTERISLANDSTANDARDTIME" => Ok(Self::Easterislandstandardtime),
                "EASTERNSTANDARDTIME" => Ok(Self::Easternstandardtime),
                "EASTERNSTANDARDTIME(MEXICO)" => Ok(Self::EasternstandardtimeMexico),
                "EAUSTRALIASTANDARDTIME" => Ok(Self::Eaustraliastandardtime),
                "EEUROPESTANDARDTIME" => Ok(Self::Eeuropestandardtime),
                "EGYPTSTANDARDTIME" => Ok(Self::Egyptstandardtime),
                "EKATERINBURGSTANDARDTIME" => Ok(Self::Ekaterinburgstandardtime),
                "ESOUTHAMERICASTANDARDTIME" => Ok(Self::Esouthamericastandardtime),
                "FIJISTANDARDTIME" => Ok(Self::Fijistandardtime),
                "FLESTANDARDTIME" => Ok(Self::Flestandardtime),
                "GEORGIANSTANDARDTIME" => Ok(Self::Georgianstandardtime),
                "GMTSTANDARDTIME" => Ok(Self::Gmtstandardtime),
                "GREENLANDSTANDARDTIME" => Ok(Self::Greenlandstandardtime),
                "GREENWICHSTANDARDTIME" => Ok(Self::Greenwichstandardtime),
                "GTBSTANDARDTIME" => Ok(Self::Gtbstandardtime),
                "HAITISTANDARDTIME" => Ok(Self::Haitistandardtime),
                "HAWAIIANSTANDARDTIME" => Ok(Self::Hawaiianstandardtime),
                "INDIASTANDARDTIME" => Ok(Self::Indiastandardtime),
                "IRANSTANDARDTIME" => Ok(Self::Iranstandardtime),
                "ISRAELSTANDARDTIME" => Ok(Self::Israelstandardtime),
                "JORDANSTANDARDTIME" => Ok(Self::Jordanstandardtime),
                "KALININGRADSTANDARDTIME" => Ok(Self::Kaliningradstandardtime),
                "KAMCHATKASTANDARDTIME" => Ok(Self::Kamchatkastandardtime),
                "KOREASTANDARDTIME" => Ok(Self::Koreastandardtime),
                "LIBYASTANDARDTIME" => Ok(Self::Libyastandardtime),
                "LINEISLANDSSTANDARDTIME" => Ok(Self::Lineislandsstandardtime),
                "LORDHOWESTANDARDTIME" => Ok(Self::Lordhowestandardtime),
                "MAGADANSTANDARDTIME" => Ok(Self::Magadanstandardtime),
                "MAGALLANESSTANDARDTIME" => Ok(Self::Magallanesstandardtime),
                "MARQUESASSTANDARDTIME" => Ok(Self::Marquesasstandardtime),
                "MAURITIUSSTANDARDTIME" => Ok(Self::Mauritiusstandardtime),
                "MIDATLANTICSTANDARDTIME" => Ok(Self::Midatlanticstandardtime),
                "MIDDLEEASTSTANDARDTIME" => Ok(Self::Middleeaststandardtime),
                "MONTEVIDEOSTANDARDTIME" => Ok(Self::Montevideostandardtime),
                "MOROCCOSTANDARDTIME" => Ok(Self::Moroccostandardtime),
                "MOUNTAINSTANDARDTIME" => Ok(Self::Mountainstandardtime),
                "MOUNTAINSTANDARDTIME(MEXICO)" => Ok(Self::MountainstandardtimeMexico),
                "MYANMARSTANDARDTIME" => Ok(Self::Myanmarstandardtime),
                "NAMIBIASTANDARDTIME" => Ok(Self::Namibiastandardtime),
                "NCENTRALASIASTANDARDTIME" => Ok(Self::Ncentralasiastandardtime),
                "NEPALSTANDARDTIME" => Ok(Self::Nepalstandardtime),
                "NEWFOUNDLANDSTANDARDTIME" => Ok(Self::Newfoundlandstandardtime),
                "NEWZEALANDSTANDARDTIME" => Ok(Self::Newzealandstandardtime),
                "NORFOLKSTANDARDTIME" => Ok(Self::Norfolkstandardtime),
                "NORTHASIAEASTSTANDARDTIME" => Ok(Self::Northasiaeaststandardtime),
                "NORTHASIASTANDARDTIME" => Ok(Self::Northasiastandardtime),
                "NORTHKOREASTANDARDTIME" => Ok(Self::Northkoreastandardtime),
                "OMSKSTANDARDTIME" => Ok(Self::Omskstandardtime),
                "PACIFICSASTANDARDTIME" => Ok(Self::Pacificsastandardtime),
                "PACIFICSTANDARDTIME" => Ok(Self::Pacificstandardtime),
                "PACIFICSTANDARDTIME(MEXICO)" => Ok(Self::PacificstandardtimeMexico),
                "PAKISTANSTANDARDTIME" => Ok(Self::Pakistanstandardtime),
                "PARAGUAYSTANDARDTIME" => Ok(Self::Paraguaystandardtime),
                "QYZYLORDASTANDARDTIME" => Ok(Self::Qyzylordastandardtime),
                "ROMANCESTANDARDTIME" => Ok(Self::Romancestandardtime),
                "RUSSIANSTANDARDTIME" => Ok(Self::Russianstandardtime),
                "RUSSIATIMEZONE10" => Ok(Self::Russiatimezone10),
                "RUSSIATIMEZONE11" => Ok(Self::Russiatimezone11),
                "RUSSIATIMEZONE3" => Ok(Self::Russiatimezone3),
                "SAEASTERNSTANDARDTIME" => Ok(Self::Saeasternstandardtime),
                "SAINTPIERRESTANDARDTIME" => Ok(Self::Saintpierrestandardtime),
                "SAKHALINSTANDARDTIME" => Ok(Self::Sakhalinstandardtime),
                "SAMOASTANDARDTIME" => Ok(Self::Samoastandardtime),
                "SAOTOMESTANDARDTIME" => Ok(Self::Saotomestandardtime),
                "SAPACIFICSTANDARDTIME" => Ok(Self::Sapacificstandardtime),
                "SARATOVSTANDARDTIME" => Ok(Self::Saratovstandardtime),
                "SAWESTERNSTANDARDTIME" => Ok(Self::Sawesternstandardtime),
                "SEASIASTANDARDTIME" => Ok(Self::Seasiastandardtime),
                "SINGAPORESTANDARDTIME" => Ok(Self::Singaporestandardtime),
                "SOUTHAFRICASTANDARDTIME" => Ok(Self::Southafricastandardtime),
                "SOUTHSUDANSTANDARDTIME" => Ok(Self::Southsudanstandardtime),
                "SRILANKASTANDARDTIME" => Ok(Self::Srilankastandardtime),
                "SUDANSTANDARDTIME" => Ok(Self::Sudanstandardtime),
                "SYRIASTANDARDTIME" => Ok(Self::Syriastandardtime),
                "TAIPEISTANDARDTIME" => Ok(Self::Taipeistandardtime),
                "TASMANIASTANDARDTIME" => Ok(Self::Tasmaniastandardtime),
                "TOCANTINSSTANDARDTIME" => Ok(Self::Tocantinsstandardtime),
                "TOKYOSTANDARDTIME" => Ok(Self::Tokyostandardtime),
                "TOMSKSTANDARDTIME" => Ok(Self::Tomskstandardtime),
                "TONGASTANDARDTIME" => Ok(Self::Tongastandardtime),
                "TRANSBAIKALSTANDARDTIME" => Ok(Self::Transbaikalstandardtime),
                "TURKEYSTANDARDTIME" => Ok(Self::Turkeystandardtime),
                "TURKSANDCAICOSSTANDARDTIME" => Ok(Self::Turksandcaicosstandardtime),
                "ULAANBAATARSTANDARDTIME" => Ok(Self::Ulaanbaatarstandardtime),
                "USEASTERNSTANDARDTIME" => Ok(Self::Useasternstandardtime),
                "USMOUNTAINSTANDARDTIME" => Ok(Self::Usmountainstandardtime),
                "UTC" => Ok(Self::Utc),
                "UTC+12" => Ok(Self::Utc12),
                "UTC+13" => Ok(Self::Utc13),
                "UTC02" => Ok(Self::Utc02),
                "UTC08" => Ok(Self::Utc08),
                "UTC09" => Ok(Self::Utc09),
                "UTC11" => Ok(Self::Utc11),
                "VENEZUELASTANDARDTIME" => Ok(Self::Venezuelastandardtime),
                "VLADIVOSTOKSTANDARDTIME" => Ok(Self::Vladivostokstandardtime),
                "VOLGOGRADSTANDARDTIME" => Ok(Self::Volgogradstandardtime),
                "WAUSTRALIASTANDARDTIME" => Ok(Self::Waustraliastandardtime),
                "WCENTRALAFRICASTANDARDTIME" => Ok(Self::Wcentralafricastandardtime),
                "WESTASIASTANDARDTIME" => Ok(Self::Westasiastandardtime),
                "WESTBANKSTANDARDTIME" => Ok(Self::Westbankstandardtime),
                "WESTPACIFICSTANDARDTIME" => Ok(Self::Westpacificstandardtime),
                "WEUROPESTANDARDTIME" => Ok(Self::Weuropestandardtime),
                "WMONGOLIASTANDARDTIME" => Ok(Self::Wmongoliastandardtime),
                "YAKUTSKSTANDARDTIME" => Ok(Self::Yakutskstandardtime),
                "YUKONSTANDARDTIME" => Ok(Self::Yukonstandardtime),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TimeZone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TimeZone {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TimeZone {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TrackingCategories
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "TrackingCategories": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingCategory"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "tracking_categories"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TrackingCategories {
        #[serde(
            rename = "TrackingCategories",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tracking_categories: Vec<TrackingCategory>,
    }

    impl From<&TrackingCategories> for TrackingCategories {
        fn from(value: &TrackingCategories) -> Self {
            value.clone()
        }
    }

    ///TrackingCategory
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Name": {
    ///      "description": "The name of the tracking category e.g. Department,
    /// Region (max length = 100)",
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "Option": {
    ///      "description": "The option name of the tracking option e.g. East,
    /// West (max length = 100)",
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "Options": {
    ///      "description": "See Tracking Options",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingOption"
    ///      }
    ///    },
    ///    "Status": {
    ///      "description": "The status of a tracking category",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "ARCHIVED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "TrackingCategoryID": {
    ///      "description": "The Xero identifier for a tracking category e.g.
    /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "TrackingOptionID": {
    ///      "description": "The Xero identifier for a tracking option e.g.
    /// dc54c220-0140-495a-b925-3246adc0075f",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TrackingCategory {
        ///The name of the tracking category e.g. Department, Region (max
        /// length = 100)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<TrackingCategoryName>,
        ///The option name of the tracking option e.g. East, West (max length =
        /// 100)
        #[serde(rename = "Option", default, skip_serializing_if = "Option::is_none")]
        pub option: Option<TrackingCategoryOption>,
        ///See Tracking Options
        #[serde(rename = "Options", default, skip_serializing_if = "Vec::is_empty")]
        pub options: Vec<TrackingOption>,
        ///The status of a tracking category
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<TrackingCategoryStatus>,
        ///The Xero identifier for a tracking category e.g.
        /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(
            rename = "TrackingCategoryID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_id: Option<uuid::Uuid>,
        ///The Xero identifier for a tracking option e.g.
        /// dc54c220-0140-495a-b925-3246adc0075f
        #[serde(
            rename = "TrackingOptionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_option_id: Option<uuid::Uuid>,
    }

    impl From<&TrackingCategory> for TrackingCategory {
        fn from(value: &TrackingCategory) -> Self {
            value.clone()
        }
    }

    ///The name of the tracking category e.g. Department, Region (max length =
    /// 100)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the tracking category e.g. Department,
    /// Region (max length = 100)",
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TrackingCategoryName(String);
    impl ::std::ops::Deref for TrackingCategoryName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TrackingCategoryName> for String {
        fn from(value: TrackingCategoryName) -> Self {
            value.0
        }
    }

    impl From<&TrackingCategoryName> for TrackingCategoryName {
        fn from(value: &TrackingCategoryName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TrackingCategoryName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TrackingCategoryName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TrackingCategoryName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TrackingCategoryName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TrackingCategoryName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The option name of the tracking option e.g. East, West (max length =
    /// 100)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The option name of the tracking option e.g. East, West
    /// (max length = 100)",
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TrackingCategoryOption(String);
    impl ::std::ops::Deref for TrackingCategoryOption {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TrackingCategoryOption> for String {
        fn from(value: TrackingCategoryOption) -> Self {
            value.0
        }
    }

    impl From<&TrackingCategoryOption> for TrackingCategoryOption {
        fn from(value: &TrackingCategoryOption) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TrackingCategoryOption {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TrackingCategoryOption {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TrackingCategoryOption {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TrackingCategoryOption {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TrackingCategoryOption {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The status of a tracking category
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of a tracking category",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "ARCHIVED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TrackingCategoryStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&TrackingCategoryStatus> for TrackingCategoryStatus {
        fn from(value: &TrackingCategoryStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TrackingCategoryStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for TrackingCategoryStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "ARCHIVED" => Ok(Self::Archived),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TrackingCategoryStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TrackingCategoryStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TrackingCategoryStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TrackingOption
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Name": {
    ///      "description": "The name of the tracking option e.g. Marketing,
    /// East (max length = 100)",
    ///      "type": "string",
    ///      "maxLength": 100
    ///    },
    ///    "Status": {
    ///      "description": "The status of a tracking option",
    ///      "type": "string",
    ///      "enum": [
    ///        "ACTIVE",
    ///        "ARCHIVED",
    ///        "DELETED"
    ///      ]
    ///    },
    ///    "TrackingCategoryID": {
    ///      "description": "Filter by a tracking category e.g.
    /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "TrackingOptionID": {
    ///      "description": "The Xero identifier for a tracking option e.g.
    /// ae777a87-5ef3-4fa0-a4f0-d10e1f13073a",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TrackingOption {
        ///The name of the tracking option e.g. Marketing, East (max length =
        /// 100)
        #[serde(rename = "Name", default, skip_serializing_if = "Option::is_none")]
        pub name: Option<TrackingOptionName>,
        ///The status of a tracking option
        #[serde(rename = "Status", default, skip_serializing_if = "Option::is_none")]
        pub status: Option<TrackingOptionStatus>,
        ///Filter by a tracking category e.g.
        /// 297c2dc5-cc47-4afd-8ec8-74990b8761e9
        #[serde(
            rename = "TrackingCategoryID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_category_id: Option<uuid::Uuid>,
        ///The Xero identifier for a tracking option e.g.
        /// ae777a87-5ef3-4fa0-a4f0-d10e1f13073a
        #[serde(
            rename = "TrackingOptionID",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub tracking_option_id: Option<uuid::Uuid>,
    }

    impl From<&TrackingOption> for TrackingOption {
        fn from(value: &TrackingOption) -> Self {
            value.clone()
        }
    }

    ///The name of the tracking option e.g. Marketing, East (max length = 100)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the tracking option e.g. Marketing, East
    /// (max length = 100)",
    ///  "type": "string",
    ///  "maxLength": 100
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TrackingOptionName(String);
    impl ::std::ops::Deref for TrackingOptionName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TrackingOptionName> for String {
        fn from(value: TrackingOptionName) -> Self {
            value.0
        }
    }

    impl From<&TrackingOptionName> for TrackingOptionName {
        fn from(value: &TrackingOptionName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TrackingOptionName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 100usize {
                return Err("longer than 100 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TrackingOptionName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TrackingOptionName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TrackingOptionName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TrackingOptionName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The status of a tracking option
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of a tracking option",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVE",
    ///    "ARCHIVED",
    ///    "DELETED"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TrackingOptionStatus {
        #[serde(rename = "ACTIVE")]
        Active,
        #[serde(rename = "ARCHIVED")]
        Archived,
        #[serde(rename = "DELETED")]
        Deleted,
    }

    impl From<&TrackingOptionStatus> for TrackingOptionStatus {
        fn from(value: &TrackingOptionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TrackingOptionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "ACTIVE"),
                Self::Archived => write!(f, "ARCHIVED"),
                Self::Deleted => write!(f, "DELETED"),
            }
        }
    }

    impl std::str::FromStr for TrackingOptionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVE" => Ok(Self::Active),
                "ARCHIVED" => Ok(Self::Archived),
                "DELETED" => Ok(Self::Deleted),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TrackingOptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TrackingOptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TrackingOptionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///TrackingOptions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Options": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrackingOption"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "options"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TrackingOptions {
        #[serde(rename = "Options", default, skip_serializing_if = "Vec::is_empty")]
        pub options: Vec<TrackingOption>,
    }

    impl From<&TrackingOptions> for TrackingOptions {
        fn from(value: &TrackingOptions) -> Self {
            value.clone()
        }
    }

    ///User
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "EmailAddress": {
    ///      "description": "Email address of user",
    ///      "type": "string"
    ///    },
    ///    "FirstName": {
    ///      "description": "First name of user",
    ///      "type": "string"
    ///    },
    ///    "IsSubscriber": {
    ///      "description": "Boolean to indicate if user is the subscriber",
    ///      "type": "boolean"
    ///    },
    ///    "LastName": {
    ///      "description": "Last name of user",
    ///      "type": "string"
    ///    },
    ///    "OrganisationRole": {
    ///      "description": "User role that defines permissions in Xero and via
    /// API (READONLY, INVOICEONLY, STANDARD, FINANCIALADVISER, etc)",
    ///      "type": "string",
    ///      "enum": [
    ///        "READONLY",
    ///        "INVOICEONLY",
    ///        "STANDARD",
    ///        "FINANCIALADVISER",
    ///        "MANAGEDCLIENT",
    ///        "CASHBOOKCLIENT",
    ///        "UNKNOWN"
    ///      ]
    ///    },
    ///    "UpdatedDateUTC": {
    ///      "description": "Timestamp of last change to user",
    ///      "readOnly": true,
    ///      "examples": [
    ///        "/Date(1573755038314)/"
    ///      ],
    ///      "type": "string",
    ///      "x-is-msdate-time": true
    ///    },
    ///    "UserID": {
    ///      "description": "Xero identifier",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct User {
        ///Email address of user
        #[serde(
            rename = "EmailAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub email_address: Option<String>,
        ///First name of user
        #[serde(rename = "FirstName", default, skip_serializing_if = "Option::is_none")]
        pub first_name: Option<String>,
        ///Boolean to indicate if user is the subscriber
        #[serde(
            rename = "IsSubscriber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub is_subscriber: Option<bool>,
        ///Last name of user
        #[serde(rename = "LastName", default, skip_serializing_if = "Option::is_none")]
        pub last_name: Option<String>,
        ///User role that defines permissions in Xero and via API (READONLY,
        /// INVOICEONLY, STANDARD, FINANCIALADVISER, etc)
        #[serde(
            rename = "OrganisationRole",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub organisation_role: Option<UserOrganisationRole>,
        ///Timestamp of last change to user
        #[serde(
            rename = "UpdatedDateUTC",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updated_date_utc: Option<String>,
        ///Xero identifier
        #[serde(rename = "UserID", default, skip_serializing_if = "Option::is_none")]
        pub user_id: Option<uuid::Uuid>,
    }

    impl From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    ///User role that defines permissions in Xero and via API (READONLY,
    /// INVOICEONLY, STANDARD, FINANCIALADVISER, etc)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "User role that defines permissions in Xero and via API
    /// (READONLY, INVOICEONLY, STANDARD, FINANCIALADVISER, etc)",
    ///  "type": "string",
    ///  "enum": [
    ///    "READONLY",
    ///    "INVOICEONLY",
    ///    "STANDARD",
    ///    "FINANCIALADVISER",
    ///    "MANAGEDCLIENT",
    ///    "CASHBOOKCLIENT",
    ///    "UNKNOWN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserOrganisationRole {
        #[serde(rename = "READONLY")]
        Readonly,
        #[serde(rename = "INVOICEONLY")]
        Invoiceonly,
        #[serde(rename = "STANDARD")]
        Standard,
        #[serde(rename = "FINANCIALADVISER")]
        Financialadviser,
        #[serde(rename = "MANAGEDCLIENT")]
        Managedclient,
        #[serde(rename = "CASHBOOKCLIENT")]
        Cashbookclient,
        #[serde(rename = "UNKNOWN")]
        Unknown,
    }

    impl From<&UserOrganisationRole> for UserOrganisationRole {
        fn from(value: &UserOrganisationRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserOrganisationRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Readonly => write!(f, "READONLY"),
                Self::Invoiceonly => write!(f, "INVOICEONLY"),
                Self::Standard => write!(f, "STANDARD"),
                Self::Financialadviser => write!(f, "FINANCIALADVISER"),
                Self::Managedclient => write!(f, "MANAGEDCLIENT"),
                Self::Cashbookclient => write!(f, "CASHBOOKCLIENT"),
                Self::Unknown => write!(f, "UNKNOWN"),
            }
        }
    }

    impl std::str::FromStr for UserOrganisationRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "READONLY" => Ok(Self::Readonly),
                "INVOICEONLY" => Ok(Self::Invoiceonly),
                "STANDARD" => Ok(Self::Standard),
                "FINANCIALADVISER" => Ok(Self::Financialadviser),
                "MANAGEDCLIENT" => Ok(Self::Managedclient),
                "CASHBOOKCLIENT" => Ok(Self::Cashbookclient),
                "UNKNOWN" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UserOrganisationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UserOrganisationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UserOrganisationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Users
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Users": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/User"
    ///      }
    ///    }
    ///  },
    ///  "x-objectArrayKey": "users"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Users {
        #[serde(rename = "Users", default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<User>,
    }

    impl From<&Users> for Users {
        fn from(value: &Users) -> Self {
            value.clone()
        }
    }

    ///ValidationError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "Message": {
    ///      "description": "Validation error message",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ValidationError {
        ///Validation error message
        #[serde(rename = "Message", default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }

    impl From<&ValidationError> for ValidationError {
        fn from(value: &ValidationError) -> Self {
            value.clone()
        }
    }
}

#[derive(Clone, Debug)]
///Client for Xero Accounting API
///
///https://developer.xero.com/xero-developer-platform-terms-conditions/
///
///Version: 6.3.0
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "6.3.0"
    }
}

#[allow(clippy::all)]
impl Client {
    ///Retrieves the full chart of accounts
    ///
    ///Sends a `GET` request to `/Accounts`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_accounts<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Accounts>, Error<()>> {
        let url = format!("{}/Accounts", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a new chart of accounts
    ///
    ///Sends a `PUT` request to `/Accounts`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Account object in body of request
    pub async fn create_account<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Account,
    ) -> Result<ResponseValue<types::Accounts>, Error<types::Error>> {
        let url = format!("{}/Accounts", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a single chart of accounts by using a unique account Id
    ///
    ///Sends a `GET` request to `/Accounts/{AccountID}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_account<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Accounts>, Error<()>> {
        let url = format!(
            "{}/Accounts/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a chart of accounts
    ///
    ///Sends a `POST` request to `/Accounts/{AccountID}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Request of type Accounts array with one Account
    pub async fn update_account<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Accounts,
    ) -> Result<ResponseValue<types::Accounts>, Error<types::Error>> {
        let url = format!(
            "{}/Accounts/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a chart of accounts
    ///
    ///Sends a `DELETE` request to `/Accounts/{AccountID}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_account<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Accounts>, Error<types::Error>> {
        let url = format!(
            "{}/Accounts/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific accounts by using a unique account
    /// Id
    ///
    ///Sends a `GET` request to `/Accounts/{AccountID}/Attachments`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_account_attachments<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/Accounts/{}/Attachments",
            self.baseurl,
            encode_path(&account_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific account using a unique
    /// attachment Id
    ///
    ///Sends a `GET` request to
    /// `/Accounts/{AccountID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_account_attachment_by_id<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Accounts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves an attachment for a specific account by filename
    ///
    ///Sends a `GET` request to `/Accounts/{AccountID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_account_attachment_by_file_name<'a>(
        &'a self,
        account_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Accounts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment on a specific account
    ///
    ///Sends a `PUT` request to `/Accounts/{AccountID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_account_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        account_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Accounts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates attachment on a specific account by filename
    ///
    ///Sends a `POST` request to `/Accounts/{AccountID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `account_id`: Unique identifier for Account object
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_account_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        account_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Accounts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&account_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves either one or many batch payments for invoices
    ///
    ///Sends a `GET` request to `/BatchPayments`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_batch_payments<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BatchPayments>, Error<()>> {
        let url = format!("{}/BatchPayments", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or many batch payments for invoices
    ///
    ///Sends a `PUT` request to `/BatchPayments`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: BatchPayments with an array of Payments in body of request
    pub async fn create_batch_payment<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BatchPayments,
    ) -> Result<ResponseValue<types::BatchPayments>, Error<types::Error>> {
        let url = format!("{}/BatchPayments", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific batch payment for invoices and credit notes
    ///
    ///Sends a `POST` request to `/BatchPayments`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn delete_batch_payment<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BatchPaymentDelete,
    ) -> Result<ResponseValue<types::BatchPayments>, Error<types::Error>> {
        let url = format!("{}/BatchPayments", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific batch payment using a unique batch payment Id
    ///
    ///Sends a `GET` request to `/BatchPayments/{BatchPaymentID}`
    ///
    ///Arguments:
    /// - `batch_payment_id`: Unique identifier for BatchPayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_batch_payment<'a>(
        &'a self,
        batch_payment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BatchPayments>, Error<()>> {
        let url = format!(
            "{}/BatchPayments/{}",
            self.baseurl,
            encode_path(&batch_payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific batch payment for invoices and credit notes
    ///
    ///Sends a `POST` request to `/BatchPayments/{BatchPaymentID}`
    ///
    ///Arguments:
    /// - `batch_payment_id`: Unique identifier for BatchPayment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn delete_batch_payment_by_url_param<'a>(
        &'a self,
        batch_payment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BatchPaymentDeleteByUrlParam,
    ) -> Result<ResponseValue<types::BatchPayments>, Error<types::Error>> {
        let url = format!(
            "{}/BatchPayments/{}",
            self.baseurl,
            encode_path(&batch_payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history from a specific batch payment
    ///
    ///Sends a `GET` request to `/BatchPayments/{BatchPaymentID}/History`
    ///
    ///Arguments:
    /// - `batch_payment_id`: Unique identifier for BatchPayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_batch_payment_history<'a>(
        &'a self,
        batch_payment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/BatchPayments/{}/History",
            self.baseurl,
            encode_path(&batch_payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific batch payment
    ///
    ///Sends a `PUT` request to `/BatchPayments/{BatchPaymentID}/History`
    ///
    ///Arguments:
    /// - `batch_payment_id`: Unique identifier for BatchPayment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_batch_payment_history_record<'a>(
        &'a self,
        batch_payment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/BatchPayments/{}/History",
            self.baseurl,
            encode_path(&batch_payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves any spent or received money transactions
    ///
    ///Sends a `GET` request to `/BankTransactions`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: Up to 100 bank transactions will be returned in a single API
    ///   call with line items details
    /// - `page_size`: Number of records to retrieve per page
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transactions<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BankTransactions>, Error<()>> {
        let url = format!("{}/BankTransactions", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more spent or received money transaction
    ///
    ///Sends a `PUT` request to `/BankTransactions`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: BankTransactions with an array of BankTransaction objects in
    ///   body of request
    pub async fn create_bank_transactions<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BankTransactions,
    ) -> Result<ResponseValue<types::BankTransactions>, Error<types::Error>> {
        let url = format!("{}/BankTransactions", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more spent or received money transaction
    ///
    ///Sends a `POST` request to `/BankTransactions`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_bank_transactions<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BankTransactions,
    ) -> Result<ResponseValue<types::BankTransactions>, Error<types::Error>> {
        let url = format!("{}/BankTransactions", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a single spent or received money transaction by using a unique
    /// bank transaction Id
    ///
    ///Sends a `GET` request to `/BankTransactions/{BankTransactionID}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transaction<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BankTransactions>, Error<()>> {
        let url = format!(
            "{}/BankTransactions/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a single spent or received money transaction
    ///
    ///Sends a `POST` request to `/BankTransactions/{BankTransactionID}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_bank_transaction<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BankTransactions,
    ) -> Result<ResponseValue<types::BankTransactions>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransactions/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves any attachments from a specific bank transactions
    ///
    ///Sends a `GET` request to
    /// `/BankTransactions/{BankTransactionID}/Attachments`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transaction_attachments<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/BankTransactions/{}/Attachments",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves specific attachments from a specific BankTransaction using a
    /// unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transaction_attachment_by_id<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/BankTransactions/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific bank transaction by
    /// filename
    ///
    ///Sends a `GET` request to
    /// `/BankTransactions/{BankTransactionID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transaction_attachment_by_file_name<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/BankTransactions/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment for a specific bank transaction by filename
    ///
    ///Sends a `PUT` request to
    /// `/BankTransactions/{BankTransactionID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_bank_transaction_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransactions/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment from a specific bank transaction by
    /// filename
    ///
    ///Sends a `POST` request to
    /// `/BankTransactions/{BankTransactionID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_bank_transaction_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransactions/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history from a specific bank transaction using a unique bank
    /// transaction Id
    ///
    ///Sends a `GET` request to `/BankTransactions/{BankTransactionID}/History`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transactions_history<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/BankTransactions/{}/History",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific bank transactions
    ///
    ///Sends a `PUT` request to `/BankTransactions/{BankTransactionID}/History`
    ///
    ///Arguments:
    /// - `bank_transaction_id`: Xero generated unique identifier for a bank
    ///   transaction
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_bank_transaction_history_record<'a>(
        &'a self,
        bank_transaction_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransactions/{}/History",
            self.baseurl,
            encode_path(&bank_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves all bank transfers
    ///
    ///Sends a `GET` request to `/BankTransfers`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfers<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BankTransfers>, Error<()>> {
        let url = format!("{}/BankTransfers", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a bank transfer
    ///
    ///Sends a `PUT` request to `/BankTransfers`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: BankTransfers with array of BankTransfer objects in request
    ///   body
    pub async fn create_bank_transfer<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::BankTransfers,
    ) -> Result<ResponseValue<types::BankTransfers>, Error<types::Error>> {
        let url = format!("{}/BankTransfers", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves specific bank transfers by using a unique bank transfer Id
    ///
    ///Sends a `GET` request to `/BankTransfers/{BankTransferID}`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfer<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BankTransfers>, Error<()>> {
        let url = format!(
            "{}/BankTransfers/{}",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments from a specific bank transfer
    ///
    ///Sends a `GET` request to `/BankTransfers/{BankTransferID}/Attachments`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfer_attachments<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/BankTransfers/{}/Attachments",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific bank transfer using a
    /// unique attachment ID
    ///
    ///Sends a `GET` request to
    /// `/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfer_attachment_by_id<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/BankTransfers/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment on a specific bank transfer by file name
    ///
    ///Sends a `GET` request to
    /// `/BankTransfers/{BankTransferID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfer_attachment_by_file_name<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/BankTransfers/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sends a `PUT` request to
    /// `/BankTransfers/{BankTransferID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_bank_transfer_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransfers/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sends a `POST` request to
    /// `/BankTransfers/{BankTransferID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_bank_transfer_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransfers/{}/Attachments/{}",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history from a specific bank transfer using a unique bank
    /// transfer Id
    ///
    ///Sends a `GET` request to `/BankTransfers/{BankTransferID}/History`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_bank_transfer_history<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/BankTransfers/{}/History",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific bank transfer
    ///
    ///Sends a `PUT` request to `/BankTransfers/{BankTransferID}/History`
    ///
    ///Arguments:
    /// - `bank_transfer_id`: Xero generated unique identifier for a bank
    ///   transfer
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_bank_transfer_history_record<'a>(
        &'a self,
        bank_transfer_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/BankTransfers/{}/History",
            self.baseurl,
            encode_path(&bank_transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves all the branding themes
    ///
    ///Sends a `GET` request to `/BrandingThemes`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_branding_themes<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BrandingThemes>, Error<()>> {
        let url = format!("{}/BrandingThemes", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific branding theme using a unique branding theme Id
    ///
    ///Sends a `GET` request to `/BrandingThemes/{BrandingThemeID}`
    ///
    ///Arguments:
    /// - `branding_theme_id`: Unique identifier for a Branding Theme
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_branding_theme<'a>(
        &'a self,
        branding_theme_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::BrandingThemes>, Error<()>> {
        let url = format!(
            "{}/BrandingThemes/{}",
            self.baseurl,
            encode_path(&branding_theme_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves the payment services for a specific branding theme
    ///
    ///Sends a `GET` request to
    /// `/BrandingThemes/{BrandingThemeID}/PaymentServices`
    ///
    ///Arguments:
    /// - `branding_theme_id`: Unique identifier for a Branding Theme
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_branding_theme_payment_services<'a>(
        &'a self,
        branding_theme_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::PaymentServices>, Error<()>> {
        let url = format!(
            "{}/BrandingThemes/{}/PaymentServices",
            self.baseurl,
            encode_path(&branding_theme_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a new custom payment service for a specific branding theme
    ///
    ///Sends a `POST` request to
    /// `/BrandingThemes/{BrandingThemeID}/PaymentServices`
    ///
    ///Arguments:
    /// - `branding_theme_id`: Unique identifier for a Branding Theme
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: PaymentServices array with PaymentService object in body of
    ///   request
    pub async fn create_branding_theme_payment_services<'a>(
        &'a self,
        branding_theme_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PaymentServices,
    ) -> Result<ResponseValue<types::PaymentServices>, Error<types::Error>> {
        let url = format!(
            "{}/BrandingThemes/{}/PaymentServices",
            self.baseurl,
            encode_path(&branding_theme_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve a list of budgets
    ///
    ///Sends a `GET` request to `/Budgets`
    ///
    ///Arguments:
    /// - `date_from`: Filter by end date
    /// - `date_to`: Filter by start date
    /// - `ids`: Filter by BudgetID. Allows you to retrieve a specific
    ///   individual budget.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_budgets<'a>(
        &'a self,
        date_from: Option<&'a chrono::naive::NaiveDate>,
        date_to: Option<&'a chrono::naive::NaiveDate>,
        ids: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Budgets>, Error<()>> {
        let url = format!("{}/Budgets", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &date_from {
            query.push(("DateFrom", v.to_string()));
        }

        if let Some(v) = &date_to {
            query.push(("DateTo", v.to_string()));
        }

        if let Some(v) = &ids {
            query.push(("IDs", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific budget, which includes budget lines
    ///
    ///Sends a `GET` request to `/Budgets/{BudgetID}`
    ///
    ///Arguments:
    /// - `budget_id`: Unique identifier for Budgets
    /// - `date_from`: Filter by end date
    /// - `date_to`: Filter by start date
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_budget<'a>(
        &'a self,
        budget_id: &'a uuid::Uuid,
        date_from: Option<&'a chrono::naive::NaiveDate>,
        date_to: Option<&'a chrono::naive::NaiveDate>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Budgets>, Error<()>> {
        let url = format!(
            "{}/Budgets/{}",
            self.baseurl,
            encode_path(&budget_id.to_string()),
        );
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &date_from {
            query.push(("DateFrom", v.to_string()));
        }

        if let Some(v) = &date_to {
            query.push(("DateTo", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves all contacts in a Xero organisation
    ///
    ///Sends a `GET` request to `/Contacts`
    ///
    ///Arguments:
    /// - `ids`: Filter by a comma separated list of ContactIDs. Allows you to
    ///   retrieve a specific set of contacts in a single call.
    /// - `include_archived`: e.g. includeArchived=true - Contacts with a status
    ///   of ARCHIVED will be included in the response
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 - Up to 100 contacts will be returned in a single
    ///   API call.
    /// - `page_size`: Number of records to retrieve per page
    /// - `search_term`: Search parameter that performs a case-insensitive text
    ///   search across the Name, FirstName, LastName, ContactNumber and
    ///   EmailAddress fields.
    /// - `summary_only`: Use summaryOnly=true in GET Contacts and Invoices
    ///   endpoint to retrieve a smaller version of the response object. This
    ///   returns only lightweight fields, excluding computation-heavy fields
    ///   from the response, making the API calls quick and efficient.
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contacts<'a>(
        &'a self,
        ids: Option<&'a Vec<uuid::Uuid>>,
        include_archived: Option<bool>,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        search_term: Option<&'a str>,
        summary_only: Option<bool>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Contacts>, Error<()>> {
        let url = format!("{}/Contacts", self.baseurl,);
        let mut query = Vec::with_capacity(8usize);
        if let Some(v) = ids {
            let mut ids_string = String::new();
            for id in v {
                let _ = write!(&mut ids_string, "{},", id.to_string());
            }
            query.push(("IDs", ids_string));
        }

        if let Some(v) = &include_archived {
            query.push(("includeArchived", v.to_string()));
        }

        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &search_term {
            query.push(("searchTerm", v.to_string()));
        }

        if let Some(v) = &summary_only {
            query.push(("summaryOnly", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates multiple contacts (bulk) in a Xero organisation
    ///
    ///Sends a `PUT` request to `/Contacts`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Contacts with an array of Contact objects to create in body of
    ///   request
    pub async fn create_contacts<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Contacts,
    ) -> Result<ResponseValue<types::Contacts>, Error<types::Error>> {
        let url = format!("{}/Contacts", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more contacts in a Xero organisation
    ///
    ///Sends a `POST` request to `/Contacts`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_contacts<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Contacts,
    ) -> Result<ResponseValue<types::Contacts>, Error<types::Error>> {
        let url = format!("{}/Contacts", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific contact by contact number in a Xero organisation
    ///
    ///Sends a `GET` request to `/Contacts/{ContactNumber}`
    ///
    ///Arguments:
    /// - `contact_number`: This field is read only on the Xero contact screen,
    ///   used to identify contacts in external systems (max length = 50).
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_by_contact_number<'a>(
        &'a self,
        contact_number: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Contacts>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}",
            self.baseurl,
            encode_path(&contact_number.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific contacts in a Xero organisation using a unique
    /// contact Id
    ///
    ///Sends a `GET` request to `/Contacts/{ContactID}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Contacts>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific contact in a Xero organisation
    ///
    ///Sends a `POST` request to `/Contacts/{ContactID}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: an array of Contacts containing single Contact object with
    ///   properties to update
    pub async fn update_contact<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Contacts,
    ) -> Result<ResponseValue<types::Contacts>, Error<types::Error>> {
        let url = format!(
            "{}/Contacts/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific contact in a Xero organisation
    ///
    ///Sends a `GET` request to `/Contacts/{ContactID}/Attachments`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_attachments<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}/Attachments",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific contact using a unique
    /// attachment Id
    ///
    ///Sends a `GET` request to
    /// `/Contacts/{ContactID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_attachment_by_id<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific contact by file name
    ///
    ///Sends a `GET` request to `/Contacts/{ContactID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_attachment_by_file_name<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sends a `PUT` request to `/Contacts/{ContactID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_contact_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Contacts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sends a `POST` request to `/Contacts/{ContactID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_contact_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Contacts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&contact_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves CIS settings for a specific contact in a Xero organisation
    ///
    ///Sends a `GET` request to `/Contacts/{ContactID}/CISSettings`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_cis_settings<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::CisSettings>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}/CISSettings",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records for a specific contact
    ///
    ///Sends a `GET` request to `/Contacts/{ContactID}/History`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_history<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Contacts/{}/History",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a new history record for a specific contact
    ///
    ///Sends a `PUT` request to `/Contacts/{ContactID}/History`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_contact_history<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Contacts/{}/History",
            self.baseurl,
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves the contact Id and name of each contact group
    ///
    ///Sends a `GET` request to `/ContactGroups`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_groups<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ContactGroups>, Error<()>> {
        let url = format!("{}/ContactGroups", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a contact group
    ///
    ///Sends a `PUT` request to `/ContactGroups`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: ContactGroups with an array of names in request body
    pub async fn create_contact_group<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ContactGroups,
    ) -> Result<ResponseValue<types::ContactGroups>, Error<types::Error>> {
        let url = format!("{}/ContactGroups", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific contact group by using a unique contact group Id
    ///
    ///Sends a `GET` request to `/ContactGroups/{ContactGroupID}`
    ///
    ///Arguments:
    /// - `contact_group_id`: Unique identifier for a Contact Group
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_contact_group<'a>(
        &'a self,
        contact_group_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ContactGroups>, Error<()>> {
        let url = format!(
            "{}/ContactGroups/{}",
            self.baseurl,
            encode_path(&contact_group_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific contact group
    ///
    ///Sends a `POST` request to `/ContactGroups/{ContactGroupID}`
    ///
    ///Arguments:
    /// - `contact_group_id`: Unique identifier for a Contact Group
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: an array of Contact groups with Name of specific group to
    ///   update
    pub async fn update_contact_group<'a>(
        &'a self,
        contact_group_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ContactGroups,
    ) -> Result<ResponseValue<types::ContactGroups>, Error<types::Error>> {
        let url = format!(
            "{}/ContactGroups/{}",
            self.baseurl,
            encode_path(&contact_group_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates contacts to a specific contact group
    ///
    ///Sends a `PUT` request to `/ContactGroups/{ContactGroupID}/Contacts`
    ///
    ///Arguments:
    /// - `contact_group_id`: Unique identifier for a Contact Group
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Contacts with array of contacts specifying the ContactID to be
    ///   added to ContactGroup in body of request
    pub async fn create_contact_group_contacts<'a>(
        &'a self,
        contact_group_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Contacts,
    ) -> Result<ResponseValue<types::Contacts>, Error<types::Error>> {
        let url = format!(
            "{}/ContactGroups/{}/Contacts",
            self.baseurl,
            encode_path(&contact_group_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes all contacts from a specific contact group
    ///
    ///Sends a `DELETE` request to `/ContactGroups/{ContactGroupID}/Contacts`
    ///
    ///Arguments:
    /// - `contact_group_id`: Unique identifier for a Contact Group
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_contact_group_contacts<'a>(
        &'a self,
        contact_group_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/ContactGroups/{}/Contacts",
            self.baseurl,
            encode_path(&contact_group_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific contact from a contact group using a unique contact
    /// Id
    ///
    ///Sends a `DELETE` request to
    /// `/ContactGroups/{ContactGroupID}/Contacts/{ContactID}`
    ///
    ///Arguments:
    /// - `contact_group_id`: Unique identifier for a Contact Group
    /// - `contact_id`: Unique identifier for a Contact
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_contact_group_contact<'a>(
        &'a self,
        contact_group_id: &'a uuid::Uuid,
        contact_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/ContactGroups/{}/Contacts/{}",
            self.baseurl,
            encode_path(&contact_group_id.to_string()),
            encode_path(&contact_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves any credit notes
    ///
    ///Sends a `GET` request to `/CreditNotes`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 credit notes will be returned in a
    ///   single API call with line items shown for each credit note
    /// - `page_size`: Number of records to retrieve per page
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_notes<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::CreditNotes>, Error<()>> {
        let url = format!("{}/CreditNotes", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a new credit note
    ///
    ///Sends a `PUT` request to `/CreditNotes`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Credit Notes with array of CreditNote object in body of
    ///   request
    pub async fn create_credit_notes<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::CreditNotes,
    ) -> Result<ResponseValue<types::CreditNotes>, Error<types::Error>> {
        let url = format!("{}/CreditNotes", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more credit notes
    ///
    ///Sends a `POST` request to `/CreditNotes`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: an array of Credit Notes with a single CreditNote object.
    pub async fn update_or_create_credit_notes<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::CreditNotes,
    ) -> Result<ResponseValue<types::CreditNotes>, Error<types::Error>> {
        let url = format!("{}/CreditNotes", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific credit note using a unique credit note Id
    ///
    ///Sends a `GET` request to `/CreditNotes/{CreditNoteID}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::CreditNotes>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific credit note
    ///
    ///Sends a `POST` request to `/CreditNotes/{CreditNoteID}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: an array of Credit Notes containing credit note details to
    ///   update
    pub async fn update_credit_note<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::CreditNotes,
    ) -> Result<ResponseValue<types::CreditNotes>, Error<types::Error>> {
        let url = format!(
            "{}/CreditNotes/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific credit notes
    ///
    ///Sends a `GET` request to `/CreditNotes/{CreditNoteID}/Attachments`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note_attachments<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/Attachments",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific credit note using a
    /// unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note_attachment_by_id<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment on a specific credit note by file name
    ///
    ///Sends a `GET` request to
    /// `/CreditNotes/{CreditNoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note_attachment_by_file_name<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment for a specific credit note
    ///
    ///Sends a `PUT` request to
    /// `/CreditNotes/{CreditNoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `file_name`: Name of the attachment
    /// - `include_online`: Allows an attachment to be seen by the end customer
    ///   within their online invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_credit_note_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        file_name: &'a str,
        include_online: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/CreditNotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &include_online {
            query.push(("IncludeOnline", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates attachments on a specific credit note by file name
    ///
    ///Sends a `POST` request to
    /// `/CreditNotes/{CreditNoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_credit_note_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/CreditNotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves credit notes as PDF files
    ///
    ///Sends a `GET` request to `/CreditNotes/{CreditNoteID}/pdf`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note_as_pdf<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/pdf",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates allocation for a specific credit note
    ///
    ///Sends a `PUT` request to `/CreditNotes/{CreditNoteID}/Allocations`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Allocations with array of Allocation object in body of
    ///   request.
    pub async fn create_credit_note_allocation<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Allocations,
    ) -> Result<ResponseValue<types::Allocations>, Error<types::Error>> {
        let url = format!(
            "{}/CreditNotes/{}/Allocations",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes an Allocation from a Credit Note
    ///
    ///Sends a `DELETE` request to
    /// `/CreditNotes/{CreditNoteID}/Allocations/{AllocationID}`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `allocation_id`: Unique identifier for Allocation object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_credit_note_allocations<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        allocation_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Allocation>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/Allocations/{}",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
            encode_path(&allocation_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific credit note
    ///
    ///Sends a `GET` request to `/CreditNotes/{CreditNoteID}/History`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_credit_note_history<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/CreditNotes/{}/History",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific credit note
    ///
    ///Sends a `PUT` request to `/CreditNotes/{CreditNoteID}/History`
    ///
    ///Arguments:
    /// - `credit_note_id`: Unique identifier for a Credit Note
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_credit_note_history<'a>(
        &'a self,
        credit_note_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/CreditNotes/{}/History",
            self.baseurl,
            encode_path(&credit_note_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves currencies for your Xero organisation
    ///
    ///Sends a `GET` request to `/Currencies`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_currencies<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Currencies>, Error<()>> {
        let url = format!("{}/Currencies", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a new currency for a Xero organisation
    ///
    ///Sends a `PUT` request to `/Currencies`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Currency object in the body of request
    pub async fn create_currency<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Currency,
    ) -> Result<ResponseValue<types::Currencies>, Error<()>> {
        let url = format!("{}/Currencies", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves employees used in Xero payrun
    ///
    ///Sends a `GET` request to `/Employees`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_employees<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Employees>, Error<()>> {
        let url = format!("{}/Employees", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates new employees used in Xero payrun
    ///
    ///Sends a `PUT` request to `/Employees`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Employees with array of Employee object in body of request
    pub async fn create_employees<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Employees,
    ) -> Result<ResponseValue<types::Employees>, Error<types::Error>> {
        let url = format!("{}/Employees", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a single new employees used in Xero payrun
    ///
    ///Sends a `POST` request to `/Employees`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Employees with array of Employee object in body of request
    pub async fn update_or_create_employees<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Employees,
    ) -> Result<ResponseValue<types::Employees>, Error<types::Error>> {
        let url = format!("{}/Employees", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific employee used in Xero payrun using a unique
    /// employee Id
    ///
    ///Sends a `GET` request to `/Employees/{EmployeeID}`
    ///
    ///Arguments:
    /// - `employee_id`: Unique identifier for a Employee
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_employee<'a>(
        &'a self,
        employee_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Employees>, Error<()>> {
        let url = format!(
            "{}/Employees/{}",
            self.baseurl,
            encode_path(&employee_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves expense claims
    ///
    ///Sends a `GET` request to `/ExpenseClaims`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_expense_claims<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ExpenseClaims>, Error<()>> {
        let url = format!("{}/ExpenseClaims", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates expense claims
    ///
    ///Sends a `PUT` request to `/ExpenseClaims`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: ExpenseClaims with array of ExpenseClaim object in body of
    ///   request
    pub async fn create_expense_claims<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ExpenseClaims,
    ) -> Result<ResponseValue<types::ExpenseClaims>, Error<types::Error>> {
        let url = format!("{}/ExpenseClaims", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific expense claim using a unique expense claim Id
    ///
    ///Sends a `GET` request to `/ExpenseClaims/{ExpenseClaimID}`
    ///
    ///Arguments:
    /// - `expense_claim_id`: Unique identifier for a ExpenseClaim
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_expense_claim<'a>(
        &'a self,
        expense_claim_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ExpenseClaims>, Error<()>> {
        let url = format!(
            "{}/ExpenseClaims/{}",
            self.baseurl,
            encode_path(&expense_claim_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific expense claims
    ///
    ///Sends a `POST` request to `/ExpenseClaims/{ExpenseClaimID}`
    ///
    ///Arguments:
    /// - `expense_claim_id`: Unique identifier for a ExpenseClaim
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_expense_claim<'a>(
        &'a self,
        expense_claim_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ExpenseClaims,
    ) -> Result<ResponseValue<types::ExpenseClaims>, Error<types::Error>> {
        let url = format!(
            "{}/ExpenseClaims/{}",
            self.baseurl,
            encode_path(&expense_claim_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific expense claim
    ///
    ///Sends a `GET` request to `/ExpenseClaims/{ExpenseClaimID}/History`
    ///
    ///Arguments:
    /// - `expense_claim_id`: Unique identifier for a ExpenseClaim
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_expense_claim_history<'a>(
        &'a self,
        expense_claim_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/ExpenseClaims/{}/History",
            self.baseurl,
            encode_path(&expense_claim_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific expense claim
    ///
    ///Sends a `PUT` request to `/ExpenseClaims/{ExpenseClaimID}/History`
    ///
    ///Arguments:
    /// - `expense_claim_id`: Unique identifier for a ExpenseClaim
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_expense_claim_history<'a>(
        &'a self,
        expense_claim_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/ExpenseClaims/{}/History",
            self.baseurl,
            encode_path(&expense_claim_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves sales invoices or purchase bills
    ///
    ///Sends a `GET` request to `/Invoices`
    ///
    ///Arguments:
    /// - `contact_ids`: Filter by a comma-separated list of ContactIDs.
    /// - `ids`: Filter by a comma-separated list of InvoicesIDs.
    /// - `invoice_numbers`: Filter by a comma-separated list of InvoiceNumbers.
    /// - `statuses`: Filter by a comma-separated list Statuses. For faster
    ///   response times we recommend using these explicit parameters instead of
    ///   passing OR conditions into the Where filter.
    /// - `created_by_my_app`: When set to true you'll only retrieve Invoices
    ///   created by your app
    /// - `include_archived`: e.g. includeArchived=true - Invoices with a status
    ///   of ARCHIVED will be included in the response
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 invoices will be returned in a single
    ///   API call with line items shown for each invoice
    /// - `page_size`: Number of records to retrieve per page
    /// - `search_term`: Search parameter that performs a case-insensitive text
    ///   search across the fields e.g. InvoiceNumber, Reference.
    /// - `summary_only`: Use summaryOnly=true in GET Contacts and Invoices
    ///   endpoint to retrieve a smaller version of the response object. This
    ///   returns only lightweight fields, excluding computation-heavy fields
    ///   from the response, making the API calls quick and efficient.
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoices<'a>(
        &'a self,
        contact_ids: Option<&'a Vec<uuid::Uuid>>,
        ids: Option<&'a Vec<uuid::Uuid>>,
        invoice_numbers: Option<&'a Vec<String>>,
        statuses: Option<&'a Vec<String>>,
        created_by_my_app: Option<bool>,
        include_archived: Option<bool>,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        search_term: Option<&'a str>,
        summary_only: Option<bool>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Invoices>, Error<()>> {
        let url = format!("{}/Invoices", self.baseurl,);
        let mut query = Vec::with_capacity(13usize);
        if let Some(v) = contact_ids {
            let mut contact_ids_string = String::new();
            for id in v {
                let _ = write!(&mut contact_ids_string, "{},", id.to_string());
            }
            query.push(("ContactIDs", contact_ids_string));
        }

        if let Some(v) = ids {
            let mut ids_string = String::new();
            for id in v {
                let _ = write!(&mut ids_string, "{},", id.to_string());
            }
            query.push(("IDs", ids_string));
        }

        if let Some(v) = invoice_numbers {
            let mut invoice_numbers_string = String::new();
            for id in v {
                let _ = write!(&mut invoice_numbers_string, "{},", id.to_string());
            }
            query.push(("InvoiceNumbers", invoice_numbers_string));
        }

        if let Some(v) = statuses {
            let mut statuses_string = String::new();
            for id in v {
                let _ = write!(&mut statuses_string, "{},", id.to_string());
            }
            query.push(("Statuses", statuses_string));
        }

        if let Some(v) = &created_by_my_app {
            query.push(("createdByMyApp", v.to_string()));
        }

        if let Some(v) = &include_archived {
            query.push(("includeArchived", v.to_string()));
        }

        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &search_term {
            query.push(("searchTerm", v.to_string()));
        }

        if let Some(v) = &summary_only {
            query.push(("summaryOnly", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more sales invoices or purchase bills
    ///
    ///Sends a `PUT` request to `/Invoices`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Invoices with an array of invoice objects in body of request
    pub async fn create_invoices<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Invoices,
    ) -> Result<ResponseValue<types::Invoices>, Error<types::Error>> {
        let url = format!("{}/Invoices", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more sales invoices or purchase bills
    ///
    ///Sends a `POST` request to `/Invoices`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_invoices<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Invoices,
    ) -> Result<ResponseValue<types::Invoices>, Error<types::Error>> {
        let url = format!("{}/Invoices", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific sales invoice or purchase bill using a unique
    /// invoice Id
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Invoices>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific sales invoices or purchase bills
    ///
    ///Sends a `POST` request to `/Invoices/{InvoiceID}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_invoice<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Invoices,
    ) -> Result<ResponseValue<types::Invoices>, Error<types::Error>> {
        let url = format!(
            "{}/Invoices/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves invoices or purchase bills as PDF files
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}/pdf`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_as_pdf<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/pdf",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific invoice or purchase bill
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}/Attachments`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_attachments<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/Attachments",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific invoices or purchase
    /// bills by using a unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/Invoices/{InvoiceID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_attachment_by_id<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves an attachment from a specific invoice or purchase bill by
    /// filename
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_attachment_by_file_name<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment for a specific invoice or purchase bill by
    /// filename
    ///
    ///Sends a `PUT` request to `/Invoices/{InvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `file_name`: Name of the attachment
    /// - `include_online`: Allows an attachment to be seen by the end customer
    ///   within their online invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_invoice_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        include_online: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Invoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &include_online {
            query.push(("IncludeOnline", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates an attachment from a specific invoices or purchase bill by
    /// filename
    ///
    ///Sends a `POST` request to `/Invoices/{InvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_invoice_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Invoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a URL to an online invoice
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}/OnlineInvoice`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_online_invoice<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::OnlineInvoices>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/OnlineInvoice",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sends a copy of a specific invoice to related contact via email
    ///
    ///Sends a `POST` request to `/Invoices/{InvoiceID}/Email`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn email_invoice<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::RequestEmpty,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/Invoices/{}/Email",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records for a specific invoice
    ///
    ///Sends a `GET` request to `/Invoices/{InvoiceID}/History`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_history<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Invoices/{}/History",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific invoice
    ///
    ///Sends a `PUT` request to `/Invoices/{InvoiceID}/History`
    ///
    ///Arguments:
    /// - `invoice_id`: Unique identifier for an Invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_invoice_history<'a>(
        &'a self,
        invoice_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Invoices/{}/History",
            self.baseurl,
            encode_path(&invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves invoice reminder settings
    ///
    ///Sends a `GET` request to `/InvoiceReminders/Settings`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_invoice_reminders<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::InvoiceReminders>, Error<()>> {
        let url = format!("{}/InvoiceReminders/Settings", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves items
    ///
    ///Sends a `GET` request to `/Items`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_items<'a>(
        &'a self,
        order: Option<&'a str>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Items>, Error<()>> {
        let url = format!("{}/Items", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more items
    ///
    ///Sends a `PUT` request to `/Items`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Items with an array of Item objects in body of request
    pub async fn create_items<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Items,
    ) -> Result<ResponseValue<types::Items>, Error<types::Error>> {
        let url = format!("{}/Items", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more items
    ///
    ///Sends a `POST` request to `/Items`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_items<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Items,
    ) -> Result<ResponseValue<types::Items>, Error<types::Error>> {
        let url = format!("{}/Items", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific item using a unique item Id
    ///
    ///Sends a `GET` request to `/Items/{ItemID}`
    ///
    ///Arguments:
    /// - `item_id`: Unique identifier for an Item
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_item<'a>(
        &'a self,
        item_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Items>, Error<()>> {
        let url = format!(
            "{}/Items/{}",
            self.baseurl,
            encode_path(&item_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific item
    ///
    ///Sends a `POST` request to `/Items/{ItemID}`
    ///
    ///Arguments:
    /// - `item_id`: Unique identifier for an Item
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_item<'a>(
        &'a self,
        item_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Items,
    ) -> Result<ResponseValue<types::Items>, Error<types::Error>> {
        let url = format!(
            "{}/Items/{}",
            self.baseurl,
            encode_path(&item_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific item
    ///
    ///Sends a `DELETE` request to `/Items/{ItemID}`
    ///
    ///Arguments:
    /// - `item_id`: Unique identifier for an Item
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_item<'a>(
        &'a self,
        item_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/Items/{}",
            self.baseurl,
            encode_path(&item_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history for a specific item
    ///
    ///Sends a `GET` request to `/Items/{ItemID}/History`
    ///
    ///Arguments:
    /// - `item_id`: Unique identifier for an Item
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_item_history<'a>(
        &'a self,
        item_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Items/{}/History",
            self.baseurl,
            encode_path(&item_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific item
    ///
    ///Sends a `PUT` request to `/Items/{ItemID}/History`
    ///
    ///Arguments:
    /// - `item_id`: Unique identifier for an Item
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_item_history<'a>(
        &'a self,
        item_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Items/{}/History",
            self.baseurl,
            encode_path(&item_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves journals
    ///
    ///Sends a `GET` request to `/Journals`
    ///
    ///Arguments:
    /// - `offset`: Offset by a specified journal number. e.g. journals with a
    ///   JournalNumber greater than the offset will be returned
    /// - `payments_only`: Filter to retrieve journals on a cash basis. Journals
    ///   are returned on an accrual basis by default.
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_journals<'a>(
        &'a self,
        offset: Option<i64>,
        payments_only: Option<bool>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Journals>, Error<()>> {
        let url = format!("{}/Journals", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &offset {
            query.push(("offset", v.to_string()));
        }

        if let Some(v) = &payments_only {
            query.push(("paymentsOnly", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific journal using a unique journal Id
    ///
    ///Sends a `GET` request to `/Journals/{JournalID}`
    ///
    ///Arguments:
    /// - `journal_id`: Unique identifier for a Journal
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_journal<'a>(
        &'a self,
        journal_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Journals>, Error<()>> {
        let url = format!(
            "{}/Journals/{}",
            self.baseurl,
            encode_path(&journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific journal using a unique journal number
    ///
    ///Sends a `GET` request to `/Journals/{JournalNumber}`
    ///
    ///Arguments:
    /// - `journal_number`: Number of a Journal
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_journal_by_number<'a>(
        &'a self,
        journal_number: i64,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Journals>, Error<()>> {
        let url = format!(
            "{}/Journals/{}",
            self.baseurl,
            encode_path(&journal_number.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves linked transactions (billable expenses)
    ///
    ///Sends a `GET` request to `/LinkedTransactions`
    ///
    ///Arguments:
    /// - `contact_id`: Filter by the ContactID. Get all the linked transactions
    ///   that have been assigned to a particular customer.
    /// - `linked_transaction_id`: The Xero identifier for an Linked Transaction
    /// - `source_transaction_id`: Filter by the SourceTransactionID. Get the
    ///   linked transactions created from a particular ACCPAY invoice
    /// - `status`: Filter by the combination of ContactID and Status. Get  the
    ///   linked transactions associated to a  customer and with a status
    /// - `target_transaction_id`: Filter by the TargetTransactionID. Get all
    ///   the linked transactions allocated to a particular ACCREC invoice
    /// - `page`: Up to 100 linked transactions will be returned in a single API
    ///   call. Use the page parameter to specify the page to be returned e.g.
    ///   page=1.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_linked_transactions<'a>(
        &'a self,
        contact_id: Option<&'a uuid::Uuid>,
        linked_transaction_id: Option<&'a uuid::Uuid>,
        source_transaction_id: Option<&'a uuid::Uuid>,
        status: Option<&'a str>,
        target_transaction_id: Option<&'a uuid::Uuid>,
        page: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::LinkedTransactions>, Error<()>> {
        let url = format!("{}/LinkedTransactions", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &contact_id {
            query.push(("ContactID", v.to_string()));
        }

        if let Some(v) = &linked_transaction_id {
            query.push(("LinkedTransactionID", v.to_string()));
        }

        if let Some(v) = &source_transaction_id {
            query.push(("SourceTransactionID", v.to_string()));
        }

        if let Some(v) = &status {
            query.push(("Status", v.to_string()));
        }

        if let Some(v) = &target_transaction_id {
            query.push(("TargetTransactionID", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates linked transactions (billable expenses)
    ///
    ///Sends a `PUT` request to `/LinkedTransactions`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: LinkedTransaction object in body of request
    pub async fn create_linked_transaction<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::LinkedTransaction,
    ) -> Result<ResponseValue<types::LinkedTransactions>, Error<types::Error>> {
        let url = format!("{}/LinkedTransactions", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific linked transaction (billable expenses) using a
    /// unique linked transaction Id
    ///
    ///Sends a `GET` request to `/LinkedTransactions/{LinkedTransactionID}`
    ///
    ///Arguments:
    /// - `linked_transaction_id`: Unique identifier for a LinkedTransaction
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_linked_transaction<'a>(
        &'a self,
        linked_transaction_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::LinkedTransactions>, Error<()>> {
        let url = format!(
            "{}/LinkedTransactions/{}",
            self.baseurl,
            encode_path(&linked_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific linked transactions (billable expenses)
    ///
    ///Sends a `POST` request to `/LinkedTransactions/{LinkedTransactionID}`
    ///
    ///Arguments:
    /// - `linked_transaction_id`: Unique identifier for a LinkedTransaction
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_linked_transaction<'a>(
        &'a self,
        linked_transaction_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::LinkedTransactions,
    ) -> Result<ResponseValue<types::LinkedTransactions>, Error<types::Error>> {
        let url = format!(
            "{}/LinkedTransactions/{}",
            self.baseurl,
            encode_path(&linked_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific linked transactions (billable expenses)
    ///
    ///Sends a `DELETE` request to `/LinkedTransactions/{LinkedTransactionID}`
    ///
    ///Arguments:
    /// - `linked_transaction_id`: Unique identifier for a LinkedTransaction
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_linked_transaction<'a>(
        &'a self,
        linked_transaction_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/LinkedTransactions/{}",
            self.baseurl,
            encode_path(&linked_transaction_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves manual journals
    ///
    ///Sends a `GET` request to `/ManualJournals`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 manual journals will be returned in a
    ///   single API call with line items shown for each overpayment
    /// - `page_size`: Number of records to retrieve per page
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journals<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ManualJournals>, Error<()>> {
        let url = format!("{}/ManualJournals", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more manual journals
    ///
    ///Sends a `PUT` request to `/ManualJournals`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: ManualJournals array with ManualJournal object in body of
    ///   request
    pub async fn create_manual_journals<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ManualJournals,
    ) -> Result<ResponseValue<types::ManualJournals>, Error<types::Error>> {
        let url = format!("{}/ManualJournals", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates a single manual journal
    ///
    ///Sends a `POST` request to `/ManualJournals`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: ManualJournals array with ManualJournal object in body of
    ///   request
    pub async fn update_or_create_manual_journals<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ManualJournals,
    ) -> Result<ResponseValue<types::ManualJournals>, Error<types::Error>> {
        let url = format!("{}/ManualJournals", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific manual journal
    ///
    ///Sends a `GET` request to `/ManualJournals/{ManualJournalID}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journal<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ManualJournals>, Error<()>> {
        let url = format!(
            "{}/ManualJournals/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific manual journal
    ///
    ///Sends a `POST` request to `/ManualJournals/{ManualJournalID}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_manual_journal<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::ManualJournals,
    ) -> Result<ResponseValue<types::ManualJournals>, Error<types::Error>> {
        let url = format!(
            "{}/ManualJournals/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachment for a specific manual journal
    ///
    ///Sends a `GET` request to `/ManualJournals/{ManualJournalID}/Attachments`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journal_attachments<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/ManualJournals/{}/Attachments",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Allows you to retrieve a specific attachment from a specific manual
    /// journal using a unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journal_attachment_by_id<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/ManualJournals/{}/Attachments/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific manual journal by file
    /// name
    ///
    ///Sends a `GET` request to
    /// `/ManualJournals/{ManualJournalID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journal_attachment_by_file_name<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/ManualJournals/{}/Attachments/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a specific attachment for a specific manual journal by file name
    ///
    ///Sends a `PUT` request to
    /// `/ManualJournals/{ManualJournalID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_manual_journal_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/ManualJournals/{}/Attachments/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment from a specific manual journal by file
    /// name
    ///
    ///Sends a `POST` request to
    /// `/ManualJournals/{ManualJournalID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_manual_journal_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/ManualJournals/{}/Attachments/{}",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history for a specific manual journal
    ///
    ///Sends a `GET` request to `/ManualJournals/{ManualJournalID}/History`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_manual_journals_history<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/ManualJournals/{}/History",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific manual journal
    ///
    ///Sends a `PUT` request to `/ManualJournals/{ManualJournalID}/History`
    ///
    ///Arguments:
    /// - `manual_journal_id`: Unique identifier for a ManualJournal
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_manual_journal_history_record<'a>(
        &'a self,
        manual_journal_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/ManualJournals/{}/History",
            self.baseurl,
            encode_path(&manual_journal_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves Xero organisation details
    ///
    ///Sends a `GET` request to `/Organisation`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_organisations<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Organisations>, Error<()>> {
        let url = format!("{}/Organisation", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a list of the key actions your app has permission to perform
    /// in the connected Xero organisation
    ///
    ///Sends a `GET` request to `/Organisation/Actions`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_organisation_actions<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Actions>, Error<()>> {
        let url = format!("{}/Organisation/Actions", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves the CIS settings for the Xero organistaion
    ///
    ///Sends a `GET` request to `/Organisation/{OrganisationID}/CISSettings`
    ///
    ///Arguments:
    /// - `organisation_id`: The unique Xero identifier for an organisation
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_organisation_cis_settings<'a>(
        &'a self,
        organisation_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::CisOrgSettings>, Error<()>> {
        let url = format!(
            "{}/Organisation/{}/CISSettings",
            self.baseurl,
            encode_path(&organisation_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves overpayments
    ///
    ///Sends a `GET` request to `/Overpayments`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 overpayments will be returned in a
    ///   single API call with line items shown for each overpayment
    /// - `page_size`: Number of records to retrieve per page
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_overpayments<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Overpayments>, Error<()>> {
        let url = format!("{}/Overpayments", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific overpayment using a unique overpayment Id
    ///
    ///Sends a `GET` request to `/Overpayments/{OverpaymentID}`
    ///
    ///Arguments:
    /// - `overpayment_id`: Unique identifier for a Overpayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_overpayment<'a>(
        &'a self,
        overpayment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Overpayments>, Error<()>> {
        let url = format!(
            "{}/Overpayments/{}",
            self.baseurl,
            encode_path(&overpayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a single allocation for a specific overpayment
    ///
    ///Sends a `PUT` request to `/Overpayments/{OverpaymentID}/Allocations`
    ///
    ///Arguments:
    /// - `overpayment_id`: Unique identifier for a Overpayment
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Allocations array with Allocation object in body of request
    pub async fn create_overpayment_allocations<'a>(
        &'a self,
        overpayment_id: &'a uuid::Uuid,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Allocations,
    ) -> Result<ResponseValue<types::Allocations>, Error<types::Error>> {
        let url = format!(
            "{}/Overpayments/{}/Allocations",
            self.baseurl,
            encode_path(&overpayment_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes an Allocation from an overpayment
    ///
    ///Sends a `DELETE` request to
    /// `/Overpayments/{OverpaymentID}/Allocations/{AllocationID}`
    ///
    ///Arguments:
    /// - `overpayment_id`: Unique identifier for a Overpayment
    /// - `allocation_id`: Unique identifier for Allocation object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_overpayment_allocations<'a>(
        &'a self,
        overpayment_id: &'a uuid::Uuid,
        allocation_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Allocation>, Error<()>> {
        let url = format!(
            "{}/Overpayments/{}/Allocations/{}",
            self.baseurl,
            encode_path(&overpayment_id.to_string()),
            encode_path(&allocation_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific overpayment
    ///
    ///Sends a `GET` request to `/Overpayments/{OverpaymentID}/History`
    ///
    ///Arguments:
    /// - `overpayment_id`: Unique identifier for a Overpayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_overpayment_history<'a>(
        &'a self,
        overpayment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Overpayments/{}/History",
            self.baseurl,
            encode_path(&overpayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific overpayment
    ///
    ///Sends a `PUT` request to `/Overpayments/{OverpaymentID}/History`
    ///
    ///Arguments:
    /// - `overpayment_id`: Unique identifier for a Overpayment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_overpayment_history<'a>(
        &'a self,
        overpayment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Overpayments/{}/History",
            self.baseurl,
            encode_path(&overpayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves payments for invoices and credit notes
    ///
    ///Sends a `GET` request to `/Payments`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: Up to 100 payments will be returned in a single API call
    /// - `page_size`: Number of records to retrieve per page
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_payments<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Payments>, Error<()>> {
        let url = format!("{}/Payments", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates multiple payments for invoices or credit notes
    ///
    ///Sends a `PUT` request to `/Payments`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Payments array with Payment object in body of request
    pub async fn create_payments<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Payments,
    ) -> Result<ResponseValue<types::Payments>, Error<types::Error>> {
        let url = format!("{}/Payments", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a single payment for invoice or credit notes
    ///
    ///Sends a `POST` request to `/Payments`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Request body with a single Payment object
    pub async fn create_payment<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Payment,
    ) -> Result<ResponseValue<types::Payments>, Error<types::Error>> {
        let url = format!("{}/Payments", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific payment for invoices and credit notes using a
    /// unique payment Id
    ///
    ///Sends a `GET` request to `/Payments/{PaymentID}`
    ///
    ///Arguments:
    /// - `payment_id`: Unique identifier for a Payment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_payment<'a>(
        &'a self,
        payment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Payments>, Error<()>> {
        let url = format!(
            "{}/Payments/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific payment for invoices and credit notes
    ///
    ///Sends a `POST` request to `/Payments/{PaymentID}`
    ///
    ///Arguments:
    /// - `payment_id`: Unique identifier for a Payment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn delete_payment<'a>(
        &'a self,
        payment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PaymentDelete,
    ) -> Result<ResponseValue<types::Payments>, Error<types::Error>> {
        let url = format!(
            "{}/Payments/{}",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific payment
    ///
    ///Sends a `GET` request to `/Payments/{PaymentID}/History`
    ///
    ///Arguments:
    /// - `payment_id`: Unique identifier for a Payment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_payment_history<'a>(
        &'a self,
        payment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Payments/{}/History",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific payment
    ///
    ///Sends a `PUT` request to `/Payments/{PaymentID}/History`
    ///
    ///Arguments:
    /// - `payment_id`: Unique identifier for a Payment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_payment_history<'a>(
        &'a self,
        payment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Payments/{}/History",
            self.baseurl,
            encode_path(&payment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves payment services
    ///
    ///Sends a `GET` request to `/PaymentServices`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_payment_services<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::PaymentServices>, Error<()>> {
        let url = format!("{}/PaymentServices", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a payment service
    ///
    ///Sends a `PUT` request to `/PaymentServices`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: PaymentServices array with PaymentService object in body of
    ///   request
    pub async fn create_payment_service<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PaymentServices,
    ) -> Result<ResponseValue<types::PaymentServices>, Error<types::Error>> {
        let url = format!("{}/PaymentServices", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves prepayments
    ///
    ///Sends a `GET` request to `/Prepayments`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 prepayments will be returned in a
    ///   single API call with line items shown for each overpayment
    /// - `page_size`: Number of records to retrieve per page
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_prepayments<'a>(
        &'a self,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Prepayments>, Error<()>> {
        let url = format!("{}/Prepayments", self.baseurl,);
        let mut query = Vec::with_capacity(5usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Allows you to retrieve a specified prepayments
    ///
    ///Sends a `GET` request to `/Prepayments/{PrepaymentID}`
    ///
    ///Arguments:
    /// - `prepayment_id`: Unique identifier for a PrePayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_prepayment<'a>(
        &'a self,
        prepayment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Prepayments>, Error<()>> {
        let url = format!(
            "{}/Prepayments/{}",
            self.baseurl,
            encode_path(&prepayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Allows you to create an Allocation for prepayments
    ///
    ///Sends a `PUT` request to `/Prepayments/{PrepaymentID}/Allocations`
    ///
    ///Arguments:
    /// - `prepayment_id`: Unique identifier for a PrePayment
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Allocations with an array of Allocation object in body of
    ///   request
    pub async fn create_prepayment_allocations<'a>(
        &'a self,
        prepayment_id: &'a uuid::Uuid,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Allocations,
    ) -> Result<ResponseValue<types::Allocations>, Error<types::Error>> {
        let url = format!(
            "{}/Prepayments/{}/Allocations",
            self.baseurl,
            encode_path(&prepayment_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes an Allocation from a Prepayment
    ///
    ///Sends a `DELETE` request to
    /// `/Prepayments/{PrepaymentID}/Allocations/{AllocationID}`
    ///
    ///Arguments:
    /// - `prepayment_id`: Unique identifier for a PrePayment
    /// - `allocation_id`: Unique identifier for Allocation object
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_prepayment_allocations<'a>(
        &'a self,
        prepayment_id: &'a uuid::Uuid,
        allocation_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Allocation>, Error<()>> {
        let url = format!(
            "{}/Prepayments/{}/Allocations/{}",
            self.baseurl,
            encode_path(&prepayment_id.to_string()),
            encode_path(&allocation_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history record for a specific prepayment
    ///
    ///Sends a `GET` request to `/Prepayments/{PrepaymentID}/History`
    ///
    ///Arguments:
    /// - `prepayment_id`: Unique identifier for a PrePayment
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_prepayment_history<'a>(
        &'a self,
        prepayment_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Prepayments/{}/History",
            self.baseurl,
            encode_path(&prepayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific prepayment
    ///
    ///Sends a `PUT` request to `/Prepayments/{PrepaymentID}/History`
    ///
    ///Arguments:
    /// - `prepayment_id`: Unique identifier for a PrePayment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_prepayment_history<'a>(
        &'a self,
        prepayment_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Prepayments/{}/History",
            self.baseurl,
            encode_path(&prepayment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves purchase orders
    ///
    ///Sends a `GET` request to `/PurchaseOrders`
    ///
    ///Arguments:
    /// - `date_from`: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
    /// - `date_to`: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
    /// - `status`: Filter by purchase order status
    /// - `order`: Order by an any element
    /// - `page`: To specify a page, append the page parameter to the URL e.g.
    ///   ?page=1. If there are 100 records in the response you will need to
    ///   check if there is any more data by fetching the next page e.g ?page=2
    ///   and continuing this process until no more results are returned.
    /// - `page_size`: Number of records to retrieve per page
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_orders<'a>(
        &'a self,
        date_from: Option<&'a str>,
        date_to: Option<&'a str>,
        status: Option<types::GetPurchaseOrdersStatus>,
        order: Option<&'a str>,
        page: Option<i64>,
        page_size: Option<i64>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<()>> {
        let url = format!("{}/PurchaseOrders", self.baseurl,);
        let mut query = Vec::with_capacity(6usize);
        if let Some(v) = &date_from {
            query.push(("DateFrom", v.to_string()));
        }

        if let Some(v) = &date_to {
            query.push(("DateTo", v.to_string()));
        }

        if let Some(v) = &status {
            query.push(("Status", v.to_string()));
        }

        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        if let Some(v) = &page_size {
            query.push(("pageSize", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more purchase orders
    ///
    ///Sends a `PUT` request to `/PurchaseOrders`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: PurchaseOrders with an array of PurchaseOrder object in body
    ///   of request
    pub async fn create_purchase_orders<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PurchaseOrders,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<types::Error>> {
        let url = format!("{}/PurchaseOrders", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more purchase orders
    ///
    ///Sends a `POST` request to `/PurchaseOrders`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_purchase_orders<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PurchaseOrders,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<types::Error>> {
        let url = format!("{}/PurchaseOrders", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves specific purchase order as PDF files using a unique purchase
    /// order Id
    ///
    ///Sends a `GET` request to `/PurchaseOrders/{PurchaseOrderID}/pdf`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_as_pdf<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}/pdf",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific purchase order using a unique purchase order Id
    ///
    ///Sends a `GET` request to `/PurchaseOrders/{PurchaseOrderID}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific purchase order
    ///
    ///Sends a `POST` request to `/PurchaseOrders/{PurchaseOrderID}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_purchase_order<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::PurchaseOrders,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<types::Error>> {
        let url = format!(
            "{}/PurchaseOrders/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific purchase order using purchase order number
    ///
    ///Sends a `GET` request to `/PurchaseOrders/{PurchaseOrderNumber}`
    ///
    ///Arguments:
    /// - `purchase_order_number`: Unique identifier for a PurchaseOrder
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_by_number<'a>(
        &'a self,
        purchase_order_number: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::PurchaseOrders>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}",
            self.baseurl,
            encode_path(&purchase_order_number.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history for a specific purchase order
    ///
    ///Sends a `GET` request to `/PurchaseOrders/{PurchaseOrderID}/History`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_history<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}/History",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific purchase orders
    ///
    ///Sends a `PUT` request to `/PurchaseOrders/{PurchaseOrderID}/History`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_purchase_order_history<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/PurchaseOrders/{}/History",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific purchase order
    ///
    ///Sends a `GET` request to `/PurchaseOrders/{PurchaseOrderID}/Attachments`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_attachments<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}/Attachments",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves specific attachment for a specific purchase order using a
    /// unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/PurchaseOrders/{PurchaseOrderID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_attachment_by_id<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}/Attachments/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment for a specific purchase order by
    /// filename
    ///
    ///Sends a `GET` request to
    /// `/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_purchase_order_attachment_by_file_name<'a>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/PurchaseOrders/{}/Attachments/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates attachment for a specific purchase order
    ///
    ///Sends a `PUT` request to
    /// `/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_purchase_order_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/PurchaseOrders/{}/Attachments/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment for a specific purchase order by filename
    ///
    ///Sends a `POST` request to
    /// `/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `purchase_order_id`: Unique identifier for an Purchase Order
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_purchase_order_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        purchase_order_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/PurchaseOrders/{}/Attachments/{}",
            self.baseurl,
            encode_path(&purchase_order_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves sales quotes
    ///
    ///Sends a `GET` request to `/Quotes`
    ///
    ///Arguments:
    /// - `contact_id`: Filter for quotes belonging to a particular contact
    /// - `date_from`: Filter for quotes after a particular date
    /// - `date_to`: Filter for quotes before a particular date
    /// - `expiry_date_from`: Filter for quotes expiring after a particular date
    /// - `expiry_date_to`: Filter for quotes before a particular date
    /// - `quote_number`: Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber=QU-0001)
    /// - `status`: Filter for quotes of a particular Status
    /// - `order`: Order by an any element
    /// - `page`: e.g. page=1 – Up to 100 Quotes will be returned in a single
    ///   API call with line items shown for each quote
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quotes<'a>(
        &'a self,
        contact_id: Option<&'a uuid::Uuid>,
        date_from: Option<&'a chrono::naive::NaiveDate>,
        date_to: Option<&'a chrono::naive::NaiveDate>,
        expiry_date_from: Option<&'a chrono::naive::NaiveDate>,
        expiry_date_to: Option<&'a chrono::naive::NaiveDate>,
        quote_number: Option<&'a str>,
        status: Option<&'a str>,
        order: Option<&'a str>,
        page: Option<i64>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Quotes>, Error<()>> {
        let url = format!("{}/Quotes", self.baseurl,);
        let mut query = Vec::with_capacity(9usize);
        if let Some(v) = &contact_id {
            query.push(("ContactID", v.to_string()));
        }

        if let Some(v) = &date_from {
            query.push(("DateFrom", v.to_string()));
        }

        if let Some(v) = &date_to {
            query.push(("DateTo", v.to_string()));
        }

        if let Some(v) = &expiry_date_from {
            query.push(("ExpiryDateFrom", v.to_string()));
        }

        if let Some(v) = &expiry_date_to {
            query.push(("ExpiryDateTo", v.to_string()));
        }

        if let Some(v) = &quote_number {
            query.push(("QuoteNumber", v.to_string()));
        }

        if let Some(v) = &status {
            query.push(("Status", v.to_string()));
        }

        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &page {
            query.push(("page", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create one or more quotes
    ///
    ///Sends a `PUT` request to `/Quotes`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Quotes with an array of Quote object in body of request
    pub async fn create_quotes<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Quotes,
    ) -> Result<ResponseValue<types::Quotes>, Error<types::Error>> {
        let url = format!("{}/Quotes", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates or creates one or more quotes
    ///
    ///Sends a `POST` request to `/Quotes`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_or_create_quotes<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Quotes,
    ) -> Result<ResponseValue<types::Quotes>, Error<types::Error>> {
        let url = format!("{}/Quotes", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific quote using a unique quote Id
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Quotes>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific quote
    ///
    ///Sends a `POST` request to `/Quotes/{QuoteID}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_quote<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Quotes,
    ) -> Result<ResponseValue<types::Quotes>, Error<types::Error>> {
        let url = format!(
            "{}/Quotes/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history records of a specific quote
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}/History`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote_history<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}/History",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific quote
    ///
    ///Sends a `PUT` request to `/Quotes/{QuoteID}/History`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_quote_history<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Quotes/{}/History",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific quote as a PDF file using a unique quote Id
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}/pdf`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote_as_pdf<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}/pdf",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific quote
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}/Attachments`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote_attachments<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}/Attachments",
            self.baseurl,
            encode_path(&quote_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific quote using a unique
    /// attachment Id
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote_attachment_by_id<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific quote by filename
    ///
    ///Sends a `GET` request to `/Quotes/{QuoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_quote_attachment_by_file_name<'a>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Quotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates attachment for a specific quote
    ///
    ///Sends a `PUT` request to `/Quotes/{QuoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_quote_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Quotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment from a specific quote by filename
    ///
    ///Sends a `POST` request to `/Quotes/{QuoteID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `quote_id`: Unique identifier for an Quote
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_quote_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        quote_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Quotes/{}/Attachments/{}",
            self.baseurl,
            encode_path(&quote_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves draft expense claim receipts for any user
    ///
    ///Sends a `GET` request to `/Receipts`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipts<'a>(
        &'a self,
        order: Option<&'a str>,
        unitdp: Option<i64>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Receipts>, Error<()>> {
        let url = format!("{}/Receipts", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates draft expense claim receipts for any user
    ///
    ///Sends a `PUT` request to `/Receipts`
    ///
    ///Arguments:
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Receipts with an array of Receipt object in body of request
    pub async fn create_receipt<'a>(
        &'a self,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Receipts,
    ) -> Result<ResponseValue<types::Receipts>, Error<types::Error>> {
        let url = format!("{}/Receipts", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific draft expense claim receipt by using a unique
    /// receipt Id
    ///
    ///Sends a `GET` request to `/Receipts/{ReceiptID}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipt<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Receipts>, Error<()>> {
        let url = format!(
            "{}/Receipts/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific draft expense claim receipts
    ///
    ///Sends a `POST` request to `/Receipts/{ReceiptID}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `unitdp`: e.g. unitdp=4 – (Unit Decimal Places) You can opt in to use
    ///   four decimal places for unit amounts
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_receipt<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        unitdp: Option<i64>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Receipts,
    ) -> Result<ResponseValue<types::Receipts>, Error<types::Error>> {
        let url = format!(
            "{}/Receipts/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &unitdp {
            query.push(("unitdp", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments for a specific expense claim receipt
    ///
    ///Sends a `GET` request to `/Receipts/{ReceiptID}/Attachments`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipt_attachments<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/Receipts/{}/Attachments",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachments from a specific expense claim receipts
    /// by using a unique attachment Id
    ///
    ///Sends a `GET` request to
    /// `/Receipts/{ReceiptID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipt_attachment_by_id<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Receipts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific expense claim receipts
    /// by file name
    ///
    ///Sends a `GET` request to `/Receipts/{ReceiptID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipt_attachment_by_file_name<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/Receipts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment on a specific expense claim receipts by file name
    ///
    ///Sends a `PUT` request to `/Receipts/{ReceiptID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_receipt_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Receipts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment on a specific expense claim receipts by
    /// file name
    ///
    ///Sends a `POST` request to `/Receipts/{ReceiptID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_receipt_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/Receipts/{}/Attachments/{}",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a history record for a specific receipt
    ///
    ///Sends a `GET` request to `/Receipts/{ReceiptID}/History`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_receipt_history<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/Receipts/{}/History",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a history record for a specific receipt
    ///
    ///Sends a `PUT` request to `/Receipts/{ReceiptID}/History`
    ///
    ///Arguments:
    /// - `receipt_id`: Unique identifier for a Receipt
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_receipt_history<'a>(
        &'a self,
        receipt_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/Receipts/{}/History",
            self.baseurl,
            encode_path(&receipt_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves repeating invoices
    ///
    ///Sends a `GET` request to `/RepeatingInvoices`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoices<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::RepeatingInvoices>, Error<()>> {
        let url = format!("{}/RepeatingInvoices", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more repeating invoice templates
    ///
    ///Sends a `PUT` request to `/RepeatingInvoices`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: RepeatingInvoices with an array of repeating invoice objects
    ///   in body of request
    pub async fn create_repeating_invoices<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::RepeatingInvoices,
    ) -> Result<ResponseValue<types::RepeatingInvoices>, Error<types::Error>> {
        let url = format!("{}/RepeatingInvoices", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates or deletes one or more repeating invoice templates
    ///
    ///Sends a `POST` request to `/RepeatingInvoices`
    ///
    ///Arguments:
    /// - `summarize_errors`: If false return 200 OK and mix of successfully
    ///   created objects and any with validation errors
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: RepeatingInvoices with an array of repeating invoice objects
    ///   in body of request
    pub async fn update_or_create_repeating_invoices<'a>(
        &'a self,
        summarize_errors: Option<bool>,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::RepeatingInvoices,
    ) -> Result<ResponseValue<types::RepeatingInvoices>, Error<types::Error>> {
        let url = format!("{}/RepeatingInvoices", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &summarize_errors {
            query.push(("summarizeErrors", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific repeating invoice by using a unique repeating
    /// invoice Id
    ///
    ///Sends a `GET` request to `/RepeatingInvoices/{RepeatingInvoiceID}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoice<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::RepeatingInvoices>, Error<()>> {
        let url = format!(
            "{}/RepeatingInvoices/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific repeating invoice template
    ///
    ///Sends a `POST` request to `/RepeatingInvoices/{RepeatingInvoiceID}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_repeating_invoice<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::RepeatingInvoices,
    ) -> Result<ResponseValue<types::RepeatingInvoices>, Error<types::Error>> {
        let url = format!(
            "{}/RepeatingInvoices/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves attachments from a specific repeating invoice
    ///
    ///Sends a `GET` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/Attachments`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoice_attachments<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Attachments>, Error<()>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/Attachments",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific repeating invoice
    ///
    ///Sends a `GET` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `attachment_id`: Unique identifier for Attachment object
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoice_attachment_by_id<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        attachment_id: &'a uuid::Uuid,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
            encode_path(&attachment_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific attachment from a specific repeating invoices by
    /// file name
    ///
    ///Sends a `GET` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `file_name`: Name of the attachment
    /// - `content_type`: The mime type of the attachment file you are
    ///   retrieving i.e image/jpg, application/pdf
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoice_attachment_by_file_name<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        content_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        header_map.append("contentType", HeaderValue::try_from(content_type)?);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates an attachment from a specific repeating invoices by file name
    ///
    ///Sends a `PUT` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn create_repeating_invoice_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific attachment from a specific repeating invoices by file
    /// name
    ///
    ///Sends a `POST` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `file_name`: Name of the attachment
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Byte array of file in body of request
    pub async fn update_repeating_invoice_attachment_by_file_name<'a, B: Into<reqwest::Body>>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        file_name: &'a str,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: B,
    ) -> Result<ResponseValue<types::Attachments>, Error<types::Error>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/Attachments/{}",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
            encode_path(&file_name.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                reqwest::header::CONTENT_TYPE,
                reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves history record for a specific repeating invoice
    ///
    ///Sends a `GET` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/History`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_repeating_invoice_history<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<()>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/History",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates a  history record for a specific repeating invoice
    ///
    ///Sends a `PUT` request to
    /// `/RepeatingInvoices/{RepeatingInvoiceID}/History`
    ///
    ///Arguments:
    /// - `repeating_invoice_id`: Unique identifier for a Repeating Invoice
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: HistoryRecords containing an array of HistoryRecord objects in
    ///   body of request
    pub async fn create_repeating_invoice_history<'a>(
        &'a self,
        repeating_invoice_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::HistoryRecords,
    ) -> Result<ResponseValue<types::HistoryRecords>, Error<types::Error>> {
        let url = format!(
            "{}/RepeatingInvoices/{}/History",
            self.baseurl,
            encode_path(&repeating_invoice_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve reports for 1099
    ///
    ///Sends a `GET` request to `/Reports/TenNinetyNine`
    ///
    ///Arguments:
    /// - `report_year`: The year of the 1099 report
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_ten_ninety_nine<'a>(
        &'a self,
        report_year: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Reports>, Error<()>> {
        let url = format!("{}/Reports/TenNinetyNine", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &report_year {
            query.push(("reportYear", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for aged payables by contact
    ///
    ///Sends a `GET` request to `/Reports/AgedPayablesByContact`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `date`: The date of the Aged Payables By Contact report
    /// - `from_date`: filter by the from date of the report e.g. 2021-02-01
    /// - `to_date`: filter by the to date of the report e.g. 2021-02-28
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_aged_payables_by_contact<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        date: Option<&'a chrono::naive::NaiveDate>,
        from_date: Option<&'a chrono::naive::NaiveDate>,
        to_date: Option<&'a chrono::naive::NaiveDate>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/AgedPayablesByContact", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("contactId", contact_id.to_string()));
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        if let Some(v) = &from_date {
            query.push(("fromDate", v.to_string()));
        }

        if let Some(v) = &to_date {
            query.push(("toDate", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for aged receivables by contact
    ///
    ///Sends a `GET` request to `/Reports/AgedReceivablesByContact`
    ///
    ///Arguments:
    /// - `contact_id`: Unique identifier for a Contact
    /// - `date`: The date of the Aged Receivables By Contact report
    /// - `from_date`: filter by the from date of the report e.g. 2021-02-01
    /// - `to_date`: filter by the to date of the report e.g. 2021-02-28
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_aged_receivables_by_contact<'a>(
        &'a self,
        contact_id: &'a uuid::Uuid,
        date: Option<&'a chrono::naive::NaiveDate>,
        from_date: Option<&'a chrono::naive::NaiveDate>,
        to_date: Option<&'a chrono::naive::NaiveDate>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/AgedReceivablesByContact", self.baseurl,);
        let mut query = Vec::with_capacity(4usize);
        query.push(("contactId", contact_id.to_string()));
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        if let Some(v) = &from_date {
            query.push(("fromDate", v.to_string()));
        }

        if let Some(v) = &to_date {
            query.push(("toDate", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for balancesheet
    ///
    ///Sends a `GET` request to `/Reports/BalanceSheet`
    ///
    ///Arguments:
    /// - `date`: The date of the Balance Sheet report
    /// - `payments_only`: return a cash basis for the Balance Sheet report
    /// - `periods`: The number of periods for the Balance Sheet report
    /// - `standard_layout`: The standard layout boolean for the Balance Sheet
    ///   report
    /// - `timeframe`: The period size to compare to (MONTH, QUARTER, YEAR)
    /// - `tracking_option_id1`: The tracking option 1 for the Balance Sheet
    ///   report
    /// - `tracking_option_id2`: The tracking option 2 for the Balance Sheet
    ///   report
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_balance_sheet<'a>(
        &'a self,
        date: Option<&'a chrono::naive::NaiveDate>,
        payments_only: Option<bool>,
        periods: Option<i64>,
        standard_layout: Option<bool>,
        timeframe: Option<types::GetReportBalanceSheetTimeframe>,
        tracking_option_id1: Option<&'a str>,
        tracking_option_id2: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/BalanceSheet", self.baseurl,);
        let mut query = Vec::with_capacity(7usize);
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        if let Some(v) = &payments_only {
            query.push(("paymentsOnly", v.to_string()));
        }

        if let Some(v) = &periods {
            query.push(("periods", v.to_string()));
        }

        if let Some(v) = &standard_layout {
            query.push(("standardLayout", v.to_string()));
        }

        if let Some(v) = &timeframe {
            query.push(("timeframe", v.to_string()));
        }

        if let Some(v) = &tracking_option_id1 {
            query.push(("trackingOptionID1", v.to_string()));
        }

        if let Some(v) = &tracking_option_id2 {
            query.push(("trackingOptionID2", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for bank summary
    ///
    ///Sends a `GET` request to `/Reports/BankSummary`
    ///
    ///Arguments:
    /// - `from_date`: filter by the from date of the report e.g. 2021-02-01
    /// - `to_date`: filter by the to date of the report e.g. 2021-02-28
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_bank_summary<'a>(
        &'a self,
        from_date: Option<&'a chrono::naive::NaiveDate>,
        to_date: Option<&'a chrono::naive::NaiveDate>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/BankSummary", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &from_date {
            query.push(("fromDate", v.to_string()));
        }

        if let Some(v) = &to_date {
            query.push(("toDate", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific report using a unique ReportID
    ///
    ///Sends a `GET` request to `/Reports/{ReportID}`
    ///
    ///Arguments:
    /// - `report_id`: Unique identifier for a Report
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_from_id<'a>(
        &'a self,
        report_id: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!(
            "{}/Reports/{}",
            self.baseurl,
            encode_path(&report_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for budget summary
    ///
    ///Sends a `GET` request to `/Reports/BudgetSummary`
    ///
    ///Arguments:
    /// - `date`: The date for the Bank Summary report e.g. 2018-03-31
    /// - `periods`: The number of periods to compare (integer between 1 and 12)
    /// - `timeframe`: The period size to compare to (1=month, 3=quarter,
    ///   12=year)
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_budget_summary<'a>(
        &'a self,
        date: Option<&'a chrono::naive::NaiveDate>,
        periods: Option<i64>,
        timeframe: Option<i64>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/BudgetSummary", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        if let Some(v) = &periods {
            query.push(("periods", v.to_string()));
        }

        if let Some(v) = &timeframe {
            query.push(("timeframe", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for executive summary
    ///
    ///Sends a `GET` request to `/Reports/ExecutiveSummary`
    ///
    ///Arguments:
    /// - `date`: The date for the Bank Summary report e.g. 2018-03-31
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_executive_summary<'a>(
        &'a self,
        date: Option<&'a chrono::naive::NaiveDate>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/ExecutiveSummary", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a list of the organistaions unique reports that require a uuid
    /// to fetch
    ///
    ///Sends a `GET` request to `/Reports`
    ///
    ///Arguments:
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_reports_list<'a>(
        &'a self,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for profit and loss
    ///
    ///Sends a `GET` request to `/Reports/ProfitAndLoss`
    ///
    ///Arguments:
    /// - `from_date`: filter by the from date of the report e.g. 2021-02-01
    /// - `payments_only`: Return cash only basis for the ProfitAndLoss report
    /// - `periods`: The number of periods to compare (integer between 1 and 12)
    /// - `standard_layout`: Return the standard layout for the ProfitAndLoss
    ///   report
    /// - `timeframe`: The period size to compare to (MONTH, QUARTER, YEAR)
    /// - `to_date`: filter by the to date of the report e.g. 2021-02-28
    /// - `tracking_category_id`: The trackingCategory 1 for the ProfitAndLoss
    ///   report
    /// - `tracking_category_id2`: The trackingCategory 2 for the ProfitAndLoss
    ///   report
    /// - `tracking_option_id`: The tracking option 1 for the ProfitAndLoss
    ///   report
    /// - `tracking_option_id2`: The tracking option 2 for the ProfitAndLoss
    ///   report
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_profit_and_loss<'a>(
        &'a self,
        from_date: Option<&'a chrono::naive::NaiveDate>,
        payments_only: Option<bool>,
        periods: Option<i64>,
        standard_layout: Option<bool>,
        timeframe: Option<types::GetReportProfitAndLossTimeframe>,
        to_date: Option<&'a chrono::naive::NaiveDate>,
        tracking_category_id: Option<&'a str>,
        tracking_category_id2: Option<&'a str>,
        tracking_option_id: Option<&'a str>,
        tracking_option_id2: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/ProfitAndLoss", self.baseurl,);
        let mut query = Vec::with_capacity(10usize);
        if let Some(v) = &from_date {
            query.push(("fromDate", v.to_string()));
        }

        if let Some(v) = &payments_only {
            query.push(("paymentsOnly", v.to_string()));
        }

        if let Some(v) = &periods {
            query.push(("periods", v.to_string()));
        }

        if let Some(v) = &standard_layout {
            query.push(("standardLayout", v.to_string()));
        }

        if let Some(v) = &timeframe {
            query.push(("timeframe", v.to_string()));
        }

        if let Some(v) = &to_date {
            query.push(("toDate", v.to_string()));
        }

        if let Some(v) = &tracking_category_id {
            query.push(("trackingCategoryID", v.to_string()));
        }

        if let Some(v) = &tracking_category_id2 {
            query.push(("trackingCategoryID2", v.to_string()));
        }

        if let Some(v) = &tracking_option_id {
            query.push(("trackingOptionID", v.to_string()));
        }

        if let Some(v) = &tracking_option_id2 {
            query.push(("trackingOptionID2", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves report for trial balance
    ///
    ///Sends a `GET` request to `/Reports/TrialBalance`
    ///
    ///Arguments:
    /// - `date`: The date for the Trial Balance report e.g. 2018-03-31
    /// - `payments_only`: Return cash only basis for the Trial Balance report
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_report_trial_balance<'a>(
        &'a self,
        date: Option<&'a chrono::naive::NaiveDate>,
        payments_only: Option<bool>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::ReportWithRows>, Error<()>> {
        let url = format!("{}/Reports/TrialBalance", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &date {
            query.push(("date", v.to_string()));
        }

        if let Some(v) = &payments_only {
            query.push(("paymentsOnly", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Sets the chart of accounts, the conversion date and conversion balances
    ///
    ///Sends a `POST` request to `/Setup`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: Object including an accounts array, a conversion balances
    ///   array and a conversion date object in body of request
    pub async fn post_setup<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::Setup,
    ) -> Result<ResponseValue<types::ImportSummaryObject>, Error<()>> {
        let url = format!("{}/Setup", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves tax rates
    ///
    ///Sends a `GET` request to `/TaxRates`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_tax_rates<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TaxRates>, Error<()>> {
        let url = format!("{}/TaxRates", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates one or more tax rates
    ///
    ///Sends a `PUT` request to `/TaxRates`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: TaxRates array with TaxRate object in body of request
    pub async fn create_tax_rates<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TaxRates,
    ) -> Result<ResponseValue<types::TaxRates>, Error<types::Error>> {
        let url = format!("{}/TaxRates", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates tax rates
    ///
    ///Sends a `POST` request to `/TaxRates`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_tax_rate<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TaxRates,
    ) -> Result<ResponseValue<types::TaxRates>, Error<types::Error>> {
        let url = format!("{}/TaxRates", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific tax rate according to given TaxType code
    ///
    ///Sends a `GET` request to `/TaxRates/{TaxType}`
    ///
    ///Arguments:
    /// - `tax_type`: A valid TaxType code
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_tax_rate_by_tax_type<'a>(
        &'a self,
        tax_type: &'a str,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TaxRates>, Error<()>> {
        let url = format!(
            "{}/TaxRates/{}",
            self.baseurl,
            encode_path(&tax_type.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves tracking categories and options
    ///
    ///Sends a `GET` request to `/TrackingCategories`
    ///
    ///Arguments:
    /// - `include_archived`: e.g. includeArchived=true - Categories and options
    ///   with a status of ARCHIVED will be included in the response
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_tracking_categories<'a>(
        &'a self,
        include_archived: Option<bool>,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TrackingCategories>, Error<()>> {
        let url = format!("{}/TrackingCategories", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &include_archived {
            query.push(("includeArchived", v.to_string()));
        }

        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create tracking categories
    ///
    ///Sends a `PUT` request to `/TrackingCategories`
    ///
    ///Arguments:
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: TrackingCategory object in body of request
    pub async fn create_tracking_category<'a>(
        &'a self,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TrackingCategory,
    ) -> Result<ResponseValue<types::TrackingCategories>, Error<types::Error>> {
        let url = format!("{}/TrackingCategories", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves specific tracking categories and options using a unique
    /// tracking category Id
    ///
    ///Sends a `GET` request to `/TrackingCategories/{TrackingCategoryID}`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_tracking_category<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TrackingCategories>, Error<()>> {
        let url = format!(
            "{}/TrackingCategories/{}",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific tracking category
    ///
    ///Sends a `POST` request to `/TrackingCategories/{TrackingCategoryID}`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_tracking_category<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TrackingCategory,
    ) -> Result<ResponseValue<types::TrackingCategories>, Error<types::Error>> {
        let url = format!(
            "{}/TrackingCategories/{}",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific tracking category
    ///
    ///Sends a `DELETE` request to `/TrackingCategories/{TrackingCategoryID}`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_tracking_category<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TrackingCategories>, Error<types::Error>> {
        let url = format!(
            "{}/TrackingCategories/{}",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Creates options for a specific tracking category
    ///
    ///Sends a `PUT` request to
    /// `/TrackingCategories/{TrackingCategoryID}/Options`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`: TrackingOption object in body of request
    pub async fn create_tracking_options<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TrackingOption,
    ) -> Result<ResponseValue<types::TrackingOptions>, Error<types::Error>> {
        let url = format!(
            "{}/TrackingCategories/{}/Options",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a specific option for a specific tracking category
    ///
    ///Sends a `POST` request to
    /// `/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `tracking_option_id`: Unique identifier for a Tracking Option
    /// - `idempotency_key`: This allows you to safely retry requests without
    ///   the risk of duplicate processing. 128 character max.
    /// - `xero_tenant_id`: Xero identifier for Tenant
    /// - `body`
    pub async fn update_tracking_options<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        tracking_option_id: &'a uuid::Uuid,
        idempotency_key: Option<&'a str>,
        xero_tenant_id: &'a str,
        body: &'a types::TrackingOption,
    ) -> Result<ResponseValue<types::TrackingOptions>, Error<types::Error>> {
        let url = format!(
            "{}/TrackingCategories/{}/Options/{}",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
            encode_path(&tracking_option_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = idempotency_key {
            header_map.append("Idempotency-Key", HeaderValue::try_from(v)?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a specific option for a specific tracking category
    ///
    ///Sends a `DELETE` request to
    /// `/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}`
    ///
    ///Arguments:
    /// - `tracking_category_id`: Unique identifier for a TrackingCategory
    /// - `tracking_option_id`: Unique identifier for a Tracking Option
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn delete_tracking_options<'a>(
        &'a self,
        tracking_category_id: &'a uuid::Uuid,
        tracking_option_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::TrackingOptions>, Error<types::Error>> {
        let url = format!(
            "{}/TrackingCategories/{}/Options/{}",
            self.baseurl,
            encode_path(&tracking_category_id.to_string()),
            encode_path(&tracking_option_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves users
    ///
    ///Sends a `GET` request to `/Users`
    ///
    ///Arguments:
    /// - `order`: Order by an any element
    /// - `where_`: Filter by an any element
    /// - `if_modified_since`: Only records created or modified since this
    ///   timestamp will be returned
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_users<'a>(
        &'a self,
        order: Option<&'a str>,
        where_: Option<&'a str>,
        if_modified_since: Option<&'a chrono::DateTime<chrono::offset::Utc>>,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Users>, Error<()>> {
        let url = format!("{}/Users", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &order {
            query.push(("order", v.to_string()));
        }

        if let Some(v) = &where_ {
            query.push(("where", v.to_string()));
        }

        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = if_modified_since {
            header_map.append("If-Modified-Since", HeaderValue::try_from(v.to_string())?);
        }

        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieves a specific user
    ///
    ///Sends a `GET` request to `/Users/{UserID}`
    ///
    ///Arguments:
    /// - `user_id`: Unique identifier for a User
    /// - `xero_tenant_id`: Xero identifier for Tenant
    pub async fn get_user<'a>(
        &'a self,
        user_id: &'a uuid::Uuid,
        xero_tenant_id: &'a str,
    ) -> Result<ResponseValue<types::Users>, Error<()>> {
        let url = format!(
            "{}/Users/{}",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        header_map.append("xero-tenant-id", HeaderValue::try_from(xero_tenant_id)?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
